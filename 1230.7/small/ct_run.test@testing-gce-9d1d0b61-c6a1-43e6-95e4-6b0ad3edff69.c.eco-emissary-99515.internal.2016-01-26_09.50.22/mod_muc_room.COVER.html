<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/travis/build/esl/MongooseIM/apps/ejabberd/logs/ct_run.test@testing-gce-9d1d0b61-c6a1-43e6-95e4-6b0ad3edff69.c.eco-emissary-99515.internal.2016-01-26_09.50.22/mod_muc_room.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/esl/MongooseIM/apps/ejabberd/ebin/../src/mod_muc_room.erl by COVER 2016-01-26 at 09:51:35

****************************************************************************

        |  %%%----------------------------------------------------------------------
        |  %%% File    : mod_muc_room.erl
        |  %%% Author  : Alexey Shchepin &lt;alexey@process-one.net&gt;
        |  %%% Purpose : MUC room stuff
        |  %%% Created : 19 Mar 2003 by Alexey Shchepin &lt;alexey@process-one.net&gt;
        |  %%%
        |  %%%
        |  %%% ejabberd, Copyright (C) 2002-2011   ProcessOne
        |  %%%
        |  %%% This program is free software; you can redistribute it and/or
        |  %%% modify it under the terms of the GNU General Public License as
        |  %%% published by the Free Software Foundation; either version 2 of the
        |  %%% License, or (at your option) any later version.
        |  %%%
        |  %%% This program is distributed in the hope that it will be useful,
        |  %%% but WITHOUT ANY WARRANTY; without even the implied warranty of
        |  %%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        |  %%% General Public License for more details.
        |  %%%
        |  %%% You should have received a copy of the GNU General Public License
        |  %%% along with this program; if not, write to the Free Software
        |  %%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
        |  %%% 02111-1307 USA
        |  %%%
        |  %%%----------------------------------------------------------------------
        |  
        |  -module(mod_muc_room).
        |  -author('alexey@process-one.net').
        |  -behaviour(gen_fsm).
        |  
        |  
        |  %% External exports
        |  -export([start_link/9,
        |           start_link/7,
        |           start/9,
        |           start/7,
        |           route/4]).
        |  
        |  %% API exports
        |  -export([get_room_users/1,
        |           is_room_owner/2]).
        |  
        |  %% gen_fsm callbacks
        |  -export([init/1,
        |           normal_state/2,
        |           locked_state/2,
        |           initial_state/2,
        |           handle_event/3,
        |           handle_sync_event/4,
        |           handle_info/3,
        |           terminate/3,
        |           code_change/4]).
        |  
        |  -include("ejabberd.hrl").
        |  -include("jlib.hrl").
        |  -include("mod_muc_room.hrl").
        |  
        |  -record(routed_message, {allowed,
        |                           type,
        |                           from,
        |                           packet,
        |                           lang
        |                          }).
        |  -type routed_message() :: #routed_message{}.
        |  
        |  -record(routed_nick_message, {allow_pm,
        |                                online,
        |                                type,
        |                                from,
        |                                nick,
        |                                lang,
        |                                packet,
        |                                decide,
        |                                jid
        |                              }).
        |  -type routed_nick_message() :: #routed_nick_message{}.
        |  
        |  -record(routed_iq, {iq,
        |                      from,
        |                      packet
        |                     }).
        |  -type routed_iq() :: #routed_iq{}.
        |  
        |  -record(routed_nick_iq, {allow_query,
        |                           online,
        |                           iq,
        |                           packet,
        |                           lang,
        |                           nick,
        |                           jid,
        |                           from,
        |                           stanza
        |                         }).
        |  -type routed_nick_iq() :: #routed_nick_iq{}.
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% Types
        |  %%%----------------------------------------------------------------------
        |  -export_type([config/0, user/0, activity/0]).
        |  
        |  -type statename() :: 'locked_state' | 'normal_state'.
        |  -type fsm_return() :: {'next_state', statename(), state()}
        |                      | {'stop', any(), state()}.
        |  
        |  -type lqueue() :: #lqueue{}.
        |  -type state() :: #state{}.
        |  -type config() :: #config{}.
        |  -type user() :: #user{}.
        |  -type activity() :: #activity{}.
        |  -type stanzaid() :: {binary(), ejabberd:resource()}.
        |  -type new_user_strategy() :: 'allowed'
        |                             | 'conflict_registered'
        |                             | 'conflict_use'
        |                             | 'invalid_password'
        |                             | 'limit_reached'
        |                             | 'require_membership'
        |                             | 'require_password'
        |                             | 'user_banned'.
        |  -type users_dict() :: dict:dict(ejabberd:simple_jid(), user()).
        |  -type sessions_dict() :: dict:dict(mod_muc:nick(), ejabberd:jid()).
        |  
        |  -define(MAX_USERS_DEFAULT_LIST,
        |          [5, 10, 20, 30, 50, 100, 200, 500, 1000, 2000, 5000]).
        |  
        |  %-define(DBGFSM, true).
        |  
        |  -ifdef(DBGFSM).
        |  -define(FSMOPTS, [{debug, [trace]}]).
        |  -else.
        |  -define(FSMOPTS, []).
        |  -endif.
        |  
        |  %% Module start with or without supervisor:
        |  -ifdef(NO_TRANSIENT_SUPERVISORS).
        |  -define(SUPERVISOR_START,
        |          gen_fsm:start(?MODULE,
        |                        [Host, ServerHost, Access, Room, HistorySize,
        |                         RoomShaper, Creator, Nick, DefRoomOpts],
        |                        ?FSMOPTS)).
        |  -else.
        |  -define(SUPERVISOR_START,
        |          Supervisor = gen_mod:get_module_proc(ServerHost, ejabberd_mod_muc_sup),
        |          supervisor:start_child(Supervisor,
        |                                 [Host, ServerHost, Access, Room, HistorySize,
        |                                  RoomShaper, Creator, Nick, DefRoomOpts])).
        |  -endif.
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% API
        |  %%%----------------------------------------------------------------------
        |  -spec start(Host :: ejabberd:server(), ServerHost :: ejabberd:server(),
        |          Access :: _, Room :: mod_muc:room(), HistorySize :: integer(),
        |          RoomShaper :: shaper:shaper(), Creator :: ejabberd:jid(),
        |          Nick :: mod_muc:nick(), DefRoomOpts :: list()) -&gt; {'error',_}
        |                                                  | {'ok','undefined' | pid()}
        |                                                  | {'ok','undefined' | pid(),_}.
        |  start(Host, ServerHost, Access, Room, HistorySize, RoomShaper,
        |        Creator, Nick, DefRoomOpts) -&gt;
<font color=red>     0..|      ?SUPERVISOR_START.</font>
        |  
        |  
        |  -spec start(Host :: ejabberd:server(), ServerHost :: ejabberd:server(),
        |          Access :: _, Room :: mod_muc:room(), HistorySize :: integer(),
        |          RoomShaper :: shaper:shaper(), Opts :: list()) -&gt; {'error',_}
        |                                                  | {'ok','undefined' | pid()}
        |                                                  | {'ok','undefined' | pid(),_}.
        |  start(Host, ServerHost, Access, Room, HistorySize, RoomShaper, Opts) -&gt;
<font color=red>     0..|      Supervisor = gen_mod:get_module_proc(ServerHost, ejabberd_mod_muc_sup),</font>
<font color=red>     0..|      supervisor:start_child(Supervisor, [Host, ServerHost, Access, Room,</font>
        |                                          HistorySize, RoomShaper, Opts]).
        |  
        |  start_link(Host, ServerHost, Access, Room, HistorySize, RoomShaper,
        |         Creator, Nick, DefRoomOpts) -&gt;
<font color=red>     0..|      gen_fsm:start_link(?MODULE,</font>
        |                         [Host, ServerHost, Access, Room, HistorySize,
        |                          RoomShaper, Creator, Nick, DefRoomOpts],
        |                         ?FSMOPTS).
        |  
        |  start_link(Host, ServerHost, Access, Room, HistorySize, RoomShaper, Opts) -&gt;
<font color=red>     0..|      gen_fsm:start_link(?MODULE,</font>
        |                         [Host, ServerHost, Access, Room, HistorySize,
        |                          RoomShaper, Opts],
        |                         ?FSMOPTS).
        |  
        |  
        |  -spec get_room_users(RoomJID :: ejabberd:jid()) -&gt; {ok, [#user{}]}
        |                                                   | {error, not_found}.
        |  get_room_users(RoomJID) -&gt;
<font color=red>     0..|      case mod_muc:room_jid_to_pid(RoomJID) of</font>
        |          {ok, Pid} -&gt;
<font color=red>     0..|              gen_fsm:sync_send_all_state_event(Pid, get_room_users);</font>
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  -spec is_room_owner( RoomJID :: ejabberd:jid()
        |                     , UserJID :: ejabberd:jid()
        |                     ) -&gt; {ok, boolean()} | {error, not_found}.
        |  is_room_owner(RoomJID, UserJID) -&gt;
<font color=red>     0..|      case mod_muc:room_jid_to_pid(RoomJID) of</font>
        |          {ok, Pid} -&gt;
<font color=red>     0..|              gen_fsm:sync_send_all_state_event(Pid, {is_room_owner, UserJID});</font>
        |          {error, Reason} -&gt;
<font color=red>     0..|              {error, Reason}</font>
        |      end.
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% Callback functions from gen_fsm
        |  %%%----------------------------------------------------------------------
        |  
        |  %%-----------------------------------------------------------------------
        |  %% Func: init/1
        |  %% Returns: {ok, StateName, StateData}          |
        |  %%          {ok, StateName, StateData, Timeout} |
        |  %%          ignore                              |
        |  %%          {stop, StopReason}
        |  %%-----------------------------------------------------------------------
        |  
        |  %% @doc A room is created. Depending on request type (MUC/groupchat 1.0) the
        |  %% next state is determined accordingly (a locked room for MUC or an instant
        |  %% one for groupchat).
        |  -spec init([any(),...]) -&gt; {'ok',statename(), state()}.
        |  init([Host, ServerHost, Access, Room, HistorySize, RoomShaper, Creator, _Nick,
        |        DefRoomOpts]) -&gt;
<font color=red>     0..|      process_flag(trap_exit, true),</font>
<font color=red>     0..|      Shaper = shaper:new(RoomShaper),</font>
<font color=red>     0..|      State = set_affiliation(Creator, owner,</font>
        |                              #state{host = Host,
        |                                     server_host = ServerHost,
        |                                     access = Access,
        |                                     room = Room,
        |                                     history = lqueue_new(HistorySize),
        |                                     jid = jid:make(Room, Host, &lt;&lt;&gt;&gt;),
        |                                     just_created = true,
        |                                     room_shaper = Shaper}),
<font color=red>     0..|      State1 = set_opts(DefRoomOpts, State),</font>
<font color=red>     0..|      ?INFO_MSG("Created MUC room ~s@~s by ~s",</font>
        |                [Room, Host, jid:to_binary(Creator)]),
<font color=red>     0..|      add_to_log(room_existence, created, State1),</font>
<font color=red>     0..|      NextState = case proplists:get_value(instant, DefRoomOpts, false) of</font>
        |                      true -&gt;
        |                          %% Instant room -- groupchat 1.0 request
<font color=red>     0..|                          add_to_log(room_existence, started, State1),</font>
<font color=red>     0..|                          normal_state;</font>
        |                      false -&gt;
        |                          %% Locked room waiting for configuration -- MUC request
<font color=red>     0..|                          initial_state</font>
        |                  end,
<font color=red>     0..|      {ok, NextState, State1};</font>
        |  
        |  
        |  %% @doc A room is restored
        |  init([Host, ServerHost, Access, Room, HistorySize, RoomShaper, Opts]) -&gt;
<font color=red>     0..|      process_flag(trap_exit, true),</font>
<font color=red>     0..|      Shaper = shaper:new(RoomShaper),</font>
<font color=red>     0..|      State = set_opts(Opts, #state{host = Host,</font>
        |                                    server_host = ServerHost,
        |                                    access = Access,
        |                                    room = Room,
        |                                    history = lqueue_new(HistorySize),
        |                                    jid = jid:make(Room, Host, &lt;&lt;&gt;&gt;),
        |                                    room_shaper = Shaper}),
<font color=red>     0..|      add_to_log(room_existence, started, State),</font>
<font color=red>     0..|      {ok, normal_state, State}.</font>
        |  
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: StateName/2
        |  %% Returns: {next_state, NextStateName, NextStateData}          |
        |  %%          {next_state, NextStateName, NextStateData, Timeout} |
        |  %%          {stop, Reason, NewStateData}
        |  %%----------------------------------------------------------------------
        |  
        |  %% @doc In the locked state StateData contains the same settings it previously
        |  %% held for the normal_state. The fsm awaits either a confirmation or a
        |  %% configuration form from the creator. Responds with error to any other queries.
        |  -spec locked_error({'route',ejabberd:jid(),_,jlib:xmlel()},
        |                     statename(), state()) -&gt; fsm_return().
        |  locked_error({route, From, ToNick, #xmlel{attrs = Attrs} = Packet},
        |               NextState, StateData) -&gt;
<font color=red>     0..|      ?INFO_MSG("Wrong stanza: ~p", [Packet]),</font>
<font color=red>     0..|      ErrText = &lt;&lt;"This room is locked"&gt;&gt;,</font>
<font color=red>     0..|      Lang = xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      Err = jlib:make_error_reply(Packet, ?ERRT_ITEM_NOT_FOUND(Lang, ErrText)),</font>
<font color=red>     0..|      ejabberd_router:route(jid:replace_resource(StateData#state.jid,</font>
        |                                                 ToNick),
        |                            From, Err),
<font color=red>     0..|      {next_state, NextState, StateData}.</font>
        |  
        |  %% @doc  Receive the room-creating Stanza. Will crash if any other stanza is
        |  %% received in this state.
        |  -spec initial_state({'route', From :: ejabberd:jid(), To :: mod_muc:nick(),
        |                      Presence :: jlib:xmlel()}, state()) -&gt; fsm_return().
        |  initial_state({route, From, ToNick,
        |                #xmlel{name = &lt;&lt;"presence"&gt;&gt;} = Presence}, StateData) -&gt;
        |      %% this should never happen so crash if it does
<font color=red>     0..|      &lt;&lt;&gt;&gt; = exml_query:attr(Presence, &lt;&lt;"type"&gt;&gt;, &lt;&lt;&gt;&gt;),</font>
<font color=red>     0..|      XNamespaces = exml_query:paths(Presence, [{element, &lt;&lt;"x"&gt;&gt;}, {attr, &lt;&lt;"xmlns"&gt;&gt;}]),</font>
<font color=red>     0..|      case lists:member(?NS_MUC, XNamespaces) of</font>
        |          true -&gt;
        |              %% FIXME
<font color=red>     0..|              add_to_log(room_existence, started, StateData),</font>
<font color=red>     0..|              process_presence(From, ToNick, Presence, StateData, locked_state);</font>
        |              %% The fragment of normal_state with Activity that used to do this - how does that work?
        |              %% Seems to work without it
        |          false -&gt;
        |              %% groupchat 1.0 user, straight to normal_state
<font color=red>     0..|              process_presence(From, ToNick, Presence, StateData)</font>
        |      end.
        |  
        |  
        |  -spec is_query_allowed(jlib:xmlel()) -&gt; boolean().
        |  is_query_allowed(Query) -&gt;
<font color=red>     0..|      X = xml:get_subtag(Query, &lt;&lt;"x"&gt;&gt;),</font>
<font color=red>     0..|      xml:get_subtag(Query, &lt;&lt;"destroy"&gt;&gt;) =/= false orelse</font>
<font color=red>     0..|          (X =/= false andalso xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, X)== ?NS_XDATA andalso</font>
<font color=red>     0..|          (xml:get_tag_attr_s(&lt;&lt;"type"&gt;&gt;, X) == &lt;&lt;"submit"&gt;&gt; orelse</font>
<font color=red>     0..|          xml:get_tag_attr_s(&lt;&lt;"type"&gt;&gt;, X)== &lt;&lt;"cancel"&gt;&gt;)).</font>
        |  
        |  
        |  -spec locked_state_process_owner_iq(ejabberd:jid(), jlib:xmlel(),
        |          ejabberd:lang(), 'error' | 'get' | 'invalid' | 'result',_)
        |              -&gt; {{'error', jlib:xmlel()}, statename()}
        |                 | {result, [jlib:xmlel() | jlib:xmlcdata()], state() | stop}.
        |  locked_state_process_owner_iq(From, Query, Lang, set, StateData) -&gt;
<font color=red>     0..|      Result = case is_query_allowed(Query) of</font>
        |                   true -&gt;
<font color=red>     0..|                       process_iq_owner(From, set, Lang, Query, StateData);</font>
        |                   false -&gt;
<font color=red>     0..|                       {error, ?ERRT_ITEM_NOT_FOUND(Lang, &lt;&lt;"Query not allowed"&gt;&gt;)}</font>
        |               end,
<font color=red>     0..|      {Result, normal_state};</font>
        |  locked_state_process_owner_iq(From, Query, Lang, get, StateData) -&gt;
<font color=red>     0..|      {process_iq_owner(From, get, Lang, Query, StateData), locked_state};</font>
        |  locked_state_process_owner_iq(_From, _Query, Lang, _Type, _StateData) -&gt;
<font color=red>     0..|      {{error, ?ERRT_ITEM_NOT_FOUND(Lang, &lt;&lt;"Wrong type"&gt;&gt;)}, locked_state}.</font>
        |  
        |  
        |  %% @doc Destroy room / confirm instant room / configure room
        |  -spec locked_state({'route',From :: ejabberd:jid(), To :: mod_muc:nick(),
        |                     Packet :: jlib:xmlel()}, state()) -&gt; fsm_return().
        |  locked_state({route, From, _ToNick,
        |                #xmlel{name = &lt;&lt;"iq"&gt;&gt;} = Packet}, StateData) -&gt;
<font color=red>     0..|      #iq{lang = Lang, sub_el = Query} = IQ = jlib:iq_query_info(Packet),</font>
<font color=red>     0..|      {Result, NextState1} =</font>
<font color=red>     0..|          case IQ#iq.xmlns == ?NS_MUC_OWNER andalso get_affiliation(From, StateData)  =:= owner of</font>
        |              true -&gt;
<font color=red>     0..|                  locked_state_process_owner_iq(From, Query, Lang, IQ#iq.type, StateData);</font>
        |              false -&gt;
<font color=red>     0..|                  ErrText = &lt;&lt;"This room is locked"&gt;&gt;,</font>
<font color=red>     0..|                  {{error, ?ERRT_ITEM_NOT_FOUND(Lang, ErrText)}, locked_state}</font>
        |          end,
<font color=red>     0..|      MkQueryResult = fun(Res) -&gt;</font>
<font color=red>     0..|                          IQ#iq{type = result,</font>
        |                              sub_el = [#xmlel{name = &lt;&lt;"query"&gt;&gt;,
        |                                               attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_OWNER}],
        |                                               children = Res}]}
        |                      end,
<font color=red>     0..|      {IQRes, StateData3, NextState2} =</font>
        |          case Result of
<font color=red>     0..|              {result, InnerRes, stop} -&gt; {MkQueryResult(InnerRes), StateData, stop};</font>
<font color=red>     0..|              {result, InnerRes, StateData2} -&gt; {MkQueryResult(InnerRes), StateData2, NextState1};</font>
<font color=red>     0..|              {error, Error} -&gt; {IQ#iq{type = error, sub_el = [Query, Error]}, StateData, NextState1}</font>
        |          end,
<font color=red>     0..|      ejabberd_router:route(StateData3#state.jid, From, jlib:iq_to_xml(IQRes)),</font>
<font color=red>     0..|      case NextState2 of</font>
        |          stop -&gt;
<font color=red>     0..|              {stop, normal, StateData3};</font>
        |          locked_state -&gt;
<font color=red>     0..|              {next_state, NextState2, StateData3};</font>
        |          normal_state -&gt;
<font color=red>     0..|              {next_state, NextState2, StateData3#state{just_created = false}}</font>
        |      end;
        |  %% Let owner leave. Destroy the room.
        |  locked_state({route, From, ToNick,
        |                #xmlel{name = &lt;&lt;"presence"&gt;&gt;, attrs = Attrs} = Presence} = Call,
        |               StateData) -&gt;
<font color=red>     0..|      case xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs) =:= &lt;&lt;"unavailable"&gt;&gt;</font>
<font color=red>     0..|          andalso get_affiliation(From, StateData)  =:= owner of</font>
        |          true -&gt;
        |              %% Will let the owner leave and destroy the room if it's not persistant
        |              %% The rooms are not persistent by default, but just to be safe...
<font color=red>     0..|              StateData1 = StateData#state{config = (StateData#state.config)#config{persistent = false}},</font>
<font color=red>     0..|              process_presence(From, ToNick, Presence, StateData1, locked_state);</font>
        |          _ -&gt;
<font color=red>     0..|              locked_error(Call, locked_state, StateData)</font>
        |      end;
        |  locked_state(Call, StateData) -&gt;
<font color=red>     0..|      locked_error(Call, locked_state, StateData).</font>
        |  
        |  
        |  -spec normal_state({route, From :: ejabberd:jid(), To :: mod_muc:nick(),
        |                     Packet :: jlib:xmlel()}, state()) -&gt; fsm_return().
        |  normal_state({route, From, &lt;&lt;&gt;&gt;,
        |                #xmlel{name = &lt;&lt;"message"&gt;&gt;, attrs = Attrs} = Packet},
        |               StateData) -&gt;
<font color=red>     0..|      Lang = xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      Type = xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs),</font>
        |  
<font color=red>     0..|      NewStateData = route_message(#routed_message{</font>
        |          allowed = can_send_to_conference(From, StateData),
        |          type = Type,
        |          from = From,
        |          packet = Packet,
        |          lang = Lang}, StateData),
<font color=red>     0..|      {next_state, normal_state, NewStateData};</font>
        |  normal_state({route, From, &lt;&lt;&gt;&gt;,
        |            #xmlel{name = &lt;&lt;"iq"&gt;&gt;} = Packet},
        |           StateData) -&gt;
<font color=red>     0..|      {RoutingEffect, NewStateData} = route_iq(#routed_iq{</font>
        |          iq = jlib:iq_query_info(Packet),
        |          from = From,
        |          packet = Packet}, StateData),
<font color=red>     0..|      case RoutingEffect of</font>
<font color=red>     0..|          ok -&gt; {next_state, normal_state, NewStateData};</font>
<font color=red>     0..|          stop -&gt; {stop, normal, NewStateData}</font>
        |      end;
        |  normal_state({route, From, Nick,
        |                #xmlel{name = &lt;&lt;"presence"&gt;&gt;} = Packet},
        |               StateData) -&gt;
        |      % FIXME sessions do we need to route presences to all sessions
<font color=red>     0..|      Activity = get_user_activity(From, StateData),</font>
<font color=red>     0..|      Now = now_to_usec(os:timestamp()),</font>
<font color=red>     0..|      MinPresenceInterval =</font>
        |          trunc(gen_mod:get_module_opt(StateData#state.server_host,
        |                                       mod_muc, min_presence_interval, 0)
        |                * 1000000),
<font color=red>     0..|      if</font>
        |      (Now &gt;= Activity#activity.presence_time + MinPresenceInterval) and
        |      (Activity#activity.presence == undefined) -&gt;
<font color=red>     0..|          NewActivity = Activity#activity{presence_time = Now},</font>
<font color=red>     0..|          StateData1 = store_user_activity(From, NewActivity, StateData),</font>
<font color=red>     0..|          process_presence(From, Nick, Packet, StateData1);</font>
        |      true -&gt;
<font color=red>     0..|          if</font>
        |          Activity#activity.presence == undefined -&gt;
<font color=red>     0..|              Interval = (Activity#activity.presence_time +</font>
        |                  MinPresenceInterval - Now) div 1000,
<font color=red>     0..|              erlang:send_after(</font>
        |                Interval, self(), {process_user_presence, From});
        |          true -&gt;
<font color=red>     0..|              ok</font>
        |          end,
<font color=red>     0..|          NewActivity = Activity#activity{presence = {Nick, Packet}},</font>
<font color=red>     0..|          StateData1 = store_user_activity(From, NewActivity, StateData),</font>
<font color=red>     0..|          {next_state, normal_state, StateData1}</font>
        |      end;
        |  normal_state({route, From, ToNick,
        |                #xmlel{name = &lt;&lt;"message"&gt;&gt;, attrs = Attrs} = Packet},
        |               StateData) -&gt;
<font color=red>     0..|      Type = xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      FunRouteNickMessage = fun(JID, StateDataAcc) -&gt;</font>
<font color=red>     0..|          route_nick_message(#routed_nick_message{</font>
        |          allow_pm = (StateDataAcc#state.config)#config.allow_private_messages,
        |          online = is_user_online(From, StateDataAcc),
        |          type = Type,
        |          from = From,
        |          nick = ToNick,
        |          lang = xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs),
        |          decide = decide_fate_message(Type, Packet, From, StateDataAcc),
        |          packet = Packet,
        |          jid = JID}, StateDataAcc)
        |      end,
<font color=red>     0..|      NewStateData = case find_jids_by_nick(ToNick, StateData) of</font>
<font color=red>     0..|          [] -&gt; FunRouteNickMessage(false, StateData);</font>
<font color=red>     0..|          JIDs -&gt; lists:foldl(FunRouteNickMessage, StateData, JIDs)</font>
        |      end,
<font color=red>     0..|      {next_state, normal_state, NewStateData};</font>
        |  normal_state({route, From, ToNick,
        |            #xmlel{name = &lt;&lt;"iq"&gt;&gt;, attrs = Attrs} = Packet},
        |           StateData) -&gt;
<font color=red>     0..|      Lang = xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      StanzaId = xml:get_attr_s(&lt;&lt;"id"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      FunRouteNickIq = fun(JID) -&gt;</font>
<font color=red>     0..|          route_nick_iq(#routed_nick_iq{</font>
        |              allow_query = (StateData#state.config)#config.allow_query_users,
        |              online = is_user_online_iq(StanzaId, From, StateData),
        |              jid = JID,
        |              iq = jlib:iq_query_info(Packet),
        |              packet = Packet,
        |              lang = Lang,
        |              from = From,
        |              stanza = StanzaId,
        |              nick = ToNick}, StateData)
        |      end,
<font color=red>     0..|      case find_jids_by_nick(ToNick, StateData) of</font>
<font color=red>     0..|          [] -&gt; FunRouteNickIq(false);</font>
<font color=red>     0..|          JIDs -&gt; lists:foreach(FunRouteNickIq, JIDs)</font>
        |      end,
<font color=red>     0..|      {next_state, normal_state, StateData};</font>
        |  normal_state(_Event, StateData) -&gt;
<font color=red>     0..|      {next_state, normal_state, StateData}.</font>
        |  
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: handle_event/3
        |  %% Returns: {next_state, NextStateName, NextStateData}          |
        |  %%          {next_state, NextStateName, NextStateData, Timeout} |
        |  %%          {stop, Reason, NewStateData}
        |  %%----------------------------------------------------------------------
        |  handle_event({service_message, Msg}, _StateName, StateData) -&gt;
<font color=red>     0..|      MessagePkt = #xmlel{name = &lt;&lt;"message"&gt;&gt;,</font>
        |                          attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"groupchat"&gt;&gt;}],
        |                          children = [#xmlel{name = &lt;&lt;"body"&gt;&gt;,
        |                                             children = [#xmlcdata{content = Msg}]}]},
<font color=red>     0..|      lists:foreach(</font>
        |        fun({_LJID, Info}) -&gt;
<font color=red>     0..|            ejabberd_router:route(</font>
        |          StateData#state.jid,
        |          Info#user.jid,
        |          MessagePkt)
        |        end,
        |        ?DICT:to_list(StateData#state.users)),
<font color=red>     0..|      NSD = add_message_to_history(&lt;&lt;&gt;&gt;,</font>
        |                   StateData#state.jid,
        |                   MessagePkt,
        |                   StateData),
<font color=red>     0..|      {next_state, normal_state, NSD};</font>
        |  
        |  handle_event({destroy, Reason}, _StateName, StateData) -&gt;
<font color=red>     0..|      {result, [], stop} =</font>
        |          destroy_room(
        |            #xmlel{name = &lt;&lt;"destroy"&gt;&gt;, attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_OWNER}],
        |                   children = case Reason of
<font color=red>     0..|                                  none -&gt; [];</font>
        |                                  _Else -&gt;
<font color=red>     0..|                                      [#xmlel{name = &lt;&lt;"reason"&gt;&gt;,</font>
        |                                              children = [#xmlcdata{content = Reason}]}]
        |                              end}, StateData),
<font color=red>     0..|      ?INFO_MSG("Destroyed MUC room ~s with reason: ~p",</font>
        |            [jid:to_binary(StateData#state.jid), Reason]),
<font color=red>     0..|      add_to_log(room_existence, destroyed, StateData),</font>
<font color=red>     0..|      {stop, shutdown, StateData};</font>
        |  handle_event(destroy, StateName, StateData) -&gt;
<font color=red>     0..|      ?INFO_MSG("Destroyed MUC room ~s",</font>
        |            [jid:to_binary(StateData#state.jid)]),
<font color=red>     0..|      handle_event({destroy, none}, StateName, StateData);</font>
        |  
        |  handle_event({set_affiliations, Affiliations}, StateName, StateData) -&gt;
<font color=red>     0..|      {next_state, StateName, StateData#state{affiliations = Affiliations}};</font>
        |  
        |  handle_event(_Event, StateName, StateData) -&gt;
<font color=red>     0..|      {next_state, StateName, StateData}.</font>
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: handle_sync_event/4
        |  %% Returns: {next_state, NextStateName, NextStateData}            |
        |  %%          {next_state, NextStateName, NextStateData, Timeout}   |
        |  %%          {reply, Reply, NextStateName, NextStateData}          |
        |  %%          {reply, Reply, NextStateName, NextStateData, Timeout} |
        |  %%          {stop, Reason, NewStateData}                          |
        |  %%          {stop, Reason, Reply, NewStateData}
        |  %%----------------------------------------------------------------------
        |  handle_sync_event({get_disco_item, JID, Lang}, _From, StateName, StateData) -&gt;
<font color=red>     0..|      Reply = get_roomdesc_reply(JID, StateData,</font>
        |                     get_roomdesc_tail(StateData, Lang)),
<font color=red>     0..|      {reply, Reply, StateName, StateData};</font>
        |  handle_sync_event(get_config, _From, StateName, StateData) -&gt;
<font color=red>     0..|      {reply, {ok, StateData#state.config}, StateName, StateData};</font>
        |  handle_sync_event(get_state, _From, StateName, StateData) -&gt;
<font color=red>     0..|      {reply, {ok, StateData}, StateName, StateData};</font>
        |  handle_sync_event(get_room_users, _From, StateName, StateData) -&gt;
<font color=red>     0..|      {reply, {ok, dict_to_values(StateData#state.users)}, StateName, StateData};</font>
        |  handle_sync_event({is_room_owner, UserJID}, _From, StateName, StateData) -&gt;
<font color=red>     0..|      {reply, {ok, get_affiliation(UserJID, StateData) =:= owner}, StateName, StateData};</font>
        |  handle_sync_event({change_config, Config}, _From, StateName, StateData) -&gt;
<font color=red>     0..|      {result, [], NSD} = change_config(Config, StateData),</font>
<font color=red>     0..|      {reply, {ok, NSD#state.config}, StateName, NSD};</font>
        |  handle_sync_event({change_state, NewStateData}, _From, StateName, _StateData) -&gt;
<font color=red>     0..|      {reply, {ok, NewStateData}, StateName, NewStateData};</font>
        |  handle_sync_event(_Event, _From, StateName, StateData) -&gt;
<font color=red>     0..|      Reply = ok,</font>
<font color=red>     0..|      {reply, Reply, StateName, StateData}.</font>
        |  
        |  code_change(_OldVsn, StateName, StateData, _Extra) -&gt;
<font color=red>     0..|      {ok, StateName, StateData}.</font>
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: handle_info/3
        |  %% Returns: {next_state, NextStateName, NextStateData}          |
        |  %%          {next_state, NextStateName, NextStateData, Timeout} |
        |  %%          {stop, Reason, NewStateData}
        |  %%----------------------------------------------------------------------
        |  -type info_msg() :: {process_user_presence | process_user_message, ejabberd:jid()}
        |                      | process_room_queue.
        |  -spec handle_info(info_msg(), statename(), state()) -&gt; fsm_return().
        |  handle_info({process_user_presence, From}, normal_state = _StateName, StateData) -&gt;
<font color=red>     0..|      RoomQueueEmpty = queue:is_empty(StateData#state.room_queue),</font>
<font color=red>     0..|      RoomQueue = queue:in({presence, From}, StateData#state.room_queue),</font>
<font color=red>     0..|      StateData1 = StateData#state{room_queue = RoomQueue},</font>
<font color=red>     0..|      if</font>
        |      RoomQueueEmpty -&gt;
<font color=red>     0..|          StateData2 = prepare_room_queue(StateData1),</font>
<font color=red>     0..|          {next_state, normal_state, StateData2};</font>
        |      true -&gt;
<font color=red>     0..|          {next_state, normal_state, StateData1}</font>
        |      end;
        |  handle_info({process_user_message, From}, normal_state = _StateName, StateData) -&gt;
<font color=red>     0..|      RoomQueueEmpty = queue:is_empty(StateData#state.room_queue),</font>
<font color=red>     0..|      RoomQueue = queue:in({message, From}, StateData#state.room_queue),</font>
<font color=red>     0..|      StateData1 = StateData#state{room_queue = RoomQueue},</font>
<font color=red>     0..|      if</font>
        |      RoomQueueEmpty -&gt;
<font color=red>     0..|          StateData2 = prepare_room_queue(StateData1),</font>
<font color=red>     0..|          {next_state, normal_state, StateData2};</font>
        |      true -&gt;
<font color=red>     0..|          {next_state, normal_state, StateData1}</font>
        |      end;
        |  handle_info(process_room_queue, normal_state = StateName, StateData) -&gt;
<font color=red>     0..|      case queue:out(StateData#state.room_queue) of</font>
        |      {{value, {message, From}}, RoomQueue} -&gt;
<font color=red>     0..|          Activity = get_user_activity(From, StateData),</font>
<font color=red>     0..|          Packet = Activity#activity.message,</font>
<font color=red>     0..|          NewActivity = Activity#activity{message = undefined},</font>
<font color=red>     0..|          StateData1 =</font>
        |          store_user_activity(
        |            From, NewActivity, StateData),
<font color=red>     0..|          StateData2 =</font>
        |          StateData1#state{
        |            room_queue = RoomQueue},
<font color=red>     0..|          StateData3 = prepare_room_queue(StateData2),</font>
<font color=red>     0..|          process_groupchat_message(From, Packet, StateData3);</font>
        |      {{value, {presence, From}}, RoomQueue} -&gt;
<font color=red>     0..|          Activity = get_user_activity(From, StateData),</font>
<font color=red>     0..|          {Nick, Packet} = Activity#activity.presence,</font>
<font color=red>     0..|          NewActivity = Activity#activity{presence = undefined},</font>
<font color=red>     0..|          StateData1 =</font>
        |          store_user_activity(
        |            From, NewActivity, StateData),
<font color=red>     0..|          StateData2 =</font>
        |          StateData1#state{
        |            room_queue = RoomQueue},
<font color=red>     0..|          StateData3 = prepare_room_queue(StateData2),</font>
<font color=red>     0..|          process_presence(From, Nick, Packet, StateData3);</font>
        |      {empty, _} -&gt;
<font color=red>     0..|          {next_state, StateName, StateData}</font>
        |      end;
        |  handle_info(_Info, StateName, StateData) -&gt;
<font color=red>     0..|      {next_state, StateName, StateData}.</font>
        |  
        |  
        |  %% @doc Purpose: Shutdown the fsm
        |  -spec terminate(any(), statename(), state()) -&gt; 'ok'.
        |  terminate(Reason, _StateName, StateData) -&gt;
<font color=red>     0..|      ?INFO_MSG("Stopping MUC room ~s@~s",</font>
        |            [StateData#state.room, StateData#state.host]),
<font color=red>     0..|      ReasonT = case Reason of</font>
<font color=red>     0..|            shutdown -&gt; &lt;&lt;"You are being removed from the room because of a system shutdown"&gt;&gt;;</font>
<font color=red>     0..|            _ -&gt; &lt;&lt;"Room terminates"&gt;&gt;</font>
        |            end,
<font color=red>     0..|      ItemAttrs = [{&lt;&lt;"affiliation"&gt;&gt;, &lt;&lt;"none"&gt;&gt;}, {&lt;&lt;"role"&gt;&gt;, &lt;&lt;"none"&gt;&gt;}],</font>
<font color=red>     0..|      ReasonEl = #xmlel{name = &lt;&lt;"reason"&gt;&gt;,</font>
        |                        children = [#xmlcdata{content = ReasonT}]},
<font color=red>     0..|      Packet = #xmlel{name = &lt;&lt;"presence"&gt;&gt;,</font>
        |                      attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"unavailable"&gt;&gt;}],
        |                      children = [#xmlel{name = &lt;&lt;"x"&gt;&gt;,
        |                                         attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_USER}],
        |                                         children = [#xmlel{name = &lt;&lt;"item"&gt;&gt;,
        |                                                            attrs = ItemAttrs,
        |                                                            children = [ReasonEl]},
        |                                                     #xmlel{name = &lt;&lt;"status"&gt;&gt;,
        |                                                            attrs = [{&lt;&lt;"code"&gt;&gt;, &lt;&lt;"332"&gt;&gt;}]}
        |                                                    ]}]},
<font color=red>     0..|      ?DICT:fold(</font>
        |         fun(LJID, Info, _) -&gt;
<font color=red>     0..|             Nick = Info#user.nick,</font>
<font color=red>     0..|             case Reason of</font>
        |             shutdown -&gt;
<font color=red>     0..|                 ejabberd_router:route(</font>
        |               jid:replace_resource(StateData#state.jid, Nick),
        |               Info#user.jid,
        |               Packet);
<font color=red>     0..|             _ -&gt; ok</font>
        |             end,
<font color=red>     0..|             tab_remove_online_user(LJID, StateData)</font>
        |         end, [], StateData#state.users),
<font color=red>     0..|      add_to_log(room_existence, stopped, StateData),</font>
<font color=red>     0..|      mod_muc:room_destroyed(StateData#state.host, StateData#state.room, self(),</font>
        |                 StateData#state.server_host),
<font color=red>     0..|      ok.</font>
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% Internal functions
        |  %%%----------------------------------------------------------------------
        |  
        |  -spec occupant_jid(user(), 'undefined' | ejabberd:jid()) -&gt; 'error' | ejabberd:jid().
        |  occupant_jid(#user{nick=Nick}, RoomJID) -&gt;
<font color=red>     0..|      jid:replace_resource(RoomJID, Nick).</font>
        |  
        |  
        |  -spec route(atom() | pid() | port() | {atom(),_} | {'via',_,_},
        |      From :: ejabberd:jid(), To :: mod_muc:nick(), Pkt :: jlib:xmlel()) -&gt; 'ok'.
        |  route(Pid, From, ToNick, Packet) -&gt;
<font color=red>     0..|      gen_fsm:send_event(Pid, {route, From, ToNick, Packet}).</font>
        |  
        |  
        |  -spec process_groupchat_message(ejabberd:simple_jid() | ejabberd:jid(),
        |                                  jlib:xmlel(), state()) -&gt; fsm_return().
        |  process_groupchat_message(From, #xmlel{name = &lt;&lt;"message"&gt;&gt;,
        |                                         attrs = Attrs} = Packet,
        |                            StateData) -&gt;
<font color=red>     0..|      Lang = xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      case can_send_to_conference(From, StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              process_message_from_allowed_user(From, Packet, StateData);</font>
        |          false -&gt;
<font color=red>     0..|              send_error_only_occupants(&lt;&lt;"messages"&gt;&gt;, Packet, Lang,</font>
        |                                        StateData#state.jid, From),
<font color=red>     0..|              {next_state, normal_state, StateData}</font>
        |      end.
        |  
        |  can_send_to_conference(From, StateData) -&gt;
<font color=red>     0..|      is_user_online(From, StateData)</font>
        |      orelse
<font color=red>     0..|      is_allowed_nonparticipant(From, StateData).</font>
        |  
        |  process_message_from_allowed_user(From, #xmlel{attrs = Attrs} = Packet,
        |                                    StateData) -&gt;
<font color=red>     0..|      Lang = xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      {FromNick, Role} = get_participant_data(From, StateData),</font>
<font color=red>     0..|      CanSendBroadcasts = can_send_broadcasts(Role, StateData),</font>
<font color=red>     0..|      if</font>
        |          CanSendBroadcasts -&gt;
<font color=red>     0..|              {NewState, Changed} = change_subject_if_allowed(FromNick, Role,</font>
        |                                                              Packet, StateData),
<font color=red>     0..|              if</font>
        |                  Changed -&gt;
<font color=red>     0..|                      broadcast_changed_subject(From, FromNick, Packet, NewState);</font>
        |                  not Changed -&gt;
<font color=red>     0..|                      change_subject_error(From, FromNick, Packet, Lang, NewState),</font>
<font color=red>     0..|                      {next_state, normal_state, NewState}</font>
        |              end;
        |          not CanSendBroadcasts -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"Visitors are not allowed to send messages to all occupants"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERRT_FORBIDDEN(Lang, ErrText)),</font>
<font color=red>     0..|              ejabberd_router:route(StateData#state.jid, From, Err),</font>
<font color=red>     0..|              {next_state, normal_state, StateData}</font>
        |      end.
        |  
        |  can_send_broadcasts(Role, StateData) -&gt;
        |      (Role == moderator)
        |      or (Role == participant)
<font color=red>     0..|      or ((StateData#state.config)#config.moderated == false).</font>
        |  
        |  broadcast_changed_subject(From, FromNick, Packet, StateData) -&gt;
<font color=red>     0..|      case ejabberd_hooks:run_fold(filter_room_packet,</font>
        |                                   StateData#state.host, Packet,
        |                                   [FromNick, From, StateData#state.jid])
        |      of
        |          drop -&gt;
<font color=red>     0..|              {next_state, normal_state, StateData};</font>
        |          FilteredPacket -&gt;
<font color=red>     0..|              RouteFrom = jid:replace_resource(StateData#state.jid,</font>
        |                                               FromNick),
<font color=red>     0..|              lists:foreach(fun({_LJID, Info}) -&gt;</font>
<font color=red>     0..|                                    ejabberd_router:route(RouteFrom,</font>
        |                                                          Info#user.jid,
        |                                                          FilteredPacket)
        |                            end, ?DICT:to_list(StateData#state.users)),
<font color=red>     0..|              NewStateData2 = add_message_to_history(FromNick,</font>
        |                                                     From,
        |                                                     FilteredPacket,
        |                                                     StateData),
<font color=red>     0..|              {next_state, normal_state, NewStateData2}</font>
        |      end.
        |  
        |  change_subject_error(From, FromNick, Packet, Lang, StateData) -&gt;
<font color=red>     0..|      Err = case (StateData#state.config)#config.allow_change_subj of</font>
        |                true -&gt;
<font color=red>     0..|                    ?ERRT_FORBIDDEN(Lang,</font>
        |                                    &lt;&lt;"Only moderators and participants are allowed to change the subject in this room"&gt;&gt;);
        |                _ -&gt;
<font color=red>     0..|                    ?ERRT_FORBIDDEN(Lang,</font>
        |                                    &lt;&lt;"Only moderators are allowed to change the subject in this room"&gt;&gt;)
        |            end,
<font color=red>     0..|      ejabberd_router:route(jid:replace_resource(StateData#state.jid,</font>
        |                                                 FromNick),
        |                            From,
        |                            jlib:make_error_reply(Packet, Err)).
        |  
        |  change_subject_if_allowed(FromNick, Role, Packet, StateData) -&gt;
<font color=red>     0..|      case check_subject(Packet) of</font>
        |          false -&gt;
<font color=red>     0..|              {StateData, true};</font>
        |          Subject -&gt;
<font color=red>     0..|              case can_change_subject(Role, StateData) of</font>
        |                  true -&gt;
<font color=red>     0..|                      NSD = StateData#state{subject = Subject,</font>
        |                                            subject_author = FromNick},
<font color=red>     0..|                      save_persistent_room_state(NSD),</font>
<font color=red>     0..|                      {NSD, true};</font>
        |                  _ -&gt;
<font color=red>     0..|                      {StateData, false}</font>
        |              end
        |      end.
        |  
        |  save_persistent_room_state(StateData) -&gt;
<font color=red>     0..|      case (StateData#state.config)#config.persistent of</font>
        |          true -&gt;
<font color=red>     0..|              mod_muc:store_room(StateData#state.host,</font>
        |                                 StateData#state.room,
        |                                 make_opts(StateData));
        |          _ -&gt;
<font color=red>     0..|              ok</font>
        |      end.
        |  
        |  %% @doc Check if this non participant can send message to room.
        |  %%
        |  %% XEP-0045 v1.23:
        |  %% 7.9 Sending a Message to All Occupants
        |  %% an implementation MAY allow users with certain privileges
        |  %% (e.g., a room owner, room admin, or service-level admin)
        |  %% to send messages to the room even if those users are not occupants.
        |  -spec is_allowed_nonparticipant(ejabberd:jid(), state()) -&gt; boolean().
        |  is_allowed_nonparticipant(JID, StateData) -&gt;
<font color=red>     0..|      get_service_affiliation(JID, StateData) =:= owner.</font>
        |  
        |  
        |  %% @doc Get information of this participant, or default values.
        |  %% If the JID is not a participant, return values for a service message.
        |  -spec get_participant_data(ejabberd:simple_jid() | ejabberd:jid(),
        |                             state()) -&gt; {_,_}.
        |  get_participant_data(From, StateData) -&gt;
<font color=red>     0..|      case ?DICT:find(jid:to_lower(From), StateData#state.users) of</font>
        |          {ok, #user{nick = FromNick, role = Role}} -&gt;
<font color=red>     0..|              {FromNick, Role};</font>
        |          error -&gt;
<font color=red>     0..|              {&lt;&lt;&gt;&gt;, moderator}</font>
        |      end.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Presence processing
        |  
        |  %% @doc Process presence stanza and destroy the room, if it is empty.
        |  -spec process_presence(From :: ejabberd:jid(), Nick :: mod_muc:nick(),
        |                         Packet :: jlib:xmlel(), state()) -&gt; fsm_return().
        |  process_presence(From, ToNick, Presence, StateData) -&gt;
<font color=red>     0..|      StateData1 = process_presence1(From, ToNick, Presence, StateData),</font>
<font color=red>     0..|      destroy_temporary_room_if_empty(StateData1).</font>
        |  
        |  
        |  -spec process_presence(From :: ejabberd:jid(), Nick :: mod_muc:nick(),
        |          Presence :: jlib:xmlel(), state(), statename()) -&gt; fsm_return().
        |  process_presence(From, ToNick, Presence, StateData, NextState) -&gt;
<font color=red>     0..|      StateData1 = process_presence(From, ToNick, Presence, StateData),</font>
<font color=red>     0..|      rewrite_next_state(NextState, StateData1).</font>
        |  
        |  
        |  -spec rewrite_next_state(statename(), fsm_return()) -&gt; fsm_return().
        |  rewrite_next_state(NewState, {next_state, _, StateData}) -&gt;
<font color=red>     0..|      {next_state, NewState, StateData};</font>
        |  rewrite_next_state(_, {stop, normal, StateData}) -&gt;
<font color=red>     0..|      {stop, normal, StateData}.</font>
        |  
        |  
        |  -spec destroy_temporary_room_if_empty(state()) -&gt; fsm_return().
        |  destroy_temporary_room_if_empty(StateData=#state{config=C=#config{}}) -&gt;
<font color=red>     0..|      case (not C#config.persistent) andalso is_empty_room(StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              ?INFO_MSG("Destroyed MUC room ~s because it's temporary and empty",</font>
        |                    [jid:to_binary(StateData#state.jid)]),
<font color=red>     0..|              add_to_log(room_existence, destroyed, StateData),</font>
<font color=red>     0..|              {stop, normal, StateData};</font>
        |          _ -&gt;
<font color=red>     0..|              {next_state, normal_state, StateData}</font>
        |      end.
        |  
        |  
        |  -spec process_presence1(From, Nick, Packet, state()) -&gt; state() when
        |        From :: ejabberd:jid(),
        |        Nick :: mod_muc:nick(),
        |        Packet :: jlib:xmlel().
        |  process_presence1(From, Nick, #xmlel{name = &lt;&lt;"presence"&gt;&gt;,
        |                                       attrs = Attrs} = Packet,
        |                    StateData=#state{}) -&gt;
<font color=red>     0..|      Type = xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      Lang = xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      case Type of</font>
        |          &lt;&lt;"unavailable"&gt;&gt; -&gt;
<font color=red>     0..|              process_presence_unavailable(From, Packet, StateData);</font>
        |          &lt;&lt;"error"&gt;&gt; -&gt;
<font color=red>     0..|              process_presence_error(From, Packet, Lang, StateData);</font>
        |          &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|              case is_user_online(From, StateData) of</font>
        |                  true -&gt;
<font color=red>     0..|                      case is_nick_change(From, Nick, StateData) of</font>
        |                          true -&gt;
<font color=red>     0..|                              process_presence_nick_change(From, Nick, Packet,</font>
        |                                                           Lang, StateData);
        |                          _NotNickChange -&gt;
<font color=red>     0..|                              process_simple_presence(From, Packet, StateData)</font>
        |                      end;
        |                  false -&gt;
        |                      %% at this point we know that the presence has no type
        |                      %% (user wants to enter the room)
        |                      %% and that the user is not alredy online
<font color=red>     0..|                      handle_new_user(From, Nick, Packet, StateData, Attrs)</font>
        |              end;
        |          _NotOnline -&gt;
<font color=red>     0..|              StateData</font>
        |      end.
        |  
        |  
        |  -spec process_simple_presence(ejabberd:jid(), jlib:xmlel(), state()) -&gt; state().
        |  process_simple_presence(From, Packet, StateData) -&gt;
<font color=red>     0..|      NewPacket = check_and_strip_visitor_status(From, Packet, StateData),</font>
<font color=red>     0..|      NewState = add_user_presence(From, NewPacket, StateData),</font>
<font color=red>     0..|      send_new_presence(From, NewState),</font>
<font color=red>     0..|      NewState.</font>
        |  
        |  
        |  -spec process_presence_error(ejabberd:simple_jid() | ejabberd:jid(),
        |                               jlib:xmlel(), ejabberd:lang(), state()) -&gt; state().
        |  process_presence_error(From, Packet, Lang, StateData) -&gt;
<font color=red>     0..|      case is_user_online(From, StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              ErrorText = &lt;&lt;"This participant is kicked from the room because he sent an error presence"&gt;&gt;,</font>
<font color=red>     0..|              expulse_participant(Packet, From, StateData, translate:translate(Lang, ErrorText)),</font>
<font color=red>     0..|              StateData;</font>
        |          _ -&gt;
<font color=red>     0..|              StateData</font>
        |      end.
        |  
        |  
        |  -spec process_presence_unavailable(ejabberd:jid(), jlib:xmlel(), state())
        |                                      -&gt; state().
        |  process_presence_unavailable(From, Packet, StateData) -&gt;
<font color=red>     0..|      case is_user_online(From, StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              NewPacket = check_and_strip_visitor_status(From, Packet, StateData),</font>
<font color=red>     0..|              NewState = add_user_presence_un(From, NewPacket, StateData),</font>
<font color=red>     0..|              send_new_presence_un(From, NewState),</font>
<font color=red>     0..|              Reason = case xml:get_subtag(NewPacket, &lt;&lt;"status"&gt;&gt;) of</font>
<font color=red>     0..|                  false -&gt; &lt;&lt;&gt;&gt;;</font>
<font color=red>     0..|                  Status_el -&gt; xml:get_tag_cdata(Status_el)</font>
        |              end,
<font color=red>     0..|              remove_online_user(From, NewState, Reason);</font>
        |          _ -&gt;
<font color=red>     0..|              StateData</font>
        |      end.
        |  
        |  
        |  -spec choose_nick_change_strategy(ejabberd:jid(), binary(), state())
        |      -&gt; 'allowed' | 'conflict_registered' | 'conflict_use' | 'not_allowed_visitor'.
        |  choose_nick_change_strategy(From, Nick, StateData) -&gt;
<font color=red>     0..|      case {is_nick_exists(Nick, StateData),</font>
        |            mod_muc:can_use_nick(StateData#state.host, From, Nick),
        |            (StateData#state.config)#config.allow_visitor_nickchange,
        |            is_visitor(From, StateData)} of
        |          {_, _, false, true} -&gt;
<font color=red>     0..|              not_allowed_visitor;</font>
        |          {true, _, _, _} -&gt;
<font color=red>     0..|              conflict_use;</font>
        |          {_, false, _, _} -&gt;
<font color=red>     0..|              conflict_registered;</font>
        |          _ -&gt;
<font color=red>     0..|              allowed</font>
        |      end.
        |  
        |  
        |  -spec process_presence_nick_change(ejabberd:jid(), mod_muc:nick(), jlib:xmlel(),
        |          ejabberd:lang(), state()) -&gt; state().
        |  process_presence_nick_change(From, Nick, Packet, Lang, StateData) -&gt;
<font color=red>     0..|      case choose_nick_change_strategy(From, Nick, StateData) of</font>
        |          not_allowed_visitor -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"Visitors are not allowed to change their nicknames in this room"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERRT_NOT_ALLOWED(Lang, ErrText)),</font>
<font color=red>     0..|              route_error(Nick, From, Err, StateData);</font>
        |          conflict_use -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"That nickname is already in use by another occupant"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERRT_CONFLICT(Lang, ErrText)),</font>
<font color=red>     0..|              route_error(Nick, From, Err, StateData);</font>
        |          conflict_registered -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"That nickname is registered by another person"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERRT_CONFLICT(Lang, ErrText)),</font>
<font color=red>     0..|              route_error(Nick, From, Err, StateData);</font>
        |          allowed -&gt;
<font color=red>     0..|              change_nick(From, Nick, StateData)</font>
        |      end.
        |  
        |  
        |  -spec check_and_strip_visitor_status(ejabberd:jid(), jlib:xmlel(), state())
        |                                          -&gt; jlib:xmlel().
        |  check_and_strip_visitor_status(From, Packet, StateData) -&gt;
<font color=red>     0..|      case {(StateData#state.config)#config.allow_visitor_status,</font>
        |            is_visitor(From, StateData)} of
        |          {false, true} -&gt;
<font color=red>     0..|              strip_status(Packet);</font>
        |          _ -&gt;
<font color=red>     0..|              Packet</font>
        |      end.
        |  
        |  
        |  -spec handle_new_user(ejabberd:jid(), mod_muc:nick(), jlib:xmlel(), state(),
        |                        [{binary(),binary()}]) -&gt; state().
        |  handle_new_user(From, Nick = &lt;&lt;&gt;&gt;, _Packet, StateData, Attrs) -&gt;
<font color=red>     0..|      Lang = xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      ErrText = &lt;&lt;"No nickname"&gt;&gt;,</font>
<font color=red>     0..|      Error =jlib:make_error_reply(</font>
        |                  #xmlel{name = &lt;&lt;"presence"&gt;&gt;},
        |                  ?ERRT_JID_MALFORMED(Lang, ErrText)),
        |      %ejabberd_route(From, To, Packet),
<font color=red>     0..|      ejabberd_router:route(jid:replace_resource(StateData#state.jid, Nick), From, Error),</font>
<font color=red>     0..|      StateData;</font>
        |  handle_new_user(From, Nick, Packet, StateData, _Attrs) -&gt;
<font color=red>     0..|      add_new_user(From, Nick, Packet, StateData).</font>
        |  
        |  
        |  -spec is_user_online(ejabberd:simple_jid() | ejabberd:jid(), state()) -&gt; boolean().
        |  is_user_online(JID, StateData) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      ?DICT:is_key(LJID, StateData#state.users).</font>
        |  
        |  
        |  %% @doc Check if the user is occupant of the room, or at least is an admin
        |  %% or owner.
        |  -spec is_occupant_or_admin(ejabberd:jid(), state()) -&gt; boolean().
        |  is_occupant_or_admin(JID, StateData) -&gt;
<font color=red>     0..|      FAffiliation = get_affiliation(JID, StateData),</font>
<font color=red>     0..|      FRole = get_role(JID, StateData),</font>
<font color=red>     0..|      (FRole /= none) orelse</font>
<font color=red>     0..|      (FAffiliation == admin) orelse</font>
<font color=red>     0..|      (FAffiliation == owner).</font>
        |  
        |  %%%
        |  %%% Handle IQ queries of vCard
        |  %%%
        |  
        |  -spec is_user_online_iq(_, ejabberd:jid(), state())
        |              -&gt; {'false',_,ejabberd:jid()} | {'true',_,ejabberd:jid()}.
        |  is_user_online_iq(StanzaId, JID, StateData) when JID#jid.lresource /= &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|      {is_user_online(JID, StateData), StanzaId, JID};</font>
        |  is_user_online_iq(StanzaId, JID, StateData) when JID#jid.lresource == &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|      try stanzaid_unpack(StanzaId) of</font>
        |          {OriginalId, Resource} -&gt;
<font color=red>     0..|              JIDWithResource = jid:replace_resource(JID, Resource),</font>
<font color=red>     0..|              {is_user_online(JIDWithResource, StateData),</font>
        |               OriginalId, JIDWithResource}
        |      catch
        |          _:_ -&gt;
<font color=red>     0..|              {is_user_online(JID, StateData), StanzaId, JID}</font>
        |      end.
        |  
        |  
        |  -spec handle_iq_vcard(ejabberd:jid(), ejabberd:simple_jid() | ejabberd:jid(),
        |                        binary(), any(), jlib:xmlel()) -&gt;
        |                  {ejabberd:simple_jid() | ejabberd:jid(), jlib:xmlel()}.
        |  handle_iq_vcard(FromFull, ToJID, StanzaId, NewId, Packet) -&gt;
<font color=red>     0..|      ToBareJID = jid:to_bare(ToJID),</font>
<font color=red>     0..|      IQ = jlib:iq_query_info(Packet),</font>
<font color=red>     0..|      handle_iq_vcard2(FromFull, ToJID, ToBareJID, StanzaId, NewId, IQ, Packet).</font>
        |  
        |  
        |  -spec handle_iq_vcard2(FromFull :: ejabberd:jid(),
        |          ToJID :: ejabberd:simple_jid() | ejabberd:jid(),
        |          ToBareJID :: ejabberd:simple_jid() | ejabberd:jid(),
        |          binary(), _NewID, 'invalid' | 'not_iq' | 'reply' | ejabberd:iq(),
        |          jlib:xmlel()) -&gt; {ejabberd:simple_jid() | ejabberd:jid(), jlib:xmlel()}.
        |  handle_iq_vcard2(_FromFull, ToJID, ToBareJID, StanzaId, _NewId,
        |           #iq{type = get, xmlns = ?NS_VCARD}, Packet)
        |    when ToBareJID /= ToJID -&gt;
<font color=red>     0..|      {ToBareJID, change_stanzaid(StanzaId, ToJID, Packet)};</font>
        |  handle_iq_vcard2(_FromFull, ToJID, _ToBareJID, _StanzaId, NewId, _IQ, Packet) -&gt;
<font color=red>     0..|      {ToJID, change_stanzaid(NewId, Packet)}.</font>
        |  
        |  
        |  -spec stanzaid_pack(binary(), ejabberd:resource()) -&gt; binary().
        |  stanzaid_pack(OriginalId, Resource) -&gt;
<font color=red>     0..|      Data64 = base64:encode(&lt;&lt;"ejab\0", OriginalId/binary, 0, Resource/binary&gt;&gt;),</font>
<font color=red>     0..|      &lt;&lt;"berd", Data64/binary&gt;&gt;.</font>
        |  
        |  
        |  -spec stanzaid_unpack(binary()) -&gt; stanzaid().
        |  stanzaid_unpack(&lt;&lt;"berd", StanzaIdBase64/binary&gt;&gt;) -&gt;
<font color=red>     0..|      StanzaId = base64:decode(StanzaIdBase64),</font>
<font color=red>     0..|      [&lt;&lt;"ejab"&gt;&gt;, OriginalId, Resource] = binary:split(StanzaId, &lt;&lt;"\0"&gt;&gt;),</font>
<font color=red>     0..|      {OriginalId, Resource}.</font>
        |  
        |  
        |  -spec change_stanzaid(binary(), jlib:xmlel()) -&gt; jlib:xmlel().
        |  change_stanzaid(NewId, Packet) -&gt;
<font color=red>     0..|      XE = #xmlel{attrs = Attrs} = jlib:remove_attr(&lt;&lt;"id"&gt;&gt;, Packet),</font>
<font color=red>     0..|      XE#xmlel{attrs = [{&lt;&lt;"id"&gt;&gt;, NewId} | Attrs]}.</font>
        |  change_stanzaid(PreviousId, ToJID, Packet) -&gt;
<font color=red>     0..|      NewId = stanzaid_pack(PreviousId, ToJID#jid.lresource),</font>
<font color=red>     0..|      change_stanzaid(NewId, Packet).</font>
        |  
        |  %%%
        |  %%%
        |  
        |  -spec role_to_binary(mod_muc:role()) -&gt; binary().
        |  role_to_binary(Role) -&gt;
<font color=red>     0..|      case Role of</font>
<font color=red>     0..|          moderator   -&gt; &lt;&lt;"moderator"&gt;&gt;;</font>
<font color=red>     0..|          participant -&gt; &lt;&lt;"participant"&gt;&gt;;</font>
<font color=red>     0..|          visitor     -&gt; &lt;&lt;"visitor"&gt;&gt;;</font>
<font color=red>     0..|          none        -&gt; &lt;&lt;"none"&gt;&gt;</font>
        |      end.
        |  
        |  -spec affiliation_to_binary(mod_muc:affiliation()) -&gt; binary().
        |  affiliation_to_binary(Affiliation) -&gt;
<font color=red>     0..|      case Affiliation of</font>
<font color=red>     0..|          owner   -&gt; &lt;&lt;"owner"&gt;&gt;;</font>
<font color=red>     0..|          admin   -&gt; &lt;&lt;"admin"&gt;&gt;;</font>
<font color=red>     0..|          member  -&gt; &lt;&lt;"member"&gt;&gt;;</font>
<font color=red>     0..|          outcast -&gt; &lt;&lt;"outcast"&gt;&gt;;</font>
<font color=red>     0..|          none    -&gt; &lt;&lt;"none"&gt;&gt;</font>
        |      end.
        |  
        |  -spec binary_to_role(binary()) -&gt; mod_muc:role().
        |  binary_to_role(Role) -&gt;
<font color=red>     0..|      case Role of</font>
<font color=red>     0..|          &lt;&lt;"moderator"&gt;&gt;     -&gt; moderator;</font>
<font color=red>     0..|          &lt;&lt;"participant"&gt;&gt;   -&gt; participant;</font>
<font color=red>     0..|          &lt;&lt;"visitor"&gt;&gt;       -&gt; visitor;</font>
<font color=red>     0..|          &lt;&lt;"none"&gt;&gt;          -&gt; none</font>
        |      end.
        |  
        |  -spec binary_to_affiliation(binary()) -&gt; mod_muc:affiliation().
        |  binary_to_affiliation(Affiliation) -&gt;
<font color=red>     0..|      case Affiliation of</font>
<font color=red>     0..|          &lt;&lt;"owner"&gt;&gt;     -&gt; owner;</font>
<font color=red>     0..|          &lt;&lt;"admin"&gt;&gt;     -&gt; admin;</font>
<font color=red>     0..|          &lt;&lt;"member"&gt;&gt;    -&gt; member;</font>
<font color=red>     0..|          &lt;&lt;"outcast"&gt;&gt;   -&gt; outcast;</font>
<font color=red>     0..|          &lt;&lt;"none"&gt;&gt;      -&gt; none</font>
        |      end.
        |  
        |  
        |  %% @doc Decide the fate of the message and its sender
        |  %% Returns: continue_delivery | forget_message | {expulse_sender, Reason}
        |  -spec decide_fate_message(binary(), jlib:xmlel(), ejabberd:simple_jid() | ejabberd:jid(),
        |          state()) -&gt; 'continue_delivery'
        |                    | 'forget_message'
        |                    | {'expulse_sender', string()}.
        |  decide_fate_message(&lt;&lt;"error"&gt;&gt;, Packet, From, StateData) -&gt;
        |      %% Make a preliminary decision
<font color=red>     0..|      PD = case check_error_kick(Packet) of</font>
        |           %% If this is an error stanza and its condition matches a criteria
        |           true -&gt;
<font color=red>     0..|           Reason = "This participant is considered a ghost and is expulsed: " ++</font>
        |              binary_to_list(jid:to_binary(From)),
<font color=red>     0..|           {expulse_sender, Reason};</font>
        |           false -&gt;
<font color=red>     0..|           continue_delivery</font>
        |       end,
<font color=red>     0..|      case PD of</font>
        |      {expulse_sender, R} -&gt;
<font color=red>     0..|          case is_user_online(From, StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              {expulse_sender, R};</font>
        |          false -&gt;
<font color=red>     0..|              forget_message</font>
        |          end;
        |      Other -&gt;
<font color=red>     0..|          Other</font>
        |      end;
        |  decide_fate_message(_, _, _, _) -&gt;
<font color=red>     0..|      continue_delivery.</font>
        |  
        |  
        |  %% @doc Check if the elements of this error stanza indicate
        |  %% that the sender is a dead participant.
        |  %% If so, return true to kick the participant.
        |  -spec check_error_kick(jlib:xmlel()) -&gt; boolean().
        |  check_error_kick(Packet) -&gt;
<font color=red>     0..|      case get_error_condition(Packet) of</font>
<font color=red>     0..|          &lt;&lt;"gone"&gt;&gt;                      -&gt; true;</font>
<font color=red>     0..|          &lt;&lt;"internal-server-error"&gt;&gt;     -&gt; true;</font>
<font color=red>     0..|          &lt;&lt;"item-not-found"&gt;&gt;            -&gt; true;</font>
<font color=red>     0..|          &lt;&lt;"jid-malformed"&gt;&gt;             -&gt; true;</font>
<font color=red>     0..|          &lt;&lt;"recipient-unavailable"&gt;&gt;     -&gt; true;</font>
<font color=red>     0..|          &lt;&lt;"redirect"&gt;&gt;                  -&gt; true;</font>
<font color=red>     0..|          &lt;&lt;"remote-server-not-found"&gt;&gt;   -&gt; true;</font>
<font color=red>     0..|          &lt;&lt;"remote-server-timeout"&gt;&gt;     -&gt; true;</font>
<font color=red>     0..|          &lt;&lt;"service-unavailable"&gt;&gt;       -&gt; true;</font>
<font color=red>     0..|          _                               -&gt; false</font>
        |      end.
        |  
        |  
        |  -spec get_error_condition(jlib:xmlel()) -&gt; binary().
        |  get_error_condition(Packet) -&gt;
<font color=red>     0..|      case catch get_error_condition2(Packet) of</font>
        |          {condition, ErrorCondition} -&gt;
<font color=red>     0..|              ErrorCondition;</font>
        |          {'EXIT', _} -&gt;
<font color=red>     0..|              &lt;&lt;"badformed error stanza"&gt;&gt;</font>
        |      end.
        |  
        |  
        |  -spec get_error_condition2(jlib:xmlel()) -&gt; {condition, binary()}.
        |  get_error_condition2(Packet) -&gt;
<font color=red>     0..|      #xmlel{children = EEls} = xml:get_subtag(Packet, &lt;&lt;"error"&gt;&gt;),</font>
<font color=red>     0..|      [Condition] = [Name || #xmlel{name = Name,</font>
        |                                    attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STANZAS}],
<font color=red>     0..|                                    children = []} &lt;- EEls],</font>
<font color=red>     0..|      {condition, Condition}.</font>
        |  
        |  
        |  -spec expulse_participant(jlib:xmlel(), ejabberd:jid(), state(), binary()) -&gt; state().
        |  expulse_participant(Packet, From, StateData, Reason1) -&gt;
<font color=red>     0..|      ErrorCondition = get_error_condition(Packet),</font>
<font color=red>     0..|      Reason2 = &lt;&lt;Reason1/binary, ": ", ErrorCondition/binary&gt;&gt;,</font>
<font color=red>     0..|      NewState = add_user_presence_un(</font>
        |          From,
        |          #xmlel{name = &lt;&lt;"presence"&gt;&gt;, attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"unavailable"&gt;&gt;}],
        |                 children = [#xmlel{name = &lt;&lt;"status"&gt;&gt;,
        |                                    children = [#xmlcdata{content = Reason2}]}]},
        |      StateData),
<font color=red>     0..|      send_new_presence_un(From, NewState),</font>
<font color=red>     0..|      remove_online_user(From, NewState).</font>
        |  
        |  
        |  -spec access_admin(state()) -&gt; any().
        |  access_admin(#state{access=Access}) -&gt;
<font color=red>     0..|      {_AccessRoute, _AccessCreate, AccessAdmin, _AccessPersistent} = Access,</font>
<font color=red>     0..|      AccessAdmin.</font>
        |  
        |  
        |  -spec access_persistent(state()) -&gt; any().
        |  access_persistent(#state{access=Access}) -&gt;
<font color=red>     0..|      {_AccessRoute, _AccessCreate, _AccessAdmin, AccessPersistent} = Access,</font>
<font color=red>     0..|      AccessPersistent.</font>
        |  
        |  
        |  -spec set_affiliation(ejabberd:jid(), mod_muc:affiliation(), state()) -&gt; state().
        |  set_affiliation(JID, Affiliation, StateData)
        |          when is_atom(Affiliation) -&gt;
<font color=red>     0..|      LJID = jid:to_bare(jid:to_lower(JID)),</font>
<font color=red>     0..|      Affiliations = case Affiliation of</font>
        |                 none -&gt;
<font color=red>     0..|                 ?DICT:erase(LJID,</font>
        |                         StateData#state.affiliations);
        |                 _ -&gt;
<font color=red>     0..|                 ?DICT:store(LJID,</font>
        |                         Affiliation,
        |                         StateData#state.affiliations)
        |             end,
<font color=red>     0..|      StateData#state{affiliations = Affiliations}.</font>
        |  
        |  
        |  -spec set_affiliation_and_reason(ejabberd:jid(), mod_muc:affiliation(), term(),
        |                                   state()) -&gt; state().
        |  set_affiliation_and_reason(JID, Affiliation, Reason, StateData)
        |          when is_atom(Affiliation) -&gt;
<font color=red>     0..|      LJID = jid:to_bare(jid:to_lower(JID)),</font>
<font color=red>     0..|      Affiliations = case Affiliation of</font>
        |                 none -&gt;
<font color=red>     0..|                 ?DICT:erase(LJID,</font>
        |                         StateData#state.affiliations);
        |                 _ -&gt;
<font color=red>     0..|                 ?DICT:store(LJID,</font>
        |                         {Affiliation, Reason},
        |                         StateData#state.affiliations)
        |             end,
<font color=red>     0..|      StateData#state{affiliations = Affiliations}.</font>
        |  
        |  
        |  -spec get_affiliation(ejabberd:jid(), state()) -&gt; mod_muc:affiliation().
        |  get_affiliation(JID, StateData) -&gt;
<font color=red>     0..|      AccessAdmin = access_admin(StateData),</font>
<font color=red>     0..|      Res =</font>
        |      case acl:match_rule(StateData#state.server_host, AccessAdmin, JID) of
        |          allow -&gt;
<font color=red>     0..|          owner;</font>
        |          _ -&gt;
<font color=red>     0..|          LJID = jid:to_lower(JID),</font>
<font color=red>     0..|          case ?DICT:find(LJID, StateData#state.affiliations) of</font>
        |              {ok, Affiliation} -&gt;
<font color=red>     0..|              Affiliation;</font>
        |              _ -&gt;
<font color=red>     0..|              LJID1 = jid:to_bare(LJID),</font>
<font color=red>     0..|              case ?DICT:find(LJID1, StateData#state.affiliations) of</font>
        |                  {ok, Affiliation} -&gt;
<font color=red>     0..|                  Affiliation;</font>
        |                  _ -&gt;
<font color=red>     0..|                  LJID2 = setelement(1, LJID, &lt;&lt;&gt;&gt;),</font>
<font color=red>     0..|                  case ?DICT:find(LJID2, StateData#state.affiliations) of</font>
        |                      {ok, Affiliation} -&gt;
<font color=red>     0..|                      Affiliation;</font>
        |                      _ -&gt;
<font color=red>     0..|                      LJID3 = jid:to_bare(LJID2),</font>
<font color=red>     0..|                      case ?DICT:find(LJID3, StateData#state.affiliations) of</font>
        |                          {ok, Affiliation} -&gt;
<font color=red>     0..|                          Affiliation;</font>
        |                          _ -&gt;
<font color=red>     0..|                          none</font>
        |                      end
        |                  end
        |              end
        |          end
        |      end,
<font color=red>     0..|      case Res of</font>
        |      {A, _Reason} -&gt;
<font color=red>     0..|          A;</font>
        |      _ -&gt;
<font color=red>     0..|          Res</font>
        |      end.
        |  
        |  
        |  -spec get_service_affiliation(ejabberd:jid(), state()) -&gt; mod_muc:affiliation().
        |  get_service_affiliation(JID, StateData) -&gt;
<font color=red>     0..|      AccessAdmin = access_admin(StateData),</font>
<font color=red>     0..|      case acl:match_rule(StateData#state.server_host, AccessAdmin, JID) of</font>
        |      allow -&gt;
<font color=red>     0..|          owner;</font>
        |      _ -&gt;
<font color=red>     0..|          none</font>
        |      end.
        |  
        |  
        |  -spec set_role(JID :: ejabberd:jid(), Role :: mod_muc:role(), state()) -&gt; state().
        |  set_role(JID, none, StateData) -&gt;
<font color=red>     0..|      erase_matched_users(JID, StateData);</font>
        |  set_role(JID, Role, StateData) -&gt;
<font color=red>     0..|      update_matched_users(fun(User) -&gt; User#user{role = Role} end,</font>
        |                           JID, StateData).
        |  
        |  
        |  -spec get_role( ejabberd:jid(), state()) -&gt; mod_muc:role().
        |  get_role(JID, StateData) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      case ?DICT:find(LJID, StateData#state.users) of</font>
        |      {ok, #user{role = Role}} -&gt;
<font color=red>     0..|          Role;</font>
        |      _ -&gt;
<font color=red>     0..|          none</font>
        |      end.
        |  
        |  
        |  -spec get_default_role(mod_muc:affiliation(), state()) -&gt; mod_muc:role().
        |  get_default_role(Affiliation, StateData) -&gt;
<font color=red>     0..|      case Affiliation of</font>
<font color=red>     0..|          owner   -&gt; moderator;</font>
<font color=red>     0..|          admin   -&gt; moderator;</font>
<font color=red>     0..|          member  -&gt; participant;</font>
<font color=red>     0..|          outcast -&gt; none;</font>
        |          none    -&gt;
<font color=red>     0..|              case (StateData#state.config)#config.members_only of</font>
        |                  true -&gt;
<font color=red>     0..|                      none;</font>
        |                  _ -&gt;
<font color=red>     0..|                      case (StateData#state.config)#config.members_by_default of</font>
        |                          true -&gt;
<font color=red>     0..|                              participant;</font>
        |                          _ -&gt;
<font color=red>     0..|                              visitor</font>
        |                      end
        |              end
        |      end.
        |  
        |  
        |  -spec is_visitor(ejabberd:jid(), state()) -&gt; boolean().
        |  is_visitor(Jid, StateData) -&gt;
<font color=red>     0..|      get_role(Jid, StateData) =:= visitor.</font>
        |  
        |  
        |  -spec is_empty_room(state()) -&gt; boolean().
        |  is_empty_room(#state{users=Users}) -&gt;
<font color=red>     0..|      is_empty_dict(Users).</font>
        |  
        |  
        |  -spec is_empty_dict(dict:dict(term(), term())) -&gt; boolean().
        |  is_empty_dict(Dict) -&gt;
<font color=red>     0..|      dict:size(Dict) =:= 0.</font>
        |  
        |  
        |  -spec dict_foreach_value(fun((_) -&gt; 'ok'), users_dict()) -&gt; any().
        |  dict_foreach_value(F, Users) -&gt;
<font color=red>     0..|      ?DICT:fold(fun(_LJID, User, _) -&gt; F(User) end, undefined, Users).</font>
        |  
        |  
        |  -spec dict_to_values(dict:dict(term(), term())) -&gt; [any()].
        |  dict_to_values(Dict) -&gt;
<font color=red>     0..|      [V || {_, V} &lt;- ?DICT:to_list(Dict)].</font>
        |  
        |  
        |  -spec count_users(state()) -&gt; non_neg_integer().
        |  count_users(#state{users=Users}) -&gt;
<font color=red>     0..|      ?DICT:size(Users).</font>
        |  
        |  
        |  -spec get_max_users(state()) -&gt; integer() | none.
        |  get_max_users(StateData) -&gt;
<font color=red>     0..|      MaxUsers = (StateData#state.config)#config.max_users,</font>
<font color=red>     0..|      ServiceMaxUsers = get_service_max_users(StateData),</font>
<font color=red>     0..|      if</font>
<font color=red>     0..|          MaxUsers =&lt; ServiceMaxUsers -&gt; MaxUsers;</font>
<font color=red>     0..|          true -&gt; ServiceMaxUsers</font>
        |      end.
        |  
        |  
        |  -spec get_service_max_users(state()) -&gt; integer() | none.
        |  get_service_max_users(StateData) -&gt;
<font color=red>     0..|      gen_mod:get_module_opt(StateData#state.server_host,</font>
        |                 mod_muc, max_users, ?MAX_USERS_DEFAULT).
        |  
        |  
        |  -spec get_max_users_admin_threshold(state()) -&gt; integer().
        |  get_max_users_admin_threshold(StateData) -&gt;
<font color=red>     0..|      gen_mod:get_module_opt(StateData#state.server_host,</font>
        |                 mod_muc, max_users_admin_threshold, 5).
        |  
        |  
        |  -spec get_user_activity(ejabberd:simple_jid() | ejabberd:jid(), state())
        |                          -&gt; activity().
        |  get_user_activity(JID, StateData) -&gt;
<font color=red>     0..|      case treap:lookup(jid:to_lower(JID),</font>
        |                StateData#state.activity) of
<font color=red>     0..|      {ok, _P, A} -&gt; A;</font>
        |      error -&gt;
<font color=red>     0..|          MessageShaper =</font>
        |          shaper:new(gen_mod:get_module_opt(
        |                   StateData#state.server_host,
        |                   mod_muc, user_message_shaper, none)),
<font color=red>     0..|          PresenceShaper =</font>
        |          shaper:new(gen_mod:get_module_opt(
        |                   StateData#state.server_host,
        |                   mod_muc, user_presence_shaper, none)),
<font color=red>     0..|          #activity{message_shaper = MessageShaper,</font>
        |                presence_shaper = PresenceShaper}
        |      end.
        |  
        |  
        |  -spec store_user_activity(ejabberd:simple_jid() | ejabberd:jid(), activity(),
        |                           state()) -&gt; state().
        |  store_user_activity(JID, UserActivity, StateData) -&gt;
<font color=red>     0..|      MinMessageInterval =</font>
        |      gen_mod:get_module_opt(
        |        StateData#state.server_host,
        |        mod_muc, min_message_interval, 0),
<font color=red>     0..|      MinPresenceInterval =</font>
        |      gen_mod:get_module_opt(
        |        StateData#state.server_host,
        |        mod_muc, min_presence_interval, 0),
<font color=red>     0..|      Key = jid:to_lower(JID),</font>
<font color=red>     0..|      Now = now_to_usec(os:timestamp()),</font>
<font color=red>     0..|      Activity1 = clean_treap(StateData#state.activity, {1, -Now}),</font>
<font color=red>     0..|      Activity =</font>
        |      case treap:lookup(Key, Activity1) of
        |          {ok, _P, _A} -&gt;
<font color=red>     0..|          treap:delete(Key, Activity1);</font>
        |          error -&gt;
<font color=red>     0..|          Activity1</font>
        |      end,
<font color=red>     0..|      StateData1 =</font>
<font color=red>     0..|      case (MinMessageInterval == 0) andalso</font>
<font color=red>     0..|          (MinPresenceInterval == 0) andalso</font>
<font color=red>     0..|          (UserActivity#activity.message_shaper == none) andalso</font>
<font color=red>     0..|          (UserActivity#activity.presence_shaper == none) andalso</font>
<font color=red>     0..|          (UserActivity#activity.message == undefined) andalso</font>
<font color=red>     0..|          (UserActivity#activity.presence == undefined) of</font>
        |          true -&gt;
<font color=red>     0..|          StateData#state{activity = Activity};</font>
        |          false -&gt;
<font color=red>     0..|          case (UserActivity#activity.message == undefined) andalso</font>
<font color=red>     0..|              (UserActivity#activity.presence == undefined) of</font>
        |              true -&gt;
<font color=red>     0..|              {_, MessageShaperInterval} =</font>
        |                  shaper:update(UserActivity#activity.message_shaper,
        |                        100000),
<font color=red>     0..|              {_, PresenceShaperInterval} =</font>
        |                  shaper:update(UserActivity#activity.presence_shaper,
        |                        100000),
<font color=red>     0..|              Delay = lists:max([MessageShaperInterval,</font>
        |                         PresenceShaperInterval,
        |                         MinMessageInterval * 1000,
        |                         MinPresenceInterval * 1000]) * 1000,
<font color=red>     0..|              Priority = {1, -(Now + Delay)},</font>
<font color=red>     0..|              StateData#state{</font>
        |                activity = treap:insert(
        |                         Key,
        |                         Priority,
        |                         UserActivity,
        |                         Activity)};
        |              false -&gt;
<font color=red>     0..|              Priority = {0, 0},</font>
<font color=red>     0..|              StateData#state{</font>
        |                activity = treap:insert(
        |                         Key,
        |                         Priority,
        |                         UserActivity,
        |                         Activity)}
        |          end
        |      end,
<font color=red>     0..|      StateData1.</font>
        |  
        |  
        |  -spec clean_treap(treap:treap(), {1,integer()}) -&gt; treap:treap().
        |  clean_treap(Treap, CleanPriority) -&gt;
<font color=red>     0..|      case treap:is_empty(Treap) of</font>
        |      true -&gt;
<font color=red>     0..|          Treap;</font>
        |      false -&gt;
<font color=red>     0..|          {_Key, Priority, _Value} = treap:get_root(Treap),</font>
<font color=red>     0..|          if</font>
        |          Priority &gt; CleanPriority -&gt;
<font color=red>     0..|              clean_treap(treap:delete_root(Treap), CleanPriority);</font>
        |          true -&gt;
<font color=red>     0..|              Treap</font>
        |          end
        |      end.
        |  
        |  
        |  -spec prepare_room_queue(state()) -&gt; state().
        |  prepare_room_queue(StateData) -&gt;
<font color=red>     0..|      case queue:out(StateData#state.room_queue) of</font>
        |      {{value, {message, From}}, _RoomQueue} -&gt;
<font color=red>     0..|          Activity = get_user_activity(From, StateData),</font>
<font color=red>     0..|          Packet = Activity#activity.message,</font>
<font color=red>     0..|          Size = element_size(Packet),</font>
<font color=red>     0..|          {RoomShaper, RoomShaperInterval} =</font>
        |          shaper:update(StateData#state.room_shaper, Size),
<font color=red>     0..|          erlang:send_after(</font>
        |            RoomShaperInterval, self(),
        |            process_room_queue),
<font color=red>     0..|          StateData#state{</font>
        |            room_shaper = RoomShaper};
        |      {{value, {presence, From}}, _RoomQueue} -&gt;
<font color=red>     0..|          Activity = get_user_activity(From, StateData),</font>
<font color=red>     0..|          {_Nick, Packet} = Activity#activity.presence,</font>
<font color=red>     0..|          Size = element_size(Packet),</font>
<font color=red>     0..|          {RoomShaper, RoomShaperInterval} =</font>
        |          shaper:update(StateData#state.room_shaper, Size),
<font color=red>     0..|          erlang:send_after(</font>
        |            RoomShaperInterval, self(),
        |            process_room_queue),
<font color=red>     0..|          StateData#state{</font>
        |            room_shaper = RoomShaper};
        |      {empty, _} -&gt;
<font color=red>     0..|          StateData</font>
        |      end.
        |  
        |  -spec is_first_session(mod_muc:nick(), state()) -&gt; boolean().
        |  is_first_session(Nick, StateData) -&gt;
<font color=red>     0..|      case ?DICT:find(Nick, StateData#state.sessions) of</font>
<font color=red>     0..|          {ok, _Val} -&gt; false;</font>
<font color=red>     0..|          error -&gt; true</font>
        |      end.
        |  
        |  -spec is_last_session(mod_muc:nick(), state()) -&gt; boolean().
        |  is_last_session(Nick, StateData) -&gt;
<font color=red>     0..|      case ?DICT:find(Nick, StateData#state.sessions) of</font>
<font color=red>     0..|          {ok, [_Val]} -&gt; true;</font>
<font color=red>     0..|          _ -&gt; false</font>
        |      end.
        |  
        |  -spec add_online_user(ejabberd:jid(), mod_muc:nick(), mod_muc:role(), state())
        |                          -&gt; state().
        |  add_online_user(JID, Nick, Role, StateData) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      Sessions = ?DICT:append(Nick, JID, StateData#state.sessions),</font>
<font color=red>     0..|      Users = ?DICT:store(LJID,</font>
        |              #user{jid = JID,
        |                    nick = Nick,
        |                    role = Role},
        |              StateData#state.users),
<font color=red>     0..|      case is_first_session(Nick, StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              add_to_log(join, Nick, StateData),</font>
<font color=red>     0..|              tab_add_online_user(JID, StateData);</font>
        |          _ -&gt;
<font color=red>     0..|              ok</font>
        |      end,
<font color=red>     0..|      StateData#state{users = Users, sessions = Sessions}.</font>
        |  
        |  
        |  -spec remove_online_user(ejabberd:jid(), state()) -&gt; state().
        |  remove_online_user(JID, StateData) -&gt;
<font color=red>     0..|      remove_online_user(JID, StateData, &lt;&lt;&gt;&gt;).</font>
        |  
        |  
        |  -spec remove_online_user(ejabberd:jid(), state(), Reason :: binary()) -&gt; state().
        |  remove_online_user(JID, StateData, Reason) -&gt;
        |  
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      {ok, #user{nick = Nick}} =</font>
        |          ?DICT:find(LJID, StateData#state.users),
<font color=red>     0..|      Sessions = case is_last_session(Nick, StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              add_to_log(leave, {Nick, Reason}, StateData),</font>
<font color=red>     0..|              tab_remove_online_user(JID, StateData),</font>
<font color=red>     0..|              ?DICT:erase(Nick, StateData#state.sessions);</font>
        |          false -&gt;
<font color=red>     0..|              IsOtherLJID = fun(J) -&gt; jid:to_lower(J) /= LJID end,</font>
<font color=red>     0..|              F = fun (JIDs) -&gt; lists:filter(IsOtherLJID, JIDs) end,</font>
<font color=red>     0..|              ?DICT:update(Nick, F, StateData#state.sessions)</font>
        |      end,
<font color=red>     0..|      Users = ?DICT:erase(LJID, StateData#state.users),</font>
        |  
<font color=red>     0..|      StateData#state{users = Users, sessions = Sessions}.</font>
        |  
        |  
        |  -spec filter_presence(jlib:xmlel()) -&gt; jlib:xmlel().
        |  filter_presence(#xmlel{name = &lt;&lt;"presence"&gt;&gt;, attrs = Attrs,
        |                         children = Els}) -&gt;
<font color=red>     0..|      FEls = lists:filter(</font>
        |           fun(El) -&gt;
<font color=red>     0..|               case El of</font>
        |               #xmlcdata{} -&gt;
<font color=red>     0..|                   false;</font>
        |               #xmlel{attrs = Attrs1} -&gt;
<font color=red>     0..|                   XMLNS = xml:get_attr_s(&lt;&lt;"xmlns"&gt;&gt;, Attrs1),</font>
<font color=red>     0..|                   case XMLNS of</font>
<font color=red>     0..|                   &lt;&lt;?NS_MUC_S, _/binary&gt;&gt; -&gt; false;</font>
        |                   _ -&gt;
<font color=red>     0..|                       true</font>
        |                   end
        |               end
        |           end, Els),
<font color=red>     0..|      #xmlel{name = &lt;&lt;"presence"&gt;&gt;, attrs = Attrs, children = FEls}.</font>
        |  
        |  
        |  -spec strip_status(jlib:xmlel()) -&gt; jlib:xmlel().
        |  strip_status(#xmlel{name = &lt;&lt;"presence"&gt;&gt;, attrs = Attrs,
        |                      children = Els}) -&gt;
<font color=red>     0..|      FEls = lists:filter(</font>
        |           fun(#xmlel{name = &lt;&lt;"status"&gt;&gt;}) -&gt;
<font color=red>     0..|                       false;</font>
<font color=red>     0..|                  (_) -&gt; true</font>
        |           end, Els),
<font color=red>     0..|      #xmlel{name = &lt;&lt;"presence"&gt;&gt;, attrs = Attrs, children = FEls}.</font>
        |  
        |  
        |  -spec add_user_presence(ejabberd:jid(), jlib:xmlel(), state()) -&gt; state().
        |  add_user_presence(JID, Presence, StateData) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      FPresence = filter_presence(Presence),</font>
<font color=red>     0..|      Users =</font>
        |      ?DICT:update(
        |          LJID,
        |          fun(#user{} = User) -&gt;
<font color=red>     0..|              User#user{last_presence = FPresence}</font>
        |          end, StateData#state.users),
<font color=red>     0..|      StateData#state{users = Users}.</font>
        |  
        |  
        |  -spec add_user_presence_un(ejabberd:simple_jid() | ejabberd:jid(), jlib:xmlel(),
        |                          state()) -&gt; state().
        |  add_user_presence_un(JID, Presence, StateData) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      FPresence = filter_presence(Presence),</font>
<font color=red>     0..|      Users =</font>
        |      ?DICT:update(
        |         LJID,
        |         fun(#user{} = User) -&gt;
<font color=red>     0..|             User#user{last_presence = FPresence, role = none}</font>
        |         end, StateData#state.users),
<font color=red>     0..|      StateData#state{users = Users}.</font>
        |  
        |  
        |  -spec is_nick_exists(mod_muc:nick(), state()) -&gt; boolean().
        |  is_nick_exists(Nick, StateData) -&gt;
<font color=red>     0..|      ?DICT:is_key(Nick, StateData#state.sessions).</font>
        |  
        |  
        |  -spec find_jids_by_nick(mod_muc:nick(), state()) -&gt; [ejabberd:jid()].
        |  find_jids_by_nick(Nick, StateData) -&gt;
<font color=red>     0..|      case ?DICT:find(Nick, StateData#state.sessions) of</font>
<font color=red>     0..|          error -&gt; [];</font>
<font color=red>     0..|          {ok, JIDs} -&gt; JIDs</font>
        |      end.
        |  
        |  -spec is_nick_change(ejabberd:simple_jid() | ejabberd:jid(), mod_muc:nick(),
        |                       state()) -&gt; boolean().
        |  is_nick_change(JID, Nick, StateData) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      case Nick of</font>
        |      &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|          false;</font>
        |      _ -&gt;
<font color=red>     0..|          {ok, #user{nick = OldNick}} =</font>
        |          ?DICT:find(LJID, StateData#state.users),
<font color=red>     0..|          Nick /= OldNick</font>
        |      end.
        |  
        |  
        |  -spec is_user_limit_reached(ejabberd:jid(), mod_muc:affiliation(), state()) -&gt; boolean().
        |  is_user_limit_reached(From, Affiliation, StateData) -&gt;
<font color=red>     0..|      MaxUsers = get_max_users(StateData),</font>
<font color=red>     0..|      MaxAdminUsers = case MaxUsers of</font>
<font color=red>     0..|                          none -&gt; none;</font>
<font color=red>     0..|                          _ -&gt; MaxUsers + get_max_users_admin_threshold(StateData)</font>
        |                      end,
<font color=red>     0..|      NUsers = count_users(StateData),</font>
<font color=red>     0..|      ServiceAffiliation = get_service_affiliation(From, StateData),</font>
<font color=red>     0..|      NConferences = tab_count_user(From),</font>
<font color=red>     0..|      MaxConferences = gen_mod:get_module_opt(</font>
        |                 StateData#state.server_host,
        |                 mod_muc, max_user_conferences, 10),
<font color=red>     0..|      (ServiceAffiliation == owner orelse</font>
<font color=red>     0..|         MaxUsers == none orelse</font>
<font color=red>     0..|         ((Affiliation == admin orelse Affiliation == owner) andalso</font>
<font color=red>     0..|          NUsers &lt; MaxAdminUsers) orelse</font>
<font color=red>     0..|         NUsers &lt; MaxUsers) andalso</font>
<font color=red>     0..|        NConferences &lt; MaxConferences.</font>
        |  
        |  is_next_session_of_occupant(From, Nick, StateData) -&gt;
<font color=red>     0..|    IsAllowed = (StateData#state.config)#config.allow_multiple_sessions,</font>
<font color=red>     0..|    case {IsAllowed, find_jids_by_nick(Nick, StateData)} of</font>
        |      {false, _} -&gt;
<font color=red>     0..|          false;</font>
        |      {_, []} -&gt;
<font color=red>     0..|          false;</font>
        |      {true, Jids} -&gt;
<font color=red>     0..|          lists:any(fun(Jid) -&gt;</font>
<font color=red>     0..|            From#jid.lserver == Jid#jid.lserver</font>
<font color=red>     0..|            andalso From#jid.luser == Jid#jid.luser</font>
        |          end, Jids)
        |    end.
        |  
        |  -spec choose_new_user_strategy(ejabberd:jid(), mod_muc:nick(),
        |          mod_muc:affiliation(), mod_muc:role(), [jlib:xmlcdata() | jlib:xmlel()],
        |          state()) -&gt; new_user_strategy().
        |  choose_new_user_strategy(From, Nick, Affiliation, Role, Els, StateData) -&gt;
<font color=red>     0..|      case {is_user_limit_reached(From, Affiliation, StateData),</font>
        |            is_nick_exists(Nick, StateData),
        |            is_next_session_of_occupant(From, Nick, StateData),
        |            mod_muc:can_use_nick(StateData#state.host, From, Nick),
        |            Role,
        |            Affiliation} of
        |          {false, _, _, _, _, _} -&gt;
<font color=red>     0..|              limit_reached;</font>
        |          {_, _, _, _, none, outcast} -&gt;
<font color=red>     0..|              user_banned;</font>
        |          {_, _, _, _, none, _} -&gt;
<font color=red>     0..|              require_membership;</font>
        |          {_, true, false, _, _, _} -&gt;
<font color=red>     0..|              conflict_use;</font>
        |          {_, _, _, false, _, _} -&gt;
<font color=red>     0..|              conflict_registered;</font>
        |          _ -&gt;
<font color=red>     0..|              ServiceAffiliation = get_service_affiliation(From, StateData),</font>
<font color=red>     0..|              case check_password(</font>
        |                  ServiceAffiliation, Affiliation, Els, From, StateData) of
<font color=red>     0..|                  true    -&gt; allowed;</font>
<font color=red>     0..|                  nopass  -&gt; require_password;</font>
<font color=red>     0..|                  _       -&gt; invalid_password</font>
        |              end
        |      end.
        |  
        |  
        |  -spec add_new_user(ejabberd:jid(), mod_muc:nick(), jlib:xmlel(), state()
        |                     ) -&gt; state().
        |  add_new_user(From, Nick,
        |               #xmlel{attrs = Attrs, children = Els} = Packet,
        |               #state{} = StateData) -&gt;
<font color=red>     0..|      Lang = xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      Affiliation = get_affiliation(From, StateData),</font>
<font color=red>     0..|      Role = get_default_role(Affiliation, StateData),</font>
<font color=red>     0..|      case choose_new_user_strategy(From, Nick, Affiliation, Role, Els, StateData) of</font>
        |          limit_reached -&gt;
        |              % max user reached and user is not admin or owner
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERR_SERVICE_UNAVAILABLE_WAIT),</font>
<font color=red>     0..|              route_error(Nick, From, Err, StateData);</font>
        |          user_banned -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"You have been banned from this room"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERRT_FORBIDDEN(Lang, ErrText)),</font>
<font color=red>     0..|              route_error(Nick, From, Err, StateData);</font>
        |          require_membership -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"Membership is required to enter this room"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(</font>
        |                  Packet, ?ERRT_REGISTRATION_REQUIRED(Lang, ErrText)),
<font color=red>     0..|              route_error(Nick, From, Err, StateData);</font>
        |          conflict_use -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"That nickname is already in use by another occupant"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERRT_CONFLICT(Lang, ErrText)),</font>
<font color=red>     0..|              route_error(Nick, From, Err, StateData);</font>
        |          conflict_registered -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"That nickname is registered by another person"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERRT_CONFLICT(Lang, ErrText)),</font>
<font color=red>     0..|              route_error(Nick, From, Err, StateData);</font>
        |          require_password -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"A password is required to enter this room"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(</font>
        |                  Packet, ?ERRT_NOT_AUTHORIZED(Lang, ErrText)),
<font color=red>     0..|              route_error(Nick, From, Err, StateData);</font>
        |          invalid_password -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"Incorrect password"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(</font>
        |                  Packet, ?ERRT_NOT_AUTHORIZED(Lang, ErrText)),
<font color=red>     0..|              route_error(Nick, From, Err, StateData);</font>
        |          allowed -&gt;
<font color=red>     0..|              NewState =</font>
        |              add_user_presence(
        |                From, Packet,
        |                add_online_user(From, Nick, Role, StateData)),
<font color=red>     0..|              send_existing_presences(From, NewState),</font>
<font color=red>     0..|              send_new_presence(From, NewState),</font>
<font color=red>     0..|              Shift = count_stanza_shift(Nick, Els, NewState),</font>
<font color=red>     0..|              case send_history(From, Shift, NewState) of</font>
        |                  true -&gt;
<font color=red>     0..|                      ok;</font>
        |                  _ -&gt;
<font color=red>     0..|                      send_subject(From, Lang, StateData)</font>
        |              end,
<font color=red>     0..|              case NewState#state.just_created of</font>
        |                  true -&gt;
<font color=red>     0..|                      NewState#state{just_created = false};</font>
        |                  false -&gt;
<font color=red>     0..|                      Robots = ?DICT:erase(From, StateData#state.robots),</font>
<font color=red>     0..|                      NewState#state{robots = Robots}</font>
        |              end
        |      end.
        |  
        |  
        |  -spec check_password(ServiceAffiliation :: mod_muc:affiliation(),
        |          Affiliation :: mod_muc:affiliation(), Els :: [jlib:xmlel()], _From,
        |          state()) -&gt; boolean() | nopass.
        |  check_password(owner, _Affiliation, _Els, _From, _StateData) -&gt;
        |      %% Don't check pass if user is owner in MUC service (access_admin option)
<font color=red>     0..|      true;</font>
        |  check_password(_ServiceAffiliation, _Affiliation, Els, _From, StateData) -&gt;
<font color=red>     0..|      case (StateData#state.config)#config.password_protected of</font>
        |          false -&gt;
        |              %% Don't check password
<font color=red>     0..|              true;</font>
        |          true -&gt;
<font color=red>     0..|              Pass = extract_password(Els),</font>
<font color=red>     0..|              case Pass of</font>
        |                  false -&gt;
<font color=red>     0..|                      nopass;</font>
        |                  _ -&gt;
<font color=red>     0..|                      (StateData#state.config)#config.password =:= Pass</font>
        |              end
        |      end.
        |  
        |  
        |  -spec extract_password([jlib:xmlcdata() | jlib:xmlel()]) -&gt; 'false' | binary().
        |  extract_password([]) -&gt;
<font color=red>     0..|      false;</font>
        |  extract_password([#xmlel{attrs = Attrs} = El | Els]) -&gt;
<font color=red>     0..|      case xml:get_attr_s(&lt;&lt;"xmlns"&gt;&gt;, Attrs) of</font>
        |      ?NS_MUC -&gt;
<font color=red>     0..|          case xml:get_subtag(El, &lt;&lt;"password"&gt;&gt;) of</font>
        |          false -&gt;
<font color=red>     0..|              false;</font>
        |          SubEl -&gt;
<font color=red>     0..|              xml:get_tag_cdata(SubEl)</font>
        |          end;
        |      _ -&gt;
<font color=red>     0..|          extract_password(Els)</font>
        |      end;
        |  extract_password([_ | Els]) -&gt;
<font color=red>     0..|      extract_password(Els).</font>
        |  
        |  
        |  -spec count_stanza_shift(mod_muc:nick(), [jlib:xmlcdata() | jlib:xmlel()],
        |                          state()) -&gt; any().
        |  count_stanza_shift(Nick, Els, StateData) -&gt;
<font color=red>     0..|      HL = lqueue_to_list(StateData#state.history),</font>
<font color=red>     0..|      Since = extract_history(Els, &lt;&lt;"since"&gt;&gt;),</font>
<font color=red>     0..|      Shift0 = case Since of</font>
        |           false -&gt;
<font color=red>     0..|               0;</font>
        |           _ -&gt;
<font color=red>     0..|               Sin = calendar:datetime_to_gregorian_seconds(Since),</font>
<font color=red>     0..|               count_seconds_shift(Sin, HL)</font>
        |           end,
<font color=red>     0..|      Seconds = extract_history(Els, &lt;&lt;"seconds"&gt;&gt;),</font>
<font color=red>     0..|      Shift1 = case Seconds of</font>
        |           false -&gt;
<font color=red>     0..|               0;</font>
        |           _ -&gt;
<font color=red>     0..|               Sec = calendar:datetime_to_gregorian_seconds(</font>
        |                   calendar:now_to_universal_time(os:timestamp())) - Seconds,
<font color=red>     0..|               count_seconds_shift(Sec, HL)</font>
        |           end,
<font color=red>     0..|      MaxStanzas = extract_history(Els, &lt;&lt;"maxstanzas"&gt;&gt;),</font>
<font color=red>     0..|      Shift2 = case MaxStanzas of</font>
        |           false -&gt;
<font color=red>     0..|               0;</font>
        |           _ -&gt;
<font color=red>     0..|               count_maxstanzas_shift(MaxStanzas, HL)</font>
        |           end,
<font color=red>     0..|      MaxChars = extract_history(Els, &lt;&lt;"maxchars"&gt;&gt;),</font>
<font color=red>     0..|      Shift3 = case MaxChars of</font>
        |           false -&gt;
<font color=red>     0..|               0;</font>
        |           _ -&gt;
<font color=red>     0..|               count_maxchars_shift(Nick, MaxChars, HL)</font>
        |           end,
<font color=red>     0..|      lists:max([Shift0, Shift1, Shift2, Shift3]).</font>
        |  
        |  
        |  -spec count_seconds_shift(integer(),[any()]) -&gt; number().
        |  count_seconds_shift(Seconds, HistoryList) -&gt;
<font color=red>     0..|      lists:sum(</font>
        |        lists:map(
        |      fun({_Nick, _Packet, _HaveSubject, TimeStamp, _Size}) -&gt;
<font color=red>     0..|          T = calendar:datetime_to_gregorian_seconds(TimeStamp),</font>
<font color=red>     0..|          if</font>
        |          T &lt; Seconds -&gt;
<font color=red>     0..|              1;</font>
        |          true -&gt;
<font color=red>     0..|              0</font>
        |          end
        |      end, HistoryList)).
        |  
        |  
        |  -spec count_maxstanzas_shift(non_neg_integer(),[any()]) -&gt; integer().
        |  count_maxstanzas_shift(MaxStanzas, HistoryList) -&gt;
<font color=red>     0..|      S = length(HistoryList) - MaxStanzas,</font>
<font color=red>     0..|      max(0, S).</font>
        |  
        |  
        |  -spec count_maxchars_shift(mod_muc:nick(), non_neg_integer() | calendar:datetime(),
        |                            [any()]) -&gt; non_neg_integer().
        |  count_maxchars_shift(Nick, MaxSize, HistoryList) -&gt;
<font color=red>     0..|      NLen = string:len(binary_to_list(Nick)) + 1,</font>
<font color=red>     0..|      Sizes = lists:map(</font>
        |            fun({_Nick, _Packet, _HaveSubject, _TimeStamp, Size}) -&gt;
<font color=red>     0..|            Size + NLen</font>
        |            end, HistoryList),
<font color=red>     0..|      calc_shift(MaxSize, Sizes).</font>
        |  
        |  
        |  -spec calc_shift(non_neg_integer() | calendar:datetime(), [number()]) -&gt; non_neg_integer().
        |  calc_shift(MaxSize, Sizes) -&gt;
<font color=red>     0..|      Total = lists:sum(Sizes),</font>
<font color=red>     0..|      calc_shift(MaxSize, Total, 0, Sizes).</font>
        |  
        |  
        |  -spec calc_shift(_MaxSize :: non_neg_integer() | calendar:datetime(),
        |          _Size :: number(), Shift :: non_neg_integer(), TSizes :: [number()]
        |          ) -&gt; non_neg_integer().
        |  calc_shift(_MaxSize, _Size, Shift, []) -&gt;
<font color=red>     0..|      Shift;</font>
        |  calc_shift(MaxSize, Size, Shift, [S | TSizes]) -&gt;
<font color=red>     0..|      if</font>
        |      MaxSize &gt;= Size -&gt;
<font color=red>     0..|          Shift;</font>
        |      true -&gt;
<font color=red>     0..|          calc_shift(MaxSize, Size - S, Shift + 1, TSizes)</font>
        |      end.
        |  
        |  
        |  -spec extract_history([jlib:xmlcdata() | jlib:xmlel()], _Type :: binary()
        |                       ) -&gt; 'false' | non_neg_integer() | calendar:datetime().
        |  extract_history([], _Type) -&gt;
<font color=red>     0..|      false;</font>
        |  extract_history([#xmlel{attrs = Attrs} = El | Els], Type) -&gt;
<font color=red>     0..|      case xml:get_attr_s(&lt;&lt;"xmlns"&gt;&gt;, Attrs) of</font>
        |      ?NS_MUC -&gt;
<font color=red>     0..|          AttrVal = xml:get_path_s(El,</font>
        |                 [{elem, &lt;&lt;"history"&gt;&gt;}, {attr, Type}]),
<font color=red>     0..|          case Type of</font>
        |          &lt;&lt;"since"&gt;&gt; -&gt;
<font color=red>     0..|              case jlib:datetime_binary_to_timestamp(AttrVal) of</font>
        |              undefined -&gt;
<font color=red>     0..|                  false;</font>
        |              TS -&gt;
<font color=red>     0..|                  calendar:now_to_universal_time(TS)</font>
        |              end;
        |          _ -&gt;
<font color=red>     0..|              case catch binary_to_integer(AttrVal) of</font>
        |              IntVal when is_integer(IntVal) and (IntVal &gt;= 0) -&gt;
<font color=red>     0..|                  IntVal;</font>
        |              _ -&gt;
<font color=red>     0..|                  false</font>
        |              end
        |          end;
        |      _ -&gt;
<font color=red>     0..|          extract_history(Els, Type)</font>
        |      end;
        |  extract_history([_ | Els], Type) -&gt;
<font color=red>     0..|      extract_history(Els, Type).</font>
        |  
        |  
        |  -spec send_update_presence(ejabberd:jid(), Reason :: binary(), state()) -&gt; any().
        |  send_update_presence(JID, Reason, StateData) -&gt;
<font color=red>     0..|      foreach_matched_jid(fun(J) -&gt;</font>
<font color=red>     0..|                            send_new_presence(J, Reason, StateData)</font>
        |                          end, JID, StateData).
        |  
        |  
        |  -spec foreach_matched_jid(fun((_) -&gt; 'ok'), ejabberd:jid(), state()) -&gt; ok.
        |  foreach_matched_jid(F, JID, #state{users=Users}) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      case LJID of</font>
        |          %% Match by bare JID
        |          {U, S, &lt;&lt;&gt;&gt;} -&gt;
<font color=red>     0..|              FF = fun(J, #user{jid=MatchedJID}, _) -&gt;</font>
<font color=red>     0..|                       case J of</font>
<font color=red>     0..|                           {U, S, _} -&gt; F(MatchedJID);</font>
<font color=red>     0..|                           _         -&gt; ok</font>
        |                       end
        |                   end,
<font color=red>     0..|              ?DICT:fold(FF, ok, Users);</font>
        |          %% Match by full JID
        |          _ -&gt;
<font color=red>     0..|              case ?DICT:is_key(LJID, Users) of</font>
        |                  true -&gt;
<font color=red>     0..|                      F(JID),</font>
<font color=red>     0..|                      ok;</font>
        |                  false -&gt;
<font color=red>     0..|                      ok</font>
        |              end
        |      end.
        |  
        |  
        |  -spec foreach_matched_user(fun((_) -&gt; 'ok'), ejabberd:simple_jid() | ejabberd:jid(),
        |                             state()) -&gt; ok.
        |  foreach_matched_user(F, JID, #state{users=Users}) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      case LJID of</font>
        |          %% Match by bare JID
        |          {U, S, &lt;&lt;&gt;&gt;} -&gt;
<font color=red>     0..|              FF = fun(J, User, _) -&gt;</font>
<font color=red>     0..|                       case J of</font>
<font color=red>     0..|                           {U, S, _} -&gt; F(User);</font>
<font color=red>     0..|                           _         -&gt; ok</font>
        |                       end
        |                   end,
<font color=red>     0..|              ?DICT:fold(FF, ok, Users);</font>
        |          %% Match by full JID
        |          _ -&gt;
<font color=red>     0..|              case ?DICT:find(LJID, Users) of</font>
<font color=red>     0..|                  {ok, User} -&gt; F(User);</font>
<font color=red>     0..|                  error -&gt; ok</font>
        |              end
        |      end.
        |  
        |  
        |  -spec foreach_user(fun((_) -&gt; 'ok'), state()) -&gt; any().
        |  foreach_user(F, #state{users=Users}) -&gt;
<font color=red>     0..|      dict_foreach_value(F, Users).</font>
        |  
        |  
        |  -spec erase_matched_users(ejabberd:simple_jid() | ejabberd:jid(), state()) -&gt; state().
        |  erase_matched_users(JID, StateData=#state{users=Users, sessions=Sessions}) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      {NewUsers, NewSessions} = erase_matched_users_dict(LJID, Users, Sessions),</font>
<font color=red>     0..|      StateData#state{users=NewUsers, sessions=NewSessions}.</font>
        |  
        |  
        |  -spec erase_matched_users_dict('error' | ejabberd:simple_jid(),
        |                                 users_dict(), sessions_dict()) -&gt; any().
        |  erase_matched_users_dict(LJID, Users, Sessions) -&gt;
<font color=red>     0..|      case LJID of</font>
        |          %% Match by bare JID
        |          {U, S, &lt;&lt;&gt;&gt;} -&gt;
<font color=red>     0..|              FF = fun(J, #user{nick=Nick}, {Us, Ss}) -&gt;</font>
<font color=red>     0..|                       case J of</font>
<font color=red>     0..|                           {U, S, _} -&gt; {?DICT:erase(J, Us),?DICT:erase(Nick, Ss)};</font>
<font color=red>     0..|                           _         -&gt; {Us, Ss}</font>
        |                       end
        |                   end,
<font color=red>     0..|              ?DICT:fold(FF, {Users, Sessions}, Users);</font>
        |          %% Match by full JID
        |          _ -&gt;
<font color=red>     0..|              {ok, #user{nick=Nick}} = ?DICT:find(LJID, Users),</font>
<font color=red>     0..|              {?DICT:erase(LJID, Users),</font>
        |               ?DICT:erase(Nick, Sessions)}
        |      end.
        |  
        |  
        |  -spec update_matched_users(F :: fun((user()) -&gt; user()), JID :: ejabberd:jid(),
        |                             state()) -&gt; state().
        |  update_matched_users(F, JID, StateData=#state{users=Users}) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      NewUsers = update_matched_users_dict(F, LJID, Users),</font>
<font color=red>     0..|      StateData#state{users=NewUsers}.</font>
        |  
        |  
        |  -spec update_matched_users_dict(fun((user()) -&gt; user()),
        |                                'error' | ejabberd:simple_jid(), users_dict()) -&gt; any().
        |  update_matched_users_dict(F, LJID, Users) -&gt;
<font color=red>     0..|      case LJID of</font>
        |          %% Match by bare JID
        |          {U, S, &lt;&lt;&gt;&gt;} -&gt;
<font color=red>     0..|              FF = fun(J, User, Us) -&gt;</font>
<font color=red>     0..|                       case J of</font>
<font color=red>     0..|                           {U, S, _} -&gt; ?DICT:store(J, F(User), Us);</font>
<font color=red>     0..|                           _         -&gt; Us</font>
        |                       end
        |                   end,
<font color=red>     0..|              ?DICT:fold(FF, Users, Users);</font>
        |          %% Match by full JID
        |          _ -&gt;
<font color=red>     0..|              case ?DICT:find(LJID, Users) of</font>
<font color=red>     0..|                  {ok, User} -&gt; ?DICT:store(LJID, F(User), Users);</font>
<font color=red>     0..|                  error -&gt; Users</font>
        |              end
        |      end.
        |  
        |  -spec send_new_presence_un(ejabberd:jid(), state()) -&gt; 'ok'.
        |  send_new_presence_un(NJID, StateData) -&gt;
<font color=red>     0..|      send_new_presence_un(NJID, &lt;&lt;&gt;&gt;, StateData).</font>
        |  
        |  
        |  -spec send_new_presence_un(ejabberd:jid(), binary(), state()) -&gt; 'ok'.
        |  send_new_presence_un(NJID, Reason, StateData) -&gt;
<font color=red>     0..|      {ok, #user{nick = Nick}} = ?DICT:find(jid:to_lower(NJID), StateData#state.users),</font>
<font color=red>     0..|      case is_last_session(Nick, StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              send_new_presence(NJID, Reason, StateData);</font>
        |          false -&gt;
<font color=red>     0..|              UserJIDs = ?DICT:fetch(Nick, StateData#state.sessions),</font>
<font color=red>     0..|              GetUserTupleByJID = fun(JID) -&gt;</font>
<font color=red>     0..|                  LJID = jid:to_lower(JID),</font>
<font color=red>     0..|                  {LJID, ?DICT:fetch(LJID, StateData#state.users)}</font>
        |              end,
<font color=red>     0..|              CurrentSessionUsers = lists:map(GetUserTupleByJID, UserJIDs),</font>
<font color=red>     0..|              send_new_presence_to(NJID, Reason, CurrentSessionUsers, StateData)</font>
        |      end.
        |  
        |  
        |  -spec send_new_presence(ejabberd:jid(), state()) -&gt; 'ok'.
        |  send_new_presence(NJID, StateData) -&gt;
<font color=red>     0..|      send_new_presence(NJID, &lt;&lt;&gt;&gt;, StateData).</font>
        |  
        |  
        |  -spec send_new_presence(ejabberd:jid(), binary(), state()) -&gt; 'ok'.
        |  send_new_presence(NJID, Reason, StateData) -&gt;
<font color=red>     0..|      send_new_presence_to(NJID, Reason, ?DICT:to_list(StateData#state.users), StateData).</font>
        |  
        |  
        |  -spec send_new_presence_to(ejabberd:jid(), binary(), [{ejabberd:jid(), #user{}}], state()) -&gt; 'ok'.
        |  send_new_presence_to(NJID, Reason, Receivers, StateData) -&gt;
        |      {ok, #user{jid = RealJID,
        |             nick = Nick,
        |             role = Role,
<font color=red>     0..|             last_presence = Presence}} =</font>
        |      ?DICT:find(jid:to_lower(NJID), StateData#state.users),
<font color=red>     0..|      Affiliation = get_affiliation(NJID, StateData),</font>
<font color=red>     0..|      BAffiliation = affiliation_to_binary(Affiliation),</font>
<font color=red>     0..|      BRole = role_to_binary(Role),</font>
<font color=red>     0..|      lists:foreach(</font>
        |        fun({_LJID, Info}) -&gt;
<font color=red>     0..|            ItemAttrs =</font>
<font color=red>     0..|            case (Info#user.role == moderator) orelse</font>
<font color=red>     0..|                ((StateData#state.config)#config.anonymous == false) of</font>
        |                true -&gt;
<font color=red>     0..|                [{&lt;&lt;"jid"&gt;&gt;, jid:to_binary(RealJID)},</font>
        |                 {&lt;&lt;"affiliation"&gt;&gt;, BAffiliation},
        |                 {&lt;&lt;"role"&gt;&gt;, BRole}];
        |                _ -&gt;
<font color=red>     0..|                [{&lt;&lt;"affiliation"&gt;&gt;, BAffiliation},</font>
        |                 {&lt;&lt;"role"&gt;&gt;, BRole}]
        |            end,
<font color=red>     0..|            ItemEls = case Reason of</font>
        |                  &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|                  [];</font>
        |                  _ -&gt;
<font color=red>     0..|                  [#xmlel{name = &lt;&lt;"reason"&gt;&gt;, children = [#xmlcdata{content = Reason}]}]</font>
        |                      end,
<font color=red>     0..|            Status = case StateData#state.just_created of</font>
        |                 true -&gt;
<font color=red>     0..|                     [status_code(201)];</font>
        |                 false -&gt;
<font color=red>     0..|                     []</font>
        |                 end,
<font color=red>     0..|            Status2 = case (NJID == Info#user.jid) of</font>
        |                   true -&gt;
<font color=red>     0..|                      Status0 = case   (StateData#state.config)#config.logging of</font>
        |                              true -&gt;
<font color=red>     0..|                              [status_code(170) | Status];</font>
        |                              false -&gt;
<font color=red>     0..|                              Status</font>
        |                          end,
<font color=red>     0..|                      Status1 = case ((StateData#state.config)#config.anonymous==false) of</font>
        |                              true -&gt;
<font color=red>     0..|                              [status_code(100) | Status0];</font>
        |                              false -&gt;
<font color=red>     0..|                              Status0</font>
        |                          end,
<font color=red>     0..|                      case ((NJID == Info#user.jid)==true) of</font>
        |                              true -&gt;
<font color=red>     0..|                              [status_code(110) | Status1];</font>
        |                              false -&gt;
<font color=red>     0..|                              Status1</font>
        |                          end;
        |                  false -&gt;
<font color=red>     0..|                          Status</font>
        |            end,
<font color=red>     0..|            Packet = xml:append_subtags(</font>
        |               Presence,
        |               [#xmlel{name = &lt;&lt;"x"&gt;&gt;, attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_USER}],
        |                       children = [#xmlel{name = &lt;&lt;"item"&gt;&gt;, attrs = ItemAttrs,
        |                                          children = ItemEls} | Status2]}]),
<font color=red>     0..|            ejabberd_router:route(</font>
        |              jid:replace_resource(StateData#state.jid, Nick),
        |              Info#user.jid,
        |              Packet)
        |        end, Receivers).
        |  
        |  
        |  -spec send_existing_presences(ejabberd:jid(), state()) -&gt; 'ok'.
        |  send_existing_presences(ToJID, StateData) -&gt;
<font color=red>     0..|      LToJID = jid:to_lower(ToJID),</font>
<font color=red>     0..|      {ok, #user{jid = RealToJID, role = Role, nick = _Nick}} =</font>
        |      ?DICT:find(LToJID, StateData#state.users),
        |      % if you don't want to send presences of other sessions of occupant with ToJID
        |      % switch following lines
        |      % JIDsToSkip = [RealToJID | find_jids_by_nick(_Nick, StateData)],
<font color=red>     0..|      JIDsToSkip = [RealToJID],</font>
<font color=red>     0..|      lists:foreach(</font>
        |          fun({LJID, #user{jid = FromJID,
        |                 nick = FromNick,
        |                 role = FromRole,
        |                 last_presence = Presence}}) -&gt;
<font color=red>     0..|              case lists:member(FromJID, JIDsToSkip) of</font>
        |                  true -&gt;
<font color=red>     0..|                      ok;</font>
        |                  _ -&gt;
<font color=red>     0..|                      FromAffiliation = get_affiliation(LJID, StateData),</font>
<font color=red>     0..|                      ItemAttrs =</font>
<font color=red>     0..|                      case (Role == moderator) orelse</font>
<font color=red>     0..|                           ((StateData#state.config)#config.anonymous == false) of</font>
        |                          true -&gt;
<font color=red>     0..|                              [{&lt;&lt;"jid"&gt;&gt;, jid:to_binary(FromJID)},</font>
        |                              {&lt;&lt;"affiliation"&gt;&gt;,
        |                              affiliation_to_binary(FromAffiliation)},
        |                              {&lt;&lt;"role"&gt;&gt;, role_to_binary(FromRole)}];
        |                          _ -&gt;
<font color=red>     0..|                              [{&lt;&lt;"affiliation"&gt;&gt;,</font>
        |                              affiliation_to_binary(FromAffiliation)},
        |                              {&lt;&lt;"role"&gt;&gt;, role_to_binary(FromRole)}]
        |                      end,
<font color=red>     0..|                      Packet = xml:append_subtags(</font>
        |                          Presence,
        |                          [#xmlel{name = &lt;&lt;"x"&gt;&gt;,
        |                                  attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_USER}],
        |                                  children = [#xmlel{name = &lt;&lt;"item"&gt;&gt;,
        |                                                     attrs = ItemAttrs}]}]),
<font color=red>     0..|                          ejabberd_router:route(</font>
        |                      jid:replace_resource(
        |                     StateData#state.jid, FromNick),
        |                      RealToJID,
        |                      Packet)
        |              end
        |          end, ?DICT:to_list(StateData#state.users)).
        |  
        |  
        |  -spec send_config_update(atom(), state()) -&gt; 'ok'.
        |  send_config_update(Type, StateData) -&gt;
<font color=red>     0..|      Status = case Type of</font>
<font color=red>     0..|              logging_enabled     -&gt; &lt;&lt;"170"&gt;&gt;;</font>
<font color=red>     0..|              logging_disabled    -&gt; &lt;&lt;"171"&gt;&gt;;</font>
<font color=red>     0..|              nonanonymous        -&gt; &lt;&lt;"172"&gt;&gt;;</font>
<font color=red>     0..|              semianonymous       -&gt; &lt;&lt;"173"&gt;&gt;</font>
        |          end,
<font color=red>     0..|      Message = jlib:make_config_change_message(Status),</font>
<font color=red>     0..|      lists:foreach(fun({_LJID, Info}) -&gt;</font>
<font color=red>     0..|          ejabberd_router:route(</font>
        |              StateData#state.jid,
        |              Info#user.jid,
        |              Message)
        |          end, ?DICT:to_list(StateData#state.users)).
        |  
        |  
        |  -spec send_invitation(ejabberd:jid(), ejabberd:jid(), binary(), state()) -&gt; 'ok'.
        |  send_invitation(From, To, Reason, StateData=#state{host=Host, server_host=ServerHost, jid=RoomJID}) -&gt;
<font color=red>     0..|      ejabberd_hooks:run(invitation_sent, Host, [Host, ServerHost, RoomJID, From, To, Reason]),</font>
<font color=red>     0..|      Config = StateData#state.config,</font>
<font color=red>     0..|      Password = case Config#config.password_protected of</font>
<font color=red>     0..|          false -&gt; &lt;&lt;&gt;&gt;;</font>
<font color=red>     0..|          true -&gt; Config#config.password</font>
        |      end,
<font color=red>     0..|      ejabberd_router:route(</font>
        |          RoomJID,
        |          To,
        |          jlib:make_invitation(
        |              jid:replace_resource(From, &lt;&lt;&gt;&gt;), Password, Reason)).
        |  
        |  
        |  -spec now_to_usec(erlang:timestamp()) -&gt; non_neg_integer().
        |  now_to_usec({MSec, Sec, USec}) -&gt;
<font color=red>     0..|      (MSec*1000000 + Sec)*1000000 + USec.</font>
        |  
        |  
        |  -spec change_nick(ejabberd:jid(), binary(), state()) -&gt; state().
        |  change_nick(JID, Nick, StateData) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      {ok, #user{nick = OldNick}} =</font>
        |      ?DICT:find(LJID, StateData#state.users),
<font color=red>     0..|      Users =</font>
        |      ?DICT:update(
        |         LJID,
        |         fun(#user{} = User) -&gt;
<font color=red>     0..|             User#user{nick = Nick}</font>
        |         end, StateData#state.users),
<font color=red>     0..|      {ok, JIDs} = ?DICT:find(OldNick, StateData#state.sessions),</font>
<font color=red>     0..|      Sessions = ?DICT:erase(OldNick, ?DICT:store(Nick, JIDs, StateData#state.sessions)),</font>
<font color=red>     0..|      NewStateData = StateData#state{users = Users, sessions = Sessions},</font>
<font color=red>     0..|      send_nick_changing(JID, OldNick, NewStateData),</font>
<font color=red>     0..|      add_to_log(nickchange, {OldNick, Nick}, StateData),</font>
<font color=red>     0..|      NewStateData.</font>
        |  
        |  
        |  -spec send_nick_changing(ejabberd:jid(), mod_muc:nick(), state()) -&gt; 'ok'.
        |  send_nick_changing(JID, OldNick, StateData) -&gt;
<font color=red>     0..|      User = ?DICT:find(jid:to_lower(JID), StateData#state.users),</font>
        |      {ok, #user{jid = RealJID,
        |                 nick = Nick,
        |                 role = Role,
<font color=red>     0..|                 last_presence = Presence}} = User,</font>
<font color=red>     0..|      Affiliation = get_affiliation(JID, StateData),</font>
<font color=red>     0..|      lists:foreach(mk_send_nick_change(Presence, OldNick, JID, RealJID,</font>
        |                                        Affiliation, Role, Nick, StateData),
        |                    ?DICT:to_list(StateData#state.users)).
        |  
        |  mk_send_nick_change(Presence, OldNick, JID, RealJID,  Affiliation,
        |                      Role, Nick, StateData) -&gt;
<font color=red>     0..|      fun({LJID, Info}) -&gt;</font>
<font color=red>     0..|              send_nick_change(Presence, OldNick, JID, RealJID, Affiliation,</font>
        |                               Role, Nick, LJID, Info, StateData)
        |      end.
        |  
        |  send_nick_change(Presence, OldNick, JID, RealJID, Affiliation, Role,
        |                   Nick, _LJID, Info, #state{} = S) -&gt;
<font color=red>     0..|      MaybePublicJID = case is_nick_change_public(Info, S#state.config) of</font>
<font color=red>     0..|                           true -&gt; RealJID;</font>
<font color=red>     0..|                           false -&gt; undefined</font>
        |                       end,
<font color=red>     0..|      MaybeSelfPresenceCode = if</font>
<font color=red>     0..|                                  JID == Info#user.jid -&gt; status_code(110);</font>
<font color=red>     0..|                                  true -&gt; undefined</font>
        |                              end,
<font color=red>     0..|      Unavailable = nick_unavailable_presence(MaybePublicJID, Nick, Affiliation,</font>
        |                                              Role, MaybeSelfPresenceCode),
<font color=red>     0..|      ejabberd_router:route(jid:replace_resource(S#state.jid, OldNick),</font>
        |                            Info#user.jid, Unavailable),
<font color=red>     0..|      Available = nick_available_presence(Presence, MaybePublicJID, Affiliation,</font>
        |                                          Role, MaybeSelfPresenceCode),
<font color=red>     0..|      ejabberd_router:route(jid:replace_resource(S#state.jid, Nick),</font>
        |                            Info#user.jid, Available).
        |  
        |  -spec is_nick_change_public(user(), config()) -&gt; boolean().
        |  is_nick_change_public(UserInfo, RoomConfig) -&gt;
<font color=red>     0..|      UserInfo#user.role == moderator</font>
        |      orelse
<font color=red>     0..|      RoomConfig#config.anonymous == false.</font>
        |  
        |  -spec status_code(integer()) -&gt; jlib:xmlel().
        |  status_code(Code) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"status"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"code"&gt;&gt;, integer_to_binary(Code)}]}.
        |  
        |  -spec nick_unavailable_presence(MaybeJID, Nick, Affiliation, Role, MaybeCode) -&gt;
        |      jlib:xmlel() when
        |        MaybeJID :: 'undefined' | ejabberd:jid(),
        |        Nick :: mod_muc:nick(),
        |        Affiliation :: mod_muc:affiliation(),
        |        Role :: mod_muc:role(),
        |        MaybeCode :: 'undefined' | jlib:xmlel().
        |  nick_unavailable_presence(MaybeJID, Nick, Affiliation, Role, MaybeCode) -&gt;
<font color=red>     0..|      presence(&lt;&lt;"unavailable"&gt;&gt;,</font>
        |               [muc_user_x([muc_user_item(MaybeJID, Nick, Affiliation, Role),
        |                            status_code(303)]
<font color=red>     0..|                           ++ [MaybeCode || MaybeCode /= undefined])]).</font>
        |  
        |  -spec nick_available_presence(LastPresence, MaybeJID, Affiliation,
        |                                Role, MaybeCode) -&gt; jlib:xmlel() when
        |        LastPresence :: jlib:xmlel(),
        |        MaybeJID :: 'undefined' | ejabberd:jid(),
        |        Affiliation :: mod_muc:affiliation(),
        |        Role :: mod_muc:role(),
        |        MaybeCode :: 'undefined' | jlib:xmlel().
        |  nick_available_presence(LastPresence, MaybeJID, Affiliation, Role, MaybeCode) -&gt;
<font color=red>     0..|      Item = muc_user_item(MaybeJID, undefined, Affiliation, Role),</font>
<font color=red>     0..|      xml:append_subtags(LastPresence,</font>
<font color=red>     0..|                         [muc_user_x([Item] ++ [MaybeCode</font>
<font color=red>     0..|                                                || MaybeCode /= undefined])]).</font>
        |  
        |  -spec muc_user_item(MaybeJID, MaybeNick, Affiliation, Role) -&gt; jlib:xmlel() when
        |        MaybeJID :: 'undefined' | ejabberd:jid(),
        |        MaybeNick :: 'undefined' | mod_muc:nick(),
        |        Affiliation :: mod_muc:affiliation(),
        |        Role :: mod_muc:role().
        |  muc_user_item(MaybeJID, MaybeNick, Affiliation, Role) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"item"&gt;&gt;,</font>
<font color=red>     0..|             attrs = [{&lt;&lt;"jid"&gt;&gt;, jid:to_binary(MaybeJID)}</font>
<font color=red>     0..|                      || MaybeJID /= undefined] ++</font>
<font color=red>     0..|                     [{&lt;&lt;"nick"&gt;&gt;, MaybeNick} || MaybeNick /= undefined] ++</font>
        |                     [{&lt;&lt;"affiliation"&gt;&gt;, affiliation_to_binary(Affiliation)},
        |                      {&lt;&lt;"role"&gt;&gt;, role_to_binary(Role)}]}.
        |  
        |  -spec muc_user_x([jlib:xmlel()]) -&gt; jlib:xmlel().
        |  muc_user_x(Children) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"x"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_USER}],
        |             children = Children}.
        |  
        |  -spec presence(binary(), [jlib:xmlel()]) -&gt; jlib:xmlel().
        |  %% Add and validate other types if need be.
        |  presence(&lt;&lt;"unavailable"&gt;&gt; = Type, Children) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"presence"&gt;&gt;,</font>
<font color=red>     0..|             attrs = [{&lt;&lt;"type"&gt;&gt;, Type} || Type /= &lt;&lt;"available"&gt;&gt;],</font>
        |             children = Children}.
        |  
        |  
        |  -spec lqueue_new(integer()) -&gt; lqueue().
        |  lqueue_new(Max) -&gt;
<font color=red>     0..|      #lqueue{queue = queue:new(),</font>
        |          len = 0,
        |          max = Max}.
        |  
        |  
        |  %% @doc If the message queue limit is set to 0, do not store messages.
        |  %% Otherwise, rotate messages in the queue store.
        |  -spec lqueue_in(any(), lqueue()) -&gt; lqueue().
        |  lqueue_in(_Item, LQ = #lqueue{max = 0}) -&gt;
<font color=red>     0..|      LQ;</font>
        |  lqueue_in(Item, #lqueue{queue = Q1, len = Len, max = Max}) -&gt;
<font color=red>     0..|      Q2 = queue:in(Item, Q1),</font>
<font color=red>     0..|      if</font>
        |      Len &gt;= Max -&gt;
<font color=red>     0..|          Q3 = lqueue_cut(Q2, Len - Max + 1),</font>
<font color=red>     0..|          #lqueue{queue = Q3, len = Max, max = Max};</font>
        |      true -&gt;
<font color=red>     0..|          #lqueue{queue = Q2, len = Len + 1, max = Max}</font>
        |      end.
        |  
        |  
        |  -spec lqueue_cut(ejabberd:queue_t(), non_neg_integer()) -&gt; ejabberd:queue_t().
        |  lqueue_cut(Q, 0) -&gt;
<font color=red>     0..|      Q;</font>
        |  lqueue_cut(Q, N) -&gt;
<font color=red>     0..|      {_, Q1} = queue:out(Q),</font>
<font color=red>     0..|      lqueue_cut(Q1, N - 1).</font>
        |  
        |  
        |  -spec lqueue_to_list(lqueue()) -&gt; [any()].
        |  lqueue_to_list(#lqueue{queue = Q1}) -&gt;
<font color=red>     0..|      queue:to_list(Q1).</font>
        |  
        |  
        |  -spec add_message_to_history(mod_muc:nick(), ejabberd:jid(), jlib:xmlel(),
        |                              state()) -&gt; state().
        |  add_message_to_history(FromNick, FromJID, Packet, StateData) -&gt;
<font color=red>     0..|      HaveSubject = case xml:get_subtag(Packet, &lt;&lt;"subject"&gt;&gt;) of</font>
        |                false -&gt;
<font color=red>     0..|                false;</font>
        |                _ -&gt;
<font color=red>     0..|                true</font>
        |            end,
<font color=red>     0..|      TimeStamp = calendar:now_to_universal_time(os:timestamp()),</font>
        |      %% Chatroom history is stored as XMPP packets, so
        |      %% the decision to include the original sender's JID or not is based on the
        |      %% chatroom configuration when the message was originally sent.
        |      %% Also, if the chatroom is anonymous, even moderators will not get the real JID
<font color=red>     0..|      SenderJid = case   (StateData#state.config)#config.anonymous of</font>
<font color=red>     0..|      true -&gt; StateData#state.jid;</font>
<font color=red>     0..|      false -&gt; FromJID</font>
        |      end,
<font color=red>     0..|      TSPacket = xml:append_subtags(Packet,</font>
        |                    [jlib:timestamp_to_xml(TimeStamp, utc, SenderJid, &lt;&lt;&gt;&gt;)]),
<font color=red>     0..|      SPacket = jlib:replace_from_to(</font>
        |          jid:replace_resource(StateData#state.jid, FromNick),
        |          StateData#state.jid,
        |          TSPacket),
<font color=red>     0..|      Size = element_size(SPacket),</font>
<font color=red>     0..|      Q1 = lqueue_in({FromNick, TSPacket, HaveSubject, TimeStamp, Size},</font>
        |             StateData#state.history),
<font color=red>     0..|      add_to_log(text, {FromNick, Packet}, StateData),</font>
<font color=red>     0..|      ejabberd_hooks:run(room_packet, StateData#state.host,</font>
        |                         [FromNick, FromJID, StateData#state.jid, Packet]),
<font color=red>     0..|      StateData#state{history = Q1}.</font>
        |  
        |  
        |  -spec send_history(ejabberd:jid(), Shift :: non_neg_integer(), state()) -&gt; boolean().
        |  send_history(JID, Shift, StateData) -&gt;
<font color=red>     0..|      lists:foldl(</font>
        |        fun({Nick, Packet, HaveSubject, _TimeStamp, _Size}, B) -&gt;
<font color=red>     0..|            ejabberd_router:route(</font>
        |          jid:replace_resource(StateData#state.jid, Nick),
        |          JID,
        |          Packet),
<font color=red>     0..|            B or HaveSubject</font>
        |        end, false, lists:nthtail(Shift, lqueue_to_list(StateData#state.history))).
        |  
        |  
        |  -spec send_subject(ejabberd:jid(), ejabberd:lang(), state()) -&gt; 'ok'.
        |  send_subject(JID, _Lang, StateData = #state{subject = &lt;&lt;&gt;&gt;, subject_author = &lt;&lt;&gt;&gt;}) -&gt;
<font color=red>     0..|      Packet = #xmlel{name = &lt;&lt;"message"&gt;&gt;,</font>
        |                      attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"groupchat"&gt;&gt;}],
        |                      children = [#xmlel{name = &lt;&lt;"subject"&gt;&gt;},
        |                                 #xmlel{name = &lt;&lt;"body"&gt;&gt;}]},
<font color=red>     0..|      ejabberd_router:route(</font>
        |          StateData#state.jid,
        |          JID,
        |          Packet);
        |  send_subject(JID, _Lang, StateData) -&gt;
<font color=red>     0..|      Subject = StateData#state.subject,</font>
<font color=red>     0..|      Packet = #xmlel{name = &lt;&lt;"message"&gt;&gt;,</font>
        |                      attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"groupchat"&gt;&gt;}],
        |                      children = [#xmlel{name = &lt;&lt;"subject"&gt;&gt;,
        |                                         children = [#xmlcdata{content = Subject}]},
        |                                 #xmlel{name = &lt;&lt;"body"&gt;&gt;}]},
<font color=red>     0..|      ejabberd_router:route(</font>
        |          StateData#state.jid,
        |          JID,
        |          Packet).
        |  
        |  
        |  -spec check_subject(jlib:xmlel()) -&gt; 'false' | binary().
        |  check_subject(Packet) -&gt;
<font color=red>     0..|      case xml:get_subtag(Packet, &lt;&lt;"subject"&gt;&gt;) of</font>
        |          false -&gt;
<font color=red>     0..|              false;</font>
        |          SubjEl -&gt;
<font color=red>     0..|              xml:get_tag_cdata(SubjEl)</font>
        |      end.
        |  
        |  
        |  -spec can_change_subject(mod_muc:role(), state()) -&gt; boolean().
        |  can_change_subject(Role, StateData) -&gt;
<font color=red>     0..|      case (StateData#state.config)#config.allow_change_subj of</font>
        |          true -&gt;
<font color=red>     0..|              (Role == moderator) orelse (Role == participant);</font>
        |          _ -&gt;
<font color=red>     0..|              Role == moderator</font>
        |      end.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  % Admin stuff
        |  
        |  -spec process_iq_admin(ejabberd:jid(), get | set, ejabberd:lang(), jlib:xmlel(), state()) -&gt;
        |      state() | {error, jlib:xmlel()}.
        |  process_iq_admin(From, set, Lang, SubEl, StateData) -&gt;
<font color=red>     0..|      #xmlel{children = Items} = SubEl,</font>
<font color=red>     0..|      process_admin_items_set(From, Items, Lang, StateData);</font>
        |  process_iq_admin(From, get, Lang, SubEl, StateData) -&gt;
<font color=red>     0..|      case xml:get_subtag(SubEl, &lt;&lt;"item"&gt;&gt;) of</font>
        |      false -&gt;
<font color=red>     0..|          {error, ?ERR_BAD_REQUEST};</font>
        |      Item -&gt;
<font color=red>     0..|          FAffiliation = get_affiliation(From, StateData),</font>
<font color=red>     0..|          FRole = get_role(From, StateData),</font>
<font color=red>     0..|          case xml:get_tag_attr(&lt;&lt;"role"&gt;&gt;, Item) of</font>
        |          false -&gt;
<font color=red>     0..|              case xml:get_tag_attr(&lt;&lt;"affiliation"&gt;&gt;, Item) of</font>
        |              false -&gt;
<font color=red>     0..|                  {error, ?ERR_BAD_REQUEST};</font>
        |              {value, BAffiliation} -&gt;
<font color=red>     0..|                  case catch binary_to_affiliation(BAffiliation) of</font>
        |                  {'EXIT', _} -&gt;
<font color=red>     0..|                      {error, ?ERR_BAD_REQUEST};</font>
        |                  Affiliation -&gt;
<font color=red>     0..|                      case iq_admin_allowed(get, affiliation, FAffiliation, FRole, StateData) of</font>
        |                      true -&gt;
<font color=red>     0..|                          Items = items_with_affiliation(</font>
        |                                Affiliation, StateData),
<font color=red>     0..|                          {result, Items, StateData};</font>
        |                      _ -&gt;
<font color=red>     0..|                          ErrText = &lt;&lt;"Administrator privileges required"&gt;&gt;,</font>
<font color=red>     0..|                          {error, ?ERRT_FORBIDDEN(Lang, ErrText)}</font>
        |                      end
        |                  end
        |              end;
        |          {value, BRole} -&gt;
<font color=red>     0..|              case catch binary_to_role(BRole) of</font>
        |              {'EXIT', _} -&gt;
<font color=red>     0..|                  {error, ?ERR_BAD_REQUEST};</font>
        |              Role -&gt;
<font color=red>     0..|                  case iq_admin_allowed(get, role, FAffiliation, FRole, StateData) of</font>
        |                  true -&gt;
<font color=red>     0..|                      Items = items_with_role(Role, StateData),</font>
<font color=red>     0..|                      {result, Items, StateData};</font>
        |                  _ -&gt;
<font color=red>     0..|                      ErrText = &lt;&lt;"Moderator privileges required"&gt;&gt;,</font>
<font color=red>     0..|                      {error, ?ERRT_FORBIDDEN(Lang, ErrText)}</font>
        |                  end
        |              end
        |          end
        |      end.
        |  
        |  -spec iq_admin_allowed(atom(), atom(), atom(), atom(), state()) -&gt; boolean().
        |  iq_admin_allowed(get, What, FAff, none, State) -&gt;
        |      %% no role is translated to 'visitor'
<font color=red>     0..|      iq_admin_allowed(get, What, FAff, visitor, State);</font>
        |  iq_admin_allowed(get, role, _, moderator, _) -&gt;
        |      %% moderator is allowed by definition, needs it to do his duty
<font color=red>     0..|      true;</font>
        |  iq_admin_allowed(get, role, _, Role, State) -&gt;
<font color=red>     0..|      Cfg = State#state.config,</font>
<font color=red>     0..|      lists:member(Role, Cfg#config.maygetmemberlist);</font>
        |  iq_admin_allowed(get, affiliation, owner, _, _) -&gt;
<font color=red>     0..|      true;</font>
        |  iq_admin_allowed(get, affiliation, admin, _, _) -&gt;
<font color=red>     0..|      true;</font>
        |  iq_admin_allowed(get, affiliation, _, Role, State) -&gt;
<font color=red>     0..|      Cfg = State#state.config,</font>
<font color=red>     0..|      lists:member(Role, Cfg#config.maygetmemberlist);</font>
        |  iq_admin_allowed(_, _, _, _, _) -&gt;
<font color=red>     0..|      false.</font>
        |  
        |  
        |  -spec items_with_role(mod_muc:role(), state()) -&gt; [jlib:xmlel()].
        |  items_with_role(BRole, StateData) -&gt;
<font color=red>     0..|      lists:map(</font>
        |        fun({_, U}) -&gt;
<font color=red>     0..|            user_to_item(U, StateData)</font>
        |        end, search_role(BRole, StateData)).
        |  
        |  
        |  -spec items_with_affiliation(mod_muc:affiliation(), state()) -&gt; [jlib:xmlel()].
        |  items_with_affiliation(BAffiliation, StateData) -&gt;
<font color=red>     0..|      lists:map(</font>
        |        fun({JID, {Affiliation, Reason}}) -&gt;
<font color=red>     0..|            #xmlel{name = &lt;&lt;"item"&gt;&gt;,</font>
        |                   attrs = [{&lt;&lt;"affiliation"&gt;&gt;, affiliation_to_binary(Affiliation)},
        |                        {&lt;&lt;"jid"&gt;&gt;, jid:to_binary(JID)}],
        |                   children = [#xmlel{name = &lt;&lt;"reason"&gt;&gt;,
        |                                      children = [#xmlcdata{content = Reason}]}]};
        |           ({JID, Affiliation}) -&gt;
<font color=red>     0..|                #xmlel{name = &lt;&lt;"item"&gt;&gt;,</font>
        |                       attrs = [{&lt;&lt;"affiliation"&gt;&gt;, affiliation_to_binary(Affiliation)},
        |                            {&lt;&lt;"jid"&gt;&gt;, jid:to_binary(JID)}]}
        |        end, search_affiliation(BAffiliation, StateData)).
        |  
        |  
        |  -spec user_to_item(user(), state()) -&gt; jlib:xmlel().
        |  user_to_item(#user{role = Role,
        |             nick = Nick,
        |             jid = JID
        |            }, StateData) -&gt;
<font color=red>     0..|      Affiliation = get_affiliation(JID, StateData),</font>
<font color=red>     0..|      #xmlel{name = &lt;&lt;"item"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"role"&gt;&gt;, role_to_binary(Role)},
        |                      {&lt;&lt;"affiliation"&gt;&gt;, affiliation_to_binary(Affiliation)},
        |                      {&lt;&lt;"nick"&gt;&gt;, Nick},
        |                      {&lt;&lt;"jid"&gt;&gt;, jid:to_binary(JID)}]}.
        |  
        |  
        |  -spec search_role(mod_muc:role(), state()) -&gt; [{_,_}].
        |  search_role(Role, StateData) -&gt;
<font color=red>     0..|      lists:filter(</font>
        |        fun({_, #user{role = R}}) -&gt;
<font color=red>     0..|            Role == R</font>
        |        end, ?DICT:to_list(StateData#state.users)).
        |  
        |  
        |  -spec search_affiliation(mod_muc:affiliation(), state()) -&gt; [{_,_}].
        |  search_affiliation(Affiliation, StateData) when is_atom(Affiliation) -&gt;
<font color=red>     0..|      lists:filter(</font>
        |        fun({_, A}) -&gt;
<font color=red>     0..|            case A of</font>
        |            {A1, _Reason} -&gt;
<font color=red>     0..|                Affiliation == A1;</font>
        |            _ -&gt;
<font color=red>     0..|                Affiliation == A</font>
        |            end
        |        end, ?DICT:to_list(StateData#state.affiliations)).
        |  
        |  
        |  -spec process_admin_items_set(ejabberd:jid(), [jlib:xmlel(),...], ejabberd:lang(),
        |                          state()) -&gt; {'error', jlib:xmlel()} | {'result',[],state()}.
        |  process_admin_items_set(UJID, Items, Lang, StateData) -&gt;
<font color=red>     0..|      UAffiliation = get_affiliation(UJID, StateData),</font>
<font color=red>     0..|      URole = get_role(UJID, StateData),</font>
<font color=red>     0..|      case find_changed_items(UJID, UAffiliation, URole, Items, Lang, StateData, []) of</font>
        |      {result, Res} -&gt;
<font color=red>     0..|          ?INFO_MSG("Processing MUC admin query from ~s in room ~s:~n ~p",</font>
        |                [jid:to_binary(UJID), jid:to_binary(StateData#state.jid), Res]),
<font color=red>     0..|          NSD =</font>
        |          lists:foldl(
        |            fun(E, SD) -&gt;
<font color=red>     0..|                case catch</font>
        |                   (case E of
        |                        {JID, affiliation, owner, _}
        |                        when (JID#jid.luser == &lt;&lt;&gt;&gt;) -&gt;
        |                        %% If the provided JID does not have username,
        |                        %% forget the affiliation completely
<font color=red>     0..|                        SD;</font>
        |                        {JID, role, none, Reason} -&gt;
<font color=red>     0..|                        catch send_kickban_presence(</font>
        |                            JID, Reason, &lt;&lt;"307"&gt;&gt;, SD),
<font color=red>     0..|                        set_role(JID, none, SD);</font>
        |                        {JID, affiliation, none, Reason} -&gt;
<font color=red>     0..|                        case  (SD#state.config)#config.members_only of</font>
        |                            true -&gt;
<font color=red>     0..|                            catch send_kickban_presence(</font>
        |                                JID, Reason, &lt;&lt;"321"&gt;&gt;, none, SD),
<font color=red>     0..|                            SD1 = set_affiliation_and_reason(JID, none, Reason, SD),</font>
<font color=red>     0..|                            set_role(JID, none, SD1);</font>
        |                            _ -&gt;
<font color=red>     0..|                            SD1 = set_affiliation_and_reason(JID, none, Reason, SD),</font>
<font color=red>     0..|                            send_update_presence(JID, Reason, SD1),</font>
<font color=red>     0..|                            SD1</font>
        |                        end;
        |                        {JID, affiliation, outcast, Reason} -&gt;
<font color=red>     0..|                        catch send_kickban_presence(</font>
        |                            JID, Reason, &lt;&lt;"301"&gt;&gt;, outcast, SD),
<font color=red>     0..|                        set_affiliation_and_reason(</font>
        |                          JID, outcast, Reason,
        |                          set_role(JID, none, SD));
        |                        {JID, affiliation, A, Reason} when
        |                           (A == admin) or (A == owner) -&gt;
<font color=red>     0..|                        SD1 = set_affiliation_and_reason(JID, A, Reason, SD),</font>
<font color=red>     0..|                        SD2 = set_role(JID, moderator, SD1),</font>
<font color=red>     0..|                        send_update_presence(JID, Reason, SD2),</font>
<font color=red>     0..|                        SD2;</font>
        |                        {JID, affiliation, member, Reason} -&gt;
<font color=red>     0..|                           case  (SD#state.config)#config.members_only of</font>
<font color=red>     0..|                               true -&gt; send_invitation(UJID, JID, Reason, SD);</font>
<font color=red>     0..|                               _ -&gt; ok</font>
        |                           end,
<font color=red>     0..|                           SD1 = set_affiliation_and_reason(</font>
        |                               JID, member, Reason, SD),
<font color=red>     0..|                           SD2 = set_role(JID, participant, SD1),</font>
<font color=red>     0..|                           send_update_presence(JID, Reason, SD2),</font>
<font color=red>     0..|                           SD2;</font>
        |                       {JID, role, Role, Reason} -&gt;
<font color=red>     0..|                       SD1 = set_role(JID, Role, SD),</font>
<font color=red>     0..|                       catch send_new_presence(JID, Reason, SD1),</font>
<font color=red>     0..|                       SD1;</font>
        |                       {JID, affiliation, A, Reason} -&gt;
<font color=red>     0..|                       SD1 = set_affiliation(JID, A, SD),</font>
<font color=red>     0..|                       send_update_presence(JID, Reason, SD1),</font>
<font color=red>     0..|                       SD1</font>
        |                    end)
        |                    of
        |                    {'EXIT', ErrReason} -&gt;
<font color=red>     0..|                    ?ERROR_MSG("MUC ITEMS SET ERR: ~p~n",</font>
        |                           [ErrReason]),
<font color=red>     0..|                    SD;</font>
        |                    NSD -&gt;
<font color=red>     0..|                    NSD</font>
        |                end
        |            end, StateData, Res),
<font color=red>     0..|          case (NSD#state.config)#config.persistent of</font>
        |          true -&gt;
<font color=red>     0..|              mod_muc:store_room(NSD#state.host, NSD#state.room,</font>
        |                         make_opts(NSD));
        |          _ -&gt;
<font color=red>     0..|              ok</font>
        |          end,
<font color=red>     0..|          {result, [], NSD};</font>
        |      Err -&gt;
<font color=red>     0..|          Err</font>
        |      end.
        |  
        |  
        |  -type res_row() :: {ejabberd:simple_jid() | ejabberd:jid(),
        |                      'affiliation' | 'role', any(), any()}.
        |  -spec find_changed_items(ejabberd:jid(), mod_muc:affiliation(), mod_muc:role(),
        |          [jlib:xmlel()], ejabberd:lang(), state(), [res_row()])
        |              -&gt; {'error', jlib:xmlel()} | {'result',[res_row()]}.
        |  find_changed_items(_UJID, _UAffiliation, _URole, [], _Lang, _StateData, Res) -&gt;
<font color=red>     0..|      {result, Res};</font>
        |  find_changed_items(UJID, UAffiliation, URole, [#xmlcdata{} | Items],
        |             Lang, StateData, Res) -&gt;
<font color=red>     0..|      find_changed_items(UJID, UAffiliation, URole, Items, Lang, StateData, Res);</font>
        |  find_changed_items(UJID, UAffiliation, URole,
        |             [#xmlel{name = &lt;&lt;"item"&gt;&gt;, attrs = Attrs} = Item | Items],
        |             Lang, StateData, Res) -&gt;
<font color=red>     0..|      TJID = case xml:get_attr(&lt;&lt;"jid"&gt;&gt;, Attrs) of</font>
        |             {value, S} -&gt;
<font color=red>     0..|             case jid:from_binary(S) of</font>
        |                 error -&gt;
<font color=red>     0..|                 ErrText = &lt;&lt;(translate:translate(Lang, &lt;&lt;"Jabber ID "&gt;&gt;))/binary,</font>
        |                    S/binary, (translate:translate(Lang, &lt;&lt;" is invalid"&gt;&gt;))/binary&gt;&gt;,
<font color=red>     0..|                 {error, ?ERRT_NOT_ACCEPTABLE(Lang, ErrText)};</font>
        |                 J -&gt;
<font color=red>     0..|                 {value, J}</font>
        |             end;
        |             _ -&gt;
<font color=red>     0..|             case xml:get_attr(&lt;&lt;"nick"&gt;&gt;, Attrs) of</font>
        |                 {value, N} -&gt;
<font color=red>     0..|                 case find_jids_by_nick(N, StateData) of</font>
        |                     [] -&gt;
<font color=red>     0..|                     ErrText = &lt;&lt;(translate:translate(Lang, &lt;&lt;"Nickname "&gt;&gt;))/binary,</font>
        |                        N/binary, (translate:translate(Lang, &lt;&lt;" does not exist in the room"&gt;&gt;))/binary&gt;&gt;,
<font color=red>     0..|                     {error, ?ERRT_NOT_ACCEPTABLE(Lang, ErrText)};</font>
        |                     [FirstSessionJid | _RestOfSessions] -&gt;
<font color=red>     0..|                     {value, FirstSessionJid}</font>
        |                 end;
        |                 _ -&gt;
<font color=red>     0..|                 {error, ?ERR_BAD_REQUEST}</font>
        |             end
        |         end,
<font color=red>     0..|      case TJID of</font>
        |      {value, JID} -&gt;
<font color=red>     0..|          TAffiliation = get_affiliation(JID, StateData),</font>
<font color=red>     0..|          TRole = get_role(JID, StateData),</font>
<font color=red>     0..|          case xml:get_attr(&lt;&lt;"role"&gt;&gt;, Attrs) of</font>
        |          false -&gt;
<font color=red>     0..|              case xml:get_attr(&lt;&lt;"affiliation"&gt;&gt;, Attrs) of</font>
        |              false -&gt;
<font color=red>     0..|                  {error, ?ERR_BAD_REQUEST};</font>
        |              {value, BAffiliation} -&gt;
<font color=red>     0..|                  case catch binary_to_affiliation(BAffiliation) of</font>
        |                  {'EXIT', _} -&gt;
<font color=red>     0..|                      ErrText1 = &lt;&lt;(translate:translate(Lang, &lt;&lt;"Invalid affiliation "&gt;&gt;))/binary,</font>
        |                          BAffiliation/binary&gt;&gt;,
<font color=red>     0..|                      {error, ?ERRT_NOT_ACCEPTABLE(Lang, ErrText1)};</font>
        |                  Affiliation -&gt;
<font color=red>     0..|                      ServiceAf = get_service_affiliation(JID, StateData),</font>
<font color=red>     0..|                      CanChangeRA =</font>
        |                      case can_change_ra(
        |                             UAffiliation, URole,
        |                             TAffiliation, TRole,
        |                             affiliation, Affiliation,
        |                             ServiceAf) of
        |                          nothing -&gt;
<font color=red>     0..|                          nothing;</font>
        |                          true -&gt;
<font color=red>     0..|                          true;</font>
        |                          cancel -&gt;
<font color=red>     0..|                          cancel;</font>
        |                          check_owner -&gt;
<font color=red>     0..|                          case search_affiliation(owner, StateData) of</font>
        |                              [{OJID, _}] -&gt;
<font color=red>     0..|                              jid:to_bare(OJID) /=</font>
        |                                  jid:to_lower(jid:to_bare(UJID));
        |                              _ -&gt;
<font color=red>     0..|                              true</font>
        |                          end;
        |                          _ -&gt;
<font color=red>     0..|                          false</font>
        |                      end,
<font color=red>     0..|                      case CanChangeRA of</font>
        |                      nothing -&gt;
<font color=red>     0..|                          find_changed_items(</font>
        |                            UJID,
        |                            UAffiliation, URole,
        |                            Items, Lang, StateData,
        |                            Res);
        |                      true -&gt;
<font color=red>     0..|                          find_changed_items(</font>
        |                            UJID,
        |                            UAffiliation, URole,
        |                            Items, Lang, StateData,
        |                            [{jid:to_bare(JID),
        |                          affiliation, Affiliation, decode_reason(Item)} | Res]);
        |                      cancel -&gt;
<font color=red>     0..|                          {error, ?ERR_NOT_ALLOWED};</font>
        |                      false -&gt;
<font color=red>     0..|                          {error, ?ERR_FORBIDDEN}</font>
        |                      end
        |                  end
        |              end;
        |          {value, BRole} -&gt;
<font color=red>     0..|              case catch binary_to_role(BRole) of</font>
        |              {'EXIT', _} -&gt;
<font color=red>     0..|                  ErrText1 = &lt;&lt;(translate:translate(Lang, &lt;&lt;"Invalid role "&gt;&gt;))/binary,</font>
        |                      BRole/binary&gt;&gt;,
<font color=red>     0..|                  {error, ?ERRT_BAD_REQUEST(Lang, ErrText1)};</font>
        |              Role -&gt;
<font color=red>     0..|                  ServiceAf = get_service_affiliation(JID, StateData),</font>
<font color=red>     0..|                  CanChangeRA =</font>
        |                  case can_change_ra(
        |                         UAffiliation, URole,
        |                         TAffiliation, TRole,
        |                         role, Role,
        |                         ServiceAf) of
        |                      nothing -&gt;
<font color=red>     0..|                      nothing;</font>
        |                      true -&gt;
<font color=red>     0..|                      true;</font>
        |                      check_owner -&gt;
<font color=red>     0..|                      case search_affiliation(owner, StateData) of</font>
        |                          [{OJID, _}] -&gt;
<font color=red>     0..|                          jid:to_bare(OJID) /=</font>
        |                              jid:to_lower(jid:to_bare(UJID));
        |                          _ -&gt;
<font color=red>     0..|                          true</font>
        |                      end;
        |                      _ -&gt;
<font color=red>     0..|                      false</font>
        |                  end,
<font color=red>     0..|                  case CanChangeRA of</font>
        |                  nothing -&gt;
<font color=red>     0..|                      find_changed_items(</font>
        |                        UJID,
        |                        UAffiliation, URole,
        |                        Items, Lang, StateData,
        |                        Res);
        |                  true -&gt;
<font color=red>     0..|                      find_changed_items(</font>
        |                        UJID,
        |                        UAffiliation, URole,
        |                        Items, Lang, StateData,
        |                        [{JID, role, Role, decode_reason(Item)} | Res]);
        |                  _ -&gt;
<font color=red>     0..|                      {error, ?ERR_NOT_ALLOWED}</font>
        |                  end
        |              end
        |          end;
        |      Err -&gt;
<font color=red>     0..|          Err</font>
        |      end;
        |  find_changed_items(_UJID, _UAffiliation, _URole, _Items,
        |             _Lang, _StateData, _Res) -&gt;
<font color=red>     0..|      {error, ?ERR_BAD_REQUEST}.</font>
        |  
        |  
        |  -spec can_change_ra(FAff :: mod_muc:affiliation(), FRole :: mod_muc:role(),
        |          TAff :: mod_muc:affiliation(), TRole :: mod_muc:role(),
        |          RoleOrAff :: 'affiliation' | 'role', Value :: any(),
        |          ServiceAff :: mod_muc:affiliation())
        |              -&gt; 'cancel' | 'check_owner' | 'false' | 'nothing' | 'true'.
        |  can_change_ra(_FAffiliation, _FRole,
        |            owner, _TRole,
        |            affiliation, owner, owner) -&gt;
        |      %% A room owner tries to add as persistent owner a
        |      %% participant that is already owner because he is MUC admin
<font color=red>     0..|      true;</font>
        |  can_change_ra(_FAffiliation, _FRole,
        |                _TAffiliation, _TRole,
        |                _RoleorAffiliation, _Value, owner) -&gt;
        |      %% Nobody can decrease MUC admin's role/affiliation
<font color=red>     0..|      false;</font>
        |  can_change_ra(_FAffiliation, _FRole,
        |            TAffiliation, _TRole,
        |            affiliation, Value, _ServiceAf)
        |    when (TAffiliation == Value) -&gt;
<font color=red>     0..|      nothing;</font>
        |  can_change_ra(_FAffiliation, _FRole,
        |            _TAffiliation, TRole,
        |            role, Value, _ServiceAf)
        |    when (TRole == Value) -&gt;
<font color=red>     0..|      nothing;</font>
        |  can_change_ra(FAffiliation, _FRole,
        |            outcast, _TRole,
        |            affiliation, none, _ServiceAf)
        |    when (FAffiliation == owner) or (FAffiliation == admin) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(FAffiliation, _FRole,
        |            outcast, _TRole,
        |            affiliation, member, _ServiceAf)
        |    when (FAffiliation == owner) or (FAffiliation == admin) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(owner, _FRole,
        |            outcast, _TRole,
        |            affiliation, admin, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(owner, _FRole,
        |            outcast, _TRole,
        |            affiliation, owner, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(FAffiliation, _FRole,
        |            none, _TRole,
        |            affiliation, outcast, _ServiceAf)
        |    when (FAffiliation == owner) or (FAffiliation == admin) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(FAffiliation, _FRole,
        |            none, _TRole,
        |            affiliation, member, _ServiceAf)
        |    when (FAffiliation == owner) or (FAffiliation == admin) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(owner, _FRole,
        |            none, _TRole,
        |            affiliation, admin, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(owner, _FRole,
        |            none, _TRole,
        |            affiliation, owner, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(FAffiliation, _FRole,
        |            member, _TRole,
        |            affiliation, outcast, _ServiceAf)
        |    when (FAffiliation == owner) or (FAffiliation == admin) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(FAffiliation, _FRole,
        |            member, _TRole,
        |            affiliation, none, _ServiceAf)
        |    when (FAffiliation == owner) or (FAffiliation == admin) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(owner, _FRole,
        |            member, _TRole,
        |            affiliation, admin, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(owner, _FRole,
        |            member, _TRole,
        |            affiliation, owner, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(owner, _FRole,
        |            admin, _TRole,
        |            affiliation, _Affiliation, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(owner, _FRole,
        |            owner, _TRole,
        |            affiliation, _Affiliation, _ServiceAf) -&gt;
<font color=red>     0..|      check_owner;</font>
        |  can_change_ra(none, _FRole,
        |                TAffiliation, _TRole,
        |                affiliation, _Affiliation, _ServiceAf)
        |      when (TAffiliation == admin orelse TAffiliation == owner) -&gt;
<font color=red>     0..|      cancel;</font>
        |  can_change_ra(admin, _FRole,
        |                owner, _TRole,
        |                affiliation, _Value, _ServiceAf) -&gt;
<font color=red>     0..|      cancel;</font>
        |  can_change_ra(_FAffiliation, _FRole,
        |            _TAffiliation, _TRole,
        |            affiliation, _Value, _ServiceAf) -&gt;
<font color=red>     0..|      false;</font>
        |  can_change_ra(_FAffiliation, moderator,
        |            _TAffiliation, visitor,
        |            role, none, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(_FAffiliation, moderator,
        |            _TAffiliation, visitor,
        |            role, participant, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(FAffiliation, _FRole,
        |            _TAffiliation, visitor,
        |            role, moderator, _ServiceAf)
        |    when (FAffiliation == owner) or (FAffiliation == admin) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(_FAffiliation, moderator,
        |            _TAffiliation, participant,
        |            role, none, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(_FAffiliation, moderator,
        |            _TAffiliation, participant,
        |            role, visitor, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(FAffiliation, _FRole,
        |            _TAffiliation, participant,
        |            role, moderator, _ServiceAf)
        |    when (FAffiliation == owner) or (FAffiliation == admin) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(_FAffiliation, _FRole,
        |            owner, moderator,
        |            role, visitor, _ServiceAf) -&gt;
<font color=red>     0..|      false;</font>
        |  can_change_ra(owner, _FRole,
        |            _TAffiliation, moderator,
        |            role, visitor, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(_FAffiliation, _FRole,
        |            admin, moderator,
        |            role, visitor, _ServiceAf) -&gt;
<font color=red>     0..|      false;</font>
        |  can_change_ra(admin, _FRole,
        |            _TAffiliation, moderator,
        |            role, visitor, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(_FAffiliation, _FRole,
        |            owner, moderator,
        |            role, participant, _ServiceAf) -&gt;
<font color=red>     0..|      false;</font>
        |  can_change_ra(owner, _FRole,
        |            _TAffiliation, moderator,
        |            role, participant, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(_FAffiliation, _FRole,
        |            admin, moderator,
        |            role, participant, _ServiceAf) -&gt;
<font color=red>     0..|      false;</font>
        |  can_change_ra(admin, _FRole,
        |            _TAffiliation, moderator,
        |            role, participant, _ServiceAf) -&gt;
<font color=red>     0..|      true;</font>
        |  can_change_ra(_FAffiliation, _FRole,
        |            _TAffiliation, _TRole,
        |            role, _Value, _ServiceAf) -&gt;
<font color=red>     0..|      false.</font>
        |  
        |  
        |  -spec send_kickban_presence(ejabberd:jid(), binary(), Code :: binary(),
        |                              state()) -&gt; any().
        |  send_kickban_presence(JID, Reason, Code, StateData) -&gt;
<font color=red>     0..|      NewAffiliation = get_affiliation(JID, StateData),</font>
<font color=red>     0..|      send_kickban_presence(JID, Reason, Code, NewAffiliation, StateData).</font>
        |  
        |  
        |  -spec send_kickban_presence(ejabberd:simple_jid() | ejabberd:jid(),
        |                              Reason :: binary(), Code :: binary(),
        |                              mod_muc:affiliation(), state()) -&gt; any().
        |  send_kickban_presence(JID, Reason, Code, NewAffiliation, StateData) -&gt;
<font color=red>     0..|      foreach_matched_user(fun(#user{nick = Nick, jid = J}) -&gt;</font>
<font color=red>     0..|        add_to_log(kickban, {Nick, Reason, Code}, StateData),</font>
<font color=red>     0..|        tab_remove_online_user(J, StateData),</font>
<font color=red>     0..|        send_kickban_presence1(J, Reason, Code, NewAffiliation, StateData)</font>
        |      end, JID, StateData).
        |  
        |  
        |  -spec send_kickban_presence1(ejabberd:jid(), Reason :: binary(), Code :: binary(),
        |                               mod_muc:affiliation(), state()) -&gt; 'ok'.
        |  send_kickban_presence1(UJID, Reason, Code, Affiliation, StateData) -&gt;
        |      {ok, #user{jid = RealJID,
<font color=red>     0..|             nick = Nick}} =</font>
        |      ?DICT:find(jid:to_lower(UJID), StateData#state.users),
<font color=red>     0..|      BAffiliation = affiliation_to_binary(Affiliation),</font>
<font color=red>     0..|      BannedJIDString = jid:to_binary(RealJID),</font>
<font color=red>     0..|      lists:foreach(</font>
        |        fun({_LJID, Info}) -&gt;
<font color=red>     0..|            JidAttrList = case (Info#user.role == moderator) orelse</font>
        |                  ((StateData#state.config)#config.anonymous
<font color=red>     0..|                   == false) of</font>
<font color=red>     0..|                  true -&gt; [{&lt;&lt;"jid"&gt;&gt;, BannedJIDString}];</font>
<font color=red>     0..|                  false -&gt; []</font>
        |                  end,
<font color=red>     0..|            ItemAttrs = [{&lt;&lt;"affiliation"&gt;&gt;, BAffiliation},</font>
        |                 {&lt;&lt;"role"&gt;&gt;, &lt;&lt;"none"&gt;&gt;}] ++ JidAttrList,
<font color=red>     0..|            ItemEls = case Reason of</font>
        |                  &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|                  [];</font>
        |                  _ -&gt;
<font color=red>     0..|                  [#xmlel{name = &lt;&lt;"reason"&gt;&gt;, children = [#xmlcdata{content = Reason}]}]</font>
        |                      end,
<font color=red>     0..|            Packet = #xmlel{name = &lt;&lt;"presence"&gt;&gt;,</font>
        |                            attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"unavailable"&gt;&gt;}],
        |                            children = [#xmlel{name = &lt;&lt;"x"&gt;&gt;,
        |                                               attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_USER}],
        |                                               children = [#xmlel{name = &lt;&lt;"item"&gt;&gt;,
        |                                                                  attrs = ItemAttrs,
        |                                                                  children = ItemEls},
        |                                                           #xmlel{name = &lt;&lt;"status"&gt;&gt;,
        |                                                                  attrs = [{&lt;&lt;"code"&gt;&gt;, Code}]}]}]},
<font color=red>     0..|            ejabberd_router:route(</font>
        |          jid:replace_resource(StateData#state.jid, Nick),
        |          Info#user.jid,
        |          Packet)
        |        end, ?DICT:to_list(StateData#state.users)).
        |  
        |  
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  % Owner stuff
        |  
        |  -spec process_iq_owner(ejabberd:jid(), 'get' | 'set', ejabberd:lang(), jlib:xmlel(), state()) -&gt;
        |      {'error', jlib:xmlel()} | {result, [jlib:xmlel() | jlib:xmlcdata()], state() | stop}.
        |  process_iq_owner(From, set, Lang, SubEl, StateData) -&gt;
<font color=red>     0..|      FAffiliation = get_affiliation(From, StateData),</font>
<font color=red>     0..|      case FAffiliation of</font>
        |      owner -&gt;
<font color=red>     0..|          #xmlel{children = Els} = SubEl,</font>
<font color=red>     0..|          case xml:remove_cdata(Els) of</font>
        |          [#xmlel{name = &lt;&lt;"x"&gt;&gt;, children = Els1} = XEl] -&gt;
<font color=red>     0..|              case {xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, XEl),</font>
        |                xml:get_tag_attr_s(&lt;&lt;"type"&gt;&gt;, XEl)} of
        |              {?NS_XDATA, &lt;&lt;"cancel"&gt;&gt;} -&gt;
<font color=red>     0..|                  ?INFO_MSG("Destroyed MUC room ~s by the owner ~s : cancelled",</font>
        |                      [jid:to_binary(StateData#state.jid), jid:to_binary(From)]),
<font color=red>     0..|                  add_to_log(room_existence, destroyed, StateData),</font>
<font color=red>     0..|                  destroy_room(XEl, StateData);</font>
        |              {?NS_XDATA, &lt;&lt;"submit"&gt;&gt;} -&gt;
<font color=red>     0..|                  case Els1 of</font>
        |                  [] -&gt;
        |                      %confrm an instant room
<font color=red>     0..|                      {result, [], StateData};</font>
        |                  _ -&gt;
        |                      %attepmt to configure
<font color=red>     0..|                      case is_allowed_log_change(XEl, StateData, From)</font>
        |                      andalso
<font color=red>     0..|                      is_allowed_persistent_change(XEl, StateData, From)</font>
        |                      andalso
<font color=red>     0..|                      is_allowed_room_name_desc_limits(XEl, StateData)</font>
        |                      andalso
<font color=red>     0..|                      is_password_settings_correct(XEl, StateData) of</font>
<font color=red>     0..|                      true -&gt; set_config(XEl, StateData);</font>
<font color=red>     0..|                      false -&gt; {error, ?ERR_NOT_ACCEPTABLE}</font>
        |                      end
        |                  end;
        |              _ -&gt;
<font color=red>     0..|                  {error, ?ERR_BAD_REQUEST}</font>
        |              end;
        |          [#xmlel{name = &lt;&lt;"destroy"&gt;&gt;} = SubEl1] -&gt;
<font color=red>     0..|              ?INFO_MSG("Destroyed MUC room ~s by the owner ~s",</font>
        |                    [jid:to_binary(StateData#state.jid), jid:to_binary(From)]),
<font color=red>     0..|              add_to_log(room_existence, destroyed, StateData),</font>
<font color=red>     0..|              destroy_room(SubEl1, StateData);</font>
        |          Items -&gt;
<font color=red>     0..|              process_admin_items_set(From, Items, Lang, StateData)</font>
        |          end;
        |      _ -&gt;
<font color=red>     0..|          ErrText = &lt;&lt;"Owner privileges required"&gt;&gt;,</font>
<font color=red>     0..|          {error, ?ERRT_FORBIDDEN(Lang, ErrText)}</font>
        |      end;
        |  process_iq_owner(From, get, Lang, SubEl, StateData) -&gt;
<font color=red>     0..|      FAffiliation = get_affiliation(From, StateData),</font>
<font color=red>     0..|      case FAffiliation of</font>
        |      owner -&gt;
<font color=red>     0..|          #xmlel{children = Els} = SubEl,</font>
<font color=red>     0..|          case xml:remove_cdata(Els) of</font>
        |          [] -&gt;
<font color=red>     0..|              get_config(Lang, StateData, From);</font>
        |          [Item] -&gt;
<font color=red>     0..|              case xml:get_tag_attr(&lt;&lt;"affiliation"&gt;&gt;, Item) of</font>
        |              false -&gt;
<font color=red>     0..|                  {error, ?ERR_BAD_REQUEST};</font>
        |              {value, BAffiliation} -&gt;
<font color=red>     0..|                  case catch binary_to_affiliation(BAffiliation) of</font>
        |                  {'EXIT', _} -&gt;
<font color=red>     0..|                      ErrText = &lt;&lt;(translate:translate(Lang, &lt;&lt;"Invalid affiliation "&gt;&gt;))/binary,</font>
        |                          BAffiliation/binary&gt;&gt;,
<font color=red>     0..|                      {error, ?ERRT_NOT_ACCEPTABLE(Lang, ErrText)};</font>
        |                  Affiliation -&gt;
<font color=red>     0..|                      Items = items_with_affiliation(Affiliation, StateData),</font>
<font color=red>     0..|                      {result, Items, StateData}</font>
        |                  end
        |              end;
        |          _ -&gt;
<font color=red>     0..|              {error, ?ERR_FEATURE_NOT_IMPLEMENTED}</font>
        |          end;
        |      _ -&gt;
<font color=red>     0..|          ErrText = &lt;&lt;"Owner privileges required"&gt;&gt;,</font>
<font color=red>     0..|          {error, ?ERRT_FORBIDDEN(Lang, ErrText)}</font>
        |      end.
        |  
        |  
        |  -spec is_allowed_log_change(jlib:xmlel(), state(), ejabberd:jid()) -&gt; boolean().
        |  is_allowed_log_change(XEl, StateData, From) -&gt;
<font color=red>     0..|      case lists:keymember(&lt;&lt;"muc#roomconfig_enablelogging"&gt;&gt;, 1,</font>
        |               jlib:parse_xdata_submit(XEl)) of
        |      false -&gt;
<font color=red>     0..|          true;</font>
        |      true -&gt;
<font color=red>     0..|          (allow == mod_muc_log:check_access_log(</font>
        |            StateData#state.server_host, From))
        |      end.
        |  
        |  
        |  -spec is_allowed_persistent_change(jlib:xmlel(), state(), ejabberd:jid()) -&gt; boolean().
        |  is_allowed_persistent_change(XEl, StateData, From) -&gt;
<font color=red>     0..|      case lists:keymember(&lt;&lt;"muc#roomconfig_persistentroom"&gt;&gt;, 1,</font>
        |               jlib:parse_xdata_submit(XEl)) of
        |      false -&gt;
<font color=red>     0..|          true;</font>
        |      true -&gt;
<font color=red>     0..|          AccessPersistent = access_persistent(StateData),</font>
<font color=red>     0..|          (allow == acl:match_rule(StateData#state.server_host, AccessPersistent, From))</font>
        |      end.
        |  
        |  
        |  %% @doc Check if the Room Name and Room Description defined in the Data Form
        |  %% are conformant to the configured limits
        |  -spec is_allowed_room_name_desc_limits(jlib:xmlel(), state()) -&gt; boolean().
        |  is_allowed_room_name_desc_limits(XEl, StateData) -&gt;
<font color=red>     0..|      IsNameAccepted =</font>
        |      case lists:keysearch(&lt;&lt;"muc#roomconfig_roomname"&gt;&gt;, 1,
        |                   jlib:parse_xdata_submit(XEl)) of
        |          {value, {_, [N]}} -&gt;
<font color=red>     0..|          byte_size(N) =&lt; gen_mod:get_module_opt(StateData#state.server_host,</font>
        |                              mod_muc, max_room_name,
        |                              infinite);
        |          _ -&gt;
<font color=red>     0..|          true</font>
        |      end,
<font color=red>     0..|      IsDescAccepted =</font>
        |      case lists:keysearch(&lt;&lt;"muc#roomconfig_roomdesc"&gt;&gt;, 1,
        |                   jlib:parse_xdata_submit(XEl)) of
        |          {value, {_, [D]}} -&gt;
<font color=red>     0..|          byte_size(D) =&lt; gen_mod:get_module_opt(StateData#state.server_host,</font>
        |                              mod_muc, max_room_desc,
        |                              infinite);
        |          _ -&gt;
<font color=red>     0..|          true</font>
        |      end,
<font color=red>     0..|      IsNameAccepted and IsDescAccepted.</font>
        |  
        |  %% @doc Return false if:
        |  %% &lt;&lt;"the password for a password-protected room is blank"&gt;&gt;
        |  -spec is_password_settings_correct(jlib:xmlel(), state()) -&gt; boolean().
        |  is_password_settings_correct(XEl, StateData) -&gt;
<font color=red>     0..|      Config = StateData#state.config,</font>
<font color=red>     0..|      OldProtected = Config#config.password_protected,</font>
<font color=red>     0..|      OldPassword = Config#config.password,</font>
<font color=red>     0..|      NewProtected =</font>
        |      case lists:keysearch(&lt;&lt;"muc#roomconfig_passwordprotectedroom"&gt;&gt;, 1,
        |                   jlib:parse_xdata_submit(XEl)) of
        |          {value, {_, [&lt;&lt;"1"&gt;&gt;]}} -&gt;
<font color=red>     0..|          true;</font>
        |          {value, {_, [&lt;&lt;"0"&gt;&gt;]}} -&gt;
<font color=red>     0..|          false;</font>
        |          _ -&gt;
<font color=red>     0..|          undefined</font>
        |      end,
<font color=red>     0..|      NewPassword =</font>
        |      case lists:keysearch(&lt;&lt;"muc#roomconfig_roomsecret"&gt;&gt;, 1,
        |                   jlib:parse_xdata_submit(XEl)) of
        |          {value, {_, [P]}} -&gt;
<font color=red>     0..|          P;</font>
        |          _ -&gt;
<font color=red>     0..|          undefined</font>
        |      end,
<font color=red>     0..|      case {OldProtected, NewProtected, OldPassword, NewPassword} of</font>
        |      {true, undefined, &lt;&lt;&gt;&gt;, undefined} -&gt;
<font color=red>     0..|          false;</font>
        |      {true, undefined, _, &lt;&lt;&gt;&gt;} -&gt;
<font color=red>     0..|          false;</font>
        |      {_, true , &lt;&lt;&gt;&gt;, undefined} -&gt;
<font color=red>     0..|          false;</font>
        |      {_, true, _, &lt;&lt;&gt;&gt;} -&gt;
<font color=red>     0..|          false;</font>
        |      _ -&gt;
<font color=red>     0..|          true</font>
        |      end.
        |  
        |  
        |  -spec get_default_room_maxusers(state()) -&gt; any().
        |  get_default_room_maxusers(RoomState) -&gt;
<font color=red>     0..|      DefRoomOpts = gen_mod:get_module_opt(RoomState#state.server_host, mod_muc, default_room_options, []),</font>
<font color=red>     0..|      RoomState2 = set_opts(DefRoomOpts, RoomState),</font>
<font color=red>     0..|      (RoomState2#state.config)#config.max_users.</font>
        |  
        |  
        |  -spec get_config(ejabberd:lang(), state(), ejabberd:jid())
        |              -&gt; {'result',[jlib:xmlel(),...], state()}.
        |  get_config(Lang, StateData, From) -&gt;
<font color=red>     0..|      AccessPersistent = access_persistent(StateData),</font>
<font color=red>     0..|      ServiceMaxUsers = get_service_max_users(StateData),</font>
<font color=red>     0..|      DefaultRoomMaxUsers = get_default_room_maxusers(StateData),</font>
<font color=red>     0..|      Config = StateData#state.config,</font>
<font color=red>     0..|      {MaxUsersRoomInteger, MaxUsersRoomString} =</font>
        |      case get_max_users(StateData) of
        |          N when is_integer(N) -&gt;
<font color=red>     0..|          {N, integer_to_binary(N)};</font>
<font color=red>     0..|          _ -&gt; {0, &lt;&lt;"none"&gt;&gt;}</font>
        |      end,
<font color=red>     0..|      Res =</font>
        |      [#xmlel{name = &lt;&lt;"title"&gt;&gt;,
        |              children = [#xmlcdata{content = &lt;&lt;(translate:translate(Lang, &lt;&lt;"Configuration of room "&gt;&gt;))/binary,
        |                                      (jid:to_binary(StateData#state.jid))/binary&gt;&gt;}]},
        |       #xmlel{name = &lt;&lt;"field"&gt;&gt;,
        |              attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"hidden"&gt;&gt;},
        |            {&lt;&lt;"var"&gt;&gt;, &lt;&lt;"FORM_TYPE"&gt;&gt;}],
        |              children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                 children = [#xmlcdata{content = &lt;&lt;"http://jabber.org/protocol/muc#roomconfig"&gt;&gt;}]}]},
        |       stringxfield(&lt;&lt;"Room title"&gt;&gt;,
        |                 &lt;&lt;"muc#roomconfig_roomname"&gt;&gt;,
        |                  Config#config.title, Lang),
        |       stringxfield(&lt;&lt;"Room description"&gt;&gt;,
        |                 &lt;&lt;"muc#roomconfig_roomdesc"&gt;&gt;,
        |                  Config#config.description, Lang)
        |      ] ++
        |       case acl:match_rule(StateData#state.server_host, AccessPersistent, From) of
        |          allow -&gt;
<font color=red>     0..|              [boolxfield(</font>
        |               &lt;&lt;"Make room persistent"&gt;&gt;,
        |               &lt;&lt;"muc#roomconfig_persistentroom"&gt;&gt;,
        |                Config#config.persistent, Lang)];
<font color=red>     0..|          _ -&gt; []</font>
        |       end ++ [
        |       boolxfield(&lt;&lt;"Make room public searchable"&gt;&gt;,
        |               &lt;&lt;"muc#roomconfig_publicroom"&gt;&gt;,
        |                Config#config.public, Lang),
        |       boolxfield(&lt;&lt;"Make participants list public"&gt;&gt;,
        |               &lt;&lt;"public_list"&gt;&gt;,
        |                Config#config.public_list, Lang),
        |       boolxfield(&lt;&lt;"Make room password protected"&gt;&gt;,
        |               &lt;&lt;"muc#roomconfig_passwordprotectedroom"&gt;&gt;,
        |                Config#config.password_protected, Lang),
        |       privatexfield(&lt;&lt;"Password"&gt;&gt;,
        |              &lt;&lt;"muc#roomconfig_roomsecret"&gt;&gt;,
        |              case Config#config.password_protected of
<font color=red>     0..|                  true -&gt; Config#config.password;</font>
<font color=red>     0..|                  false -&gt; &lt;&lt;&gt;&gt;</font>
        |              end, Lang),
        |       #xmlel{name = &lt;&lt;"field"&gt;&gt;,
        |              attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"list-multi"&gt;&gt;},
        |                  {&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, &lt;&lt;"Roles and affiliations that may retrieve member list"&gt;&gt;)},
        |                  {&lt;&lt;"var"&gt;&gt;, &lt;&lt;"muc#roomconfig_getmemberlist"&gt;&gt;}],
        |              children = [
        |                  #xmlel{name = &lt;&lt;"value"&gt;&gt;, children = [#xmlcdata{content = &lt;&lt;"moderator"&gt;&gt;}]},
        |                  #xmlel{name = &lt;&lt;"value"&gt;&gt;, children = [#xmlcdata{content = &lt;&lt;"participant"&gt;&gt;}]},
        |                  #xmlel{name = &lt;&lt;"value"&gt;&gt;, children = [#xmlcdata{content = &lt;&lt;"visitor"&gt;&gt;}]},
        |                  #xmlel{name = &lt;&lt;"option"&gt;&gt;,
        |                      attrs = [{&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, &lt;&lt;"moderator"&gt;&gt;)}],
        |                      children = [
        |                          #xmlel{name = &lt;&lt;"value"&gt;&gt;, children = [#xmlcdata{content = &lt;&lt;"moderator"&gt;&gt;}]}
        |                      ]},
        |                  #xmlel{name = &lt;&lt;"option"&gt;&gt;,
        |                  attrs = [{&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, &lt;&lt;"participant"&gt;&gt;)}],
        |                  children = [
        |                      #xmlel{name = &lt;&lt;"value"&gt;&gt;, children = [#xmlcdata{content = &lt;&lt;"participant"&gt;&gt;}]}
        |                  ]},
        |                  #xmlel{name = &lt;&lt;"option"&gt;&gt;,
        |                  attrs = [{&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, &lt;&lt;"visitor"&gt;&gt;)}],
        |                  children = [
        |                      #xmlel{name = &lt;&lt;"value"&gt;&gt;, children = [#xmlcdata{content = &lt;&lt;"visitor"&gt;&gt;}]}
        |                  ]}
        |              ]
        |       },
        |       #xmlel{name = &lt;&lt;"field"&gt;&gt;,
        |              attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"list-single"&gt;&gt;},
        |                       {&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, &lt;&lt;"Maximum Number of Occupants"&gt;&gt;)},
        |                       {&lt;&lt;"var"&gt;&gt;, &lt;&lt;"muc#roomconfig_maxusers"&gt;&gt;}],
        |              children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                 children = [#xmlcdata{content = MaxUsersRoomString}]}] ++
        |                         if
<font color=red>     0..|                             is_integer(ServiceMaxUsers) -&gt; [];</font>
        |                             true -&gt;
<font color=red>     0..|                             [#xmlel{name = &lt;&lt;"option"&gt;&gt;,</font>
        |                                     attrs = [{&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, &lt;&lt;"No limit"&gt;&gt;)}],
        |                                     children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                                        children = [#xmlcdata{content = &lt;&lt;"none"&gt;&gt;}]}]}]
        |                         end ++
<font color=red>     0..|                         [#xmlel{name = &lt;&lt;"option"&gt;&gt;,</font>
        |                                 attrs = [{&lt;&lt;"label"&gt;&gt;, list_to_binary(integer_to_list(N))}],
        |                                 children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                                    children = [#xmlcdata{content = list_to_binary(integer_to_list(N))}]}]} ||
<font color=red>     0..|                                                                        N &lt;- lists:usort([ServiceMaxUsers, DefaultRoomMaxUsers, MaxUsersRoomInteger |</font>
<font color=red>     0..|                                                                                 ?MAX_USERS_DEFAULT_LIST]), N =&lt; ServiceMaxUsers]},</font>
        |       #xmlel{name = &lt;&lt;"field"&gt;&gt;,
        |              attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"list-single"&gt;&gt;},
        |                       {&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, &lt;&lt;"Present real Jabber IDs to"&gt;&gt;)},
        |                       {&lt;&lt;"var"&gt;&gt;, &lt;&lt;"muc#roomconfig_whois"&gt;&gt;}],
        |              children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                 children = [#xmlcdata{content = if Config#config.anonymous -&gt;
<font color=red>     0..|                                                                     &lt;&lt;"moderators"&gt;&gt;;</font>
        |                                                                    true -&gt;
<font color=red>     0..|                                                                         &lt;&lt;"anyone"&gt;&gt;</font>
        |                                                                 end}]},
        |                          #xmlel{name = &lt;&lt;"option"&gt;&gt;,
        |                                 attrs = [{&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, &lt;&lt;"moderators only"&gt;&gt;)}],
        |                                 children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                                    children = [#xmlcdata{content = &lt;&lt;"moderators"&gt;&gt;}]}]},
        |                          #xmlel{name = &lt;&lt;"option"&gt;&gt;,
        |                                 attrs = [{&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, &lt;&lt;"anyone"&gt;&gt;)}],
        |                                 children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                                    children = [#xmlcdata{content = &lt;&lt;"anyone"&gt;&gt;}]}]}]},
        |       boolxfield(&lt;&lt;"Make room members-only"&gt;&gt;,
        |               &lt;&lt;"muc#roomconfig_membersonly"&gt;&gt;,
        |                Config#config.members_only, Lang),
        |       boolxfield(&lt;&lt;"Make room moderated"&gt;&gt;,
        |               &lt;&lt;"muc#roomconfig_moderatedroom"&gt;&gt;,
        |                Config#config.moderated, Lang),
        |       boolxfield(&lt;&lt;"Default users as participants"&gt;&gt;,
        |               &lt;&lt;"members_by_default"&gt;&gt;,
        |                Config#config.members_by_default, Lang),
        |       boolxfield(&lt;&lt;"Allow users to change the subject"&gt;&gt;,
        |               &lt;&lt;"muc#roomconfig_changesubject"&gt;&gt;,
        |                Config#config.allow_change_subj, Lang),
        |       boolxfield(&lt;&lt;"Allow users to send private messages"&gt;&gt;,
        |               &lt;&lt;"allow_private_messages"&gt;&gt;,
        |                Config#config.allow_private_messages, Lang),
        |       boolxfield(&lt;&lt;"Allow users to query other users"&gt;&gt;,
        |               &lt;&lt;"allow_query_users"&gt;&gt;,
        |                Config#config.allow_query_users, Lang),
        |       boolxfield(&lt;&lt;"Allow users to send invites"&gt;&gt;,
        |               &lt;&lt;"muc#roomconfig_allowinvites"&gt;&gt;,
        |                Config#config.allow_user_invites, Lang),
        |       boolxfield(&lt;&lt;"Allow users to enter room with multiple sessions"&gt;&gt;,
        |               &lt;&lt;"muc#roomconfig_allowmultisessions"&gt;&gt;,
        |                Config#config.allow_multiple_sessions, Lang),
        |       boolxfield(&lt;&lt;"Allow visitors to send status text in presence updates"&gt;&gt;,
        |               &lt;&lt;"muc#roomconfig_allowvisitorstatus"&gt;&gt;,
        |                Config#config.allow_visitor_status, Lang),
        |       boolxfield(&lt;&lt;"Allow visitors to change nickname"&gt;&gt;,
        |               &lt;&lt;"muc#roomconfig_allowvisitornickchange"&gt;&gt;,
        |                Config#config.allow_visitor_nickchange, Lang)
        |      ] ++
        |      case mod_muc_log:check_access_log(
        |             StateData#state.server_host, From) of
        |          allow -&gt;
<font color=red>     0..|          [boolxfield(</font>
        |              &lt;&lt;"Enable logging"&gt;&gt;,
        |              &lt;&lt;"muc#roomconfig_enablelogging"&gt;&gt;,
        |               Config#config.logging, Lang)];
<font color=red>     0..|          _ -&gt; []</font>
        |      end,
<font color=red>     0..|      {result, [#xmlel{name = &lt;&lt;"instructions"&gt;&gt;,</font>
        |                       children = [#xmlcdata{content = translate:translate(
        |                                                         Lang, &lt;&lt;"You need an x:data capable client to configure room"&gt;&gt;)}]},
        |            #xmlel{name = &lt;&lt;"x"&gt;&gt;,
        |                   attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_XDATA},
        |                 {&lt;&lt;"type"&gt;&gt;, &lt;&lt;"form"&gt;&gt;}],
        |                   children = Res}],
        |       StateData}.
        |  
        |  
        |  -spec set_config(jlib:xmlel(), state()) -&gt; any().
        |  set_config(XEl, StateData) -&gt;
<font color=red>     0..|      XData = jlib:parse_xdata_submit(XEl),</font>
<font color=red>     0..|      case XData of</font>
        |      invalid -&gt;
<font color=red>     0..|          {error, ?ERR_BAD_REQUEST};</font>
        |      _ -&gt;
<font color=red>     0..|          case set_xoption(XData, StateData#state.config) of</font>
        |          #config{} = Config -&gt;
<font color=red>     0..|              Res = change_config(Config, StateData),</font>
<font color=red>     0..|              {result, _, NSD} = Res,</font>
<font color=red>     0..|              Type = case {(StateData#state.config)#config.logging,</font>
        |                   Config#config.logging} of
        |                     {true, false} -&gt;
<font color=red>     0..|                                    send_config_update(logging_disabled, StateData),</font>
<font color=red>     0..|                        roomconfig_change_disabledlogging;</font>
        |                     {false, true} -&gt;
<font color=red>     0..|                                    send_config_update(logging_enabled, StateData),</font>
<font color=red>     0..|                        roomconfig_change_enabledlogging;</font>
<font color=red>     0..|                                 {_, _} -&gt; case {(StateData#state.config)#config.anonymous,</font>
        |                                      Config#config.anonymous} of
        |                        {true, false} -&gt;
<font color=red>     0..|                                        send_config_update(nonanonymous, StateData),</font>
<font color=red>     0..|                                        roomconfig_change_nonanonymous;</font>
        |                                    {false, true} -&gt;
<font color=red>     0..|                                        send_config_update(semianonymous, StateData),</font>
<font color=red>     0..|                                        roomconfig_change_anonymous;</font>
        |                                    {_, _} -&gt;
<font color=red>     0..|                        roomconfig_change</font>
        |                                  end
        |                 end,
<font color=red>     0..|              Users = [{U#user.jid, U#user.nick, U#user.role} ||</font>
<font color=red>     0..|                  {_, U} &lt;- ?DICT:to_list(StateData#state.users)],</font>
<font color=red>     0..|              add_to_log(Type, Users, NSD),</font>
<font color=red>     0..|              Res;</font>
        |          Err -&gt;
<font color=red>     0..|              Err</font>
        |          end
        |      end.
        |  
        |  -define(SET_BOOL_XOPT(Opt, Val),
        |      case Val of
        |          &lt;&lt;"0"&gt;&gt; -&gt; set_xoption(Opts, Config#config{Opt = false});
        |          &lt;&lt;"false"&gt;&gt; -&gt; set_xoption(Opts, Config#config{Opt = false});
        |          &lt;&lt;"1"&gt;&gt; -&gt; set_xoption(Opts, Config#config{Opt = true});
        |          &lt;&lt;"true"&gt;&gt; -&gt; set_xoption(Opts, Config#config{Opt = true});
        |          _ -&gt; {error, ?ERR_BAD_REQUEST}
        |      end).
        |  
        |  -define(SET_NAT_XOPT(Opt, Val),
        |      case catch binary_to_integer(Val) of
        |          I when is_integer(I),
        |                 I &gt; 0 -&gt;
        |          set_xoption(Opts, Config#config{Opt = I});
        |          _ -&gt;
        |          {error, ?ERR_BAD_REQUEST}
        |      end).
        |  
        |  -define(SET_XOPT(Opt, Val),
        |      set_xoption(Opts, Config#config{Opt = Val})).
        |  
        |  -define(SET_JIDMULTI_XOPT(Opt, Vals),
        |          begin
        |              Set = lists:foldl(
        |                      fun({U, S, R}, Set1) -&gt;
        |                              ?SETS:add_element({U, S, R}, Set1);
        |                         (#jid{luser = U, lserver = S, lresource = R}, Set1) -&gt;
        |                              ?SETS:add_element({U, S, R}, Set1);
        |                         (_, Set1) -&gt;
        |                              Set1
        |                      end, ?SETS:empty(), Vals),
        |              set_xoption(Opts, Config#config{Opt = Set})
        |          end).
        |  
        |  -spec set_xoption([{binary(), binary()}], config()) -&gt; config() | {error, jlib:xmlel()}.
        |  set_xoption([], Config) -&gt;
<font color=red>     0..|      Config;</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_roomname"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_XOPT(title, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_roomdesc"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_XOPT(description, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_changesubject"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(allow_change_subj, Val);</font>
        |  set_xoption([{&lt;&lt;"allow_query_users"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(allow_query_users, Val);</font>
        |  set_xoption([{&lt;&lt;"allow_private_messages"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(allow_private_messages, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_allowvisitorstatus"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(allow_visitor_status, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_allowvisitornickchange"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(allow_visitor_nickchange, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_publicroom"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(public, Val);</font>
        |  set_xoption([{&lt;&lt;"public_list"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(public_list, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_persistentroom"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(persistent, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_moderatedroom"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(moderated, Val);</font>
        |  set_xoption([{&lt;&lt;"members_by_default"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(members_by_default, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_membersonly"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(members_only, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_allowinvites"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(allow_user_invites, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_allowmultisessions"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(allow_multiple_sessions, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_passwordprotectedroom"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(password_protected, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_roomsecret"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_XOPT(password, Val);</font>
        |  set_xoption([{&lt;&lt;"anonymous"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(anonymous, Val);</font>
        |  set_xoption([{&lt;&lt;"muc#roomconfig_whois"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      case Val of</font>
        |      &lt;&lt;"moderators"&gt;&gt; -&gt;
<font color=red>     0..|          ?SET_XOPT(anonymous, true);</font>
        |      &lt;&lt;"anyone"&gt;&gt; -&gt;
<font color=red>     0..|          ?SET_XOPT(anonymous, false);</font>
        |      _ -&gt;
<font color=red>     0..|          {error, ?ERR_BAD_REQUEST}</font>
        |      end;
        |  set_xoption([{&lt;&lt;"muc#roomconfig_maxusers"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      case Val of</font>
        |      &lt;&lt;"none"&gt;&gt; -&gt;
<font color=red>     0..|          ?SET_XOPT(max_users, none);</font>
        |      _ -&gt;
<font color=red>     0..|          ?SET_NAT_XOPT(max_users, Val)</font>
        |      end;
        |  set_xoption([{&lt;&lt;"muc#roomconfig_getmemberlist"&gt;&gt;, Val} | Opts], Config) -&gt;
<font color=red>     0..|      case Val of</font>
        |          &lt;&lt;"none"&gt;&gt; -&gt;
<font color=red>     0..|              ?SET_XOPT(maygetmemberlist, []);</font>
        |          _ -&gt;
<font color=red>     0..|              ?SET_XOPT(maygetmemberlist, [binary_to_existing_atom(V, latin1) || V &lt;- Val])</font>
        |      end;
        |  set_xoption([{&lt;&lt;"muc#roomconfig_enablelogging"&gt;&gt;, [Val]} | Opts], Config) -&gt;
<font color=red>     0..|      ?SET_BOOL_XOPT(logging, Val);</font>
        |  set_xoption([{&lt;&lt;"FORM_TYPE"&gt;&gt;, _} | Opts], Config) -&gt;
        |      %% Ignore our FORM_TYPE
<font color=red>     0..|      set_xoption(Opts, Config);</font>
        |  set_xoption([_ | _Opts], _Config) -&gt;
<font color=red>     0..|      {error, ?ERR_BAD_REQUEST}.</font>
        |  
        |  
        |  -spec change_config(config(), state()) -&gt; {'result',[],state()}.
        |  change_config(Config, StateData) -&gt;
<font color=red>     0..|      NSD = StateData#state{config = Config},</font>
<font color=red>     0..|      case {(StateData#state.config)#config.persistent,</font>
        |        Config#config.persistent} of
        |      {_, true} -&gt;
<font color=red>     0..|          mod_muc:store_room(NSD#state.host, NSD#state.room, make_opts(NSD));</font>
        |      {true, false} -&gt;
<font color=red>     0..|          mod_muc:forget_room(NSD#state.host, NSD#state.room);</font>
        |      {false, false} -&gt;
<font color=red>     0..|          ok</font>
        |      end,
<font color=red>     0..|      case {(StateData#state.config)#config.members_only,</font>
        |            Config#config.members_only} of
        |      {false, true} -&gt;
<font color=red>     0..|          NSD1 = remove_nonmembers(NSD),</font>
<font color=red>     0..|          {result, [], NSD1};</font>
        |      _ -&gt;
<font color=red>     0..|          {result, [], NSD}</font>
        |      end.
        |  
        |  
        |  -spec remove_nonmembers(state()) -&gt; state().
        |  remove_nonmembers(StateData) -&gt;
<font color=red>     0..|      lists:foldl(</font>
        |        fun({_LJID, #user{jid = JID}}, SD) -&gt;
<font color=red>     0..|          Affiliation = get_affiliation(JID, SD),</font>
<font color=red>     0..|          case Affiliation of</font>
        |          none -&gt;
<font color=red>     0..|              catch send_kickban_presence(</font>
        |                  JID, &lt;&lt;&gt;&gt;, &lt;&lt;"322"&gt;&gt;, SD),
<font color=red>     0..|              set_role(JID, none, SD);</font>
        |          _ -&gt;
<font color=red>     0..|              SD</font>
        |          end
        |        end, StateData, ?DICT:to_list(StateData#state.users)).
        |  
        |  
        |  -spec set_opts(Opts :: [{atom(), term()}], state()) -&gt; state().
        |  set_opts([], SD) -&gt;
<font color=red>     0..|      SD;</font>
        |  set_opts([{Opt, Val} | Opts], SD=#state{config = C = #config{}}) -&gt;
<font color=red>     0..|      NSD = case Opt of</font>
        |          title -&gt;
<font color=red>     0..|              SD#state{config = C#config{title = Val}};</font>
        |          description -&gt;
<font color=red>     0..|              SD#state{config = C#config{description = Val}};</font>
        |          allow_change_subj -&gt;
<font color=red>     0..|              SD#state{config = C#config{allow_change_subj = Val}};</font>
        |          allow_query_users -&gt;
<font color=red>     0..|              SD#state{config = C#config{allow_query_users = Val}};</font>
        |          allow_private_messages -&gt;
<font color=red>     0..|              SD#state{config = C#config{allow_private_messages = Val}};</font>
        |          allow_visitor_nickchange -&gt;
<font color=red>     0..|              SD#state{config = C#config{allow_visitor_nickchange = Val}};</font>
        |          allow_visitor_status -&gt;
<font color=red>     0..|              SD#state{config = C#config{allow_visitor_status = Val}};</font>
        |          public -&gt;
<font color=red>     0..|              SD#state{config = C#config{public = Val}};</font>
        |          public_list -&gt;
<font color=red>     0..|              SD#state{config = C#config{public_list = Val}};</font>
        |          persistent -&gt;
<font color=red>     0..|              SD#state{config = C#config{persistent = Val}};</font>
        |          moderated -&gt;
<font color=red>     0..|              SD#state{config = C#config{moderated = Val}};</font>
        |          members_by_default -&gt;
<font color=red>     0..|              SD#state{config = C#config{members_by_default = Val}};</font>
        |          members_only -&gt;
<font color=red>     0..|              SD#state{config = C#config{members_only = Val}};</font>
        |          allow_user_invites -&gt;
<font color=red>     0..|              SD#state{config = C#config{allow_user_invites = Val}};</font>
        |          allow_multiple_sessions -&gt;
<font color=red>     0..|              SD#state{config = C#config{allow_multiple_sessions = Val}};</font>
        |          password_protected -&gt;
<font color=red>     0..|              SD#state{config = C#config{password_protected = Val}};</font>
        |          password -&gt;
<font color=red>     0..|              SD#state{config = C#config{password = Val}};</font>
        |          anonymous -&gt;
<font color=red>     0..|              SD#state{config = C#config{anonymous = Val}};</font>
        |          logging -&gt;
<font color=red>     0..|              SD#state{config = C#config{logging = Val}};</font>
        |          max_users -&gt;
<font color=red>     0..|              MaxUsers = min(Val, get_service_max_users(SD)),</font>
<font color=red>     0..|              SD#state{config = C#config{max_users = MaxUsers}};</font>
        |          maygetmemberlist -&gt;
<font color=red>     0..|              SD#state{config = C#config{maygetmemberlist = Val}};</font>
        |          affiliations -&gt;
<font color=red>     0..|              SD#state{affiliations = ?DICT:from_list(Val)};</font>
        |          subject -&gt;
<font color=red>     0..|              SD#state{subject = Val};</font>
        |          subject_author -&gt;
<font color=red>     0..|              SD#state{subject_author = Val};</font>
        |          _ -&gt;
<font color=red>     0..|              SD</font>
        |         end,
<font color=red>     0..|      set_opts(Opts, NSD).</font>
        |  
        |  
        |  -define(MAKE_CONFIG_OPT(Opt), {Opt, Config#config.Opt}).
        |  
        |  -spec make_opts(state()) -&gt; [{atom(),_},...].
        |  make_opts(StateData) -&gt;
<font color=red>     0..|      Config = StateData#state.config,</font>
<font color=red>     0..|      [</font>
        |       ?MAKE_CONFIG_OPT(title),
        |       ?MAKE_CONFIG_OPT(description),
        |       ?MAKE_CONFIG_OPT(allow_change_subj),
        |       ?MAKE_CONFIG_OPT(allow_query_users),
        |       ?MAKE_CONFIG_OPT(allow_private_messages),
        |       ?MAKE_CONFIG_OPT(allow_visitor_status),
        |       ?MAKE_CONFIG_OPT(allow_visitor_nickchange),
        |       ?MAKE_CONFIG_OPT(public),
        |       ?MAKE_CONFIG_OPT(public_list),
        |       ?MAKE_CONFIG_OPT(persistent),
        |       ?MAKE_CONFIG_OPT(moderated),
        |       ?MAKE_CONFIG_OPT(members_by_default),
        |       ?MAKE_CONFIG_OPT(members_only),
        |       ?MAKE_CONFIG_OPT(allow_user_invites),
        |       ?MAKE_CONFIG_OPT(allow_multiple_sessions),
        |       ?MAKE_CONFIG_OPT(password_protected),
        |       ?MAKE_CONFIG_OPT(password),
        |       ?MAKE_CONFIG_OPT(anonymous),
        |       ?MAKE_CONFIG_OPT(logging),
        |       ?MAKE_CONFIG_OPT(max_users),
        |       ?MAKE_CONFIG_OPT(maygetmemberlist),
        |       {affiliations, ?DICT:to_list(StateData#state.affiliations)},
        |       {subject, StateData#state.subject},
        |       {subject_author, StateData#state.subject_author}
        |      ].
        |  
        |  
        |  -spec destroy_room(jlib:xmlel(), state()) -&gt; {result, [], stop}.
        |  destroy_room(DestroyEl, StateData) -&gt;
<font color=red>     0..|      remove_each_occupant_from_room(DestroyEl, StateData),</font>
<font color=red>     0..|      case (StateData#state.config)#config.persistent of</font>
        |          true -&gt;
<font color=red>     0..|              mod_muc:forget_room(StateData#state.host, StateData#state.room);</font>
        |          false -&gt;
<font color=red>     0..|              ok</font>
        |      end,
<font color=red>     0..|      {result, [], stop}.</font>
        |  
        |  
        |  %% @doc Service Removes Each Occupant
        |  %%
        |  %% Send only one presence stanza of type "unavailable" to each occupant
        |  %% so that the user knows he or she has been removed from the room.
        |  %%
        |  %% If extended presence information specifying the JID of an alternate
        |  %% location and the reason for the room destruction was provided by the
        |  %% room owner, the presence stanza MUST include that information.
        |  %% @end
        |  -spec remove_each_occupant_from_room(jlib:xmlel(), state()) -&gt; any().
        |  remove_each_occupant_from_room(DestroyEl, StateData) -&gt;
<font color=red>     0..|      Packet = presence_stanza_of_type_unavailable(DestroyEl),</font>
<font color=red>     0..|      send_to_occupants(Packet, StateData).</font>
        |  
        |  
        |  -spec send_to_occupants(jlib:xmlel(), state()) -&gt; any().
        |  send_to_occupants(Packet, StateData=#state{jid=RoomJID}) -&gt;
<font color=red>     0..|      F = fun(User=#user{jid=UserJID}) -&gt;</font>
<font color=red>     0..|          ejabberd_router:route(occupant_jid(User, RoomJID), UserJID, Packet)</font>
        |          end,
<font color=red>     0..|      foreach_user(F, StateData).</font>
        |  
        |  
        |  -spec presence_stanza_of_type_unavailable(jlib:xmlel()) -&gt; jlib:xmlel().
        |  presence_stanza_of_type_unavailable(DestroyEl) -&gt;
<font color=red>     0..|      ItemEl = #xmlel{</font>
        |          name = &lt;&lt;"item"&gt;&gt;,
        |          attrs = [{&lt;&lt;"affiliation"&gt;&gt;, &lt;&lt;"none"&gt;&gt;}, {&lt;&lt;"role"&gt;&gt;, &lt;&lt;"none"&gt;&gt;}]},
<font color=red>     0..|      XEl = #xmlel{</font>
        |          name = &lt;&lt;"x"&gt;&gt;,
        |          attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_USER}],
        |          children = [ItemEl, DestroyEl]},
<font color=red>     0..|      #xmlel{</font>
        |          name = &lt;&lt;"presence"&gt;&gt;,
        |          attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"unavailable"&gt;&gt;}],
        |          children = [XEl]}.
        |  
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  % Disco
        |  
        |  -spec feature(binary()) -&gt; jlib:xmlel().
        |  feature(Var) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"feature"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"var"&gt;&gt;, Var}]}.
        |  
        |  
        |  -spec config_opt_to_feature(boolean(), Fiftrue :: binary(), Fiffalse :: binary())
        |                              -&gt; jlib:xmlel().
        |  config_opt_to_feature(Opt, Fiftrue, Fiffalse) -&gt;
<font color=red>     0..|      case Opt of</font>
<font color=red>     0..|          true -&gt; feature(Fiftrue);</font>
<font color=red>     0..|          false -&gt; feature(Fiffalse)</font>
        |      end.
        |  
        |  
        |  -spec process_iq_disco_info(ejabberd:jid(), 'get' | 'set', ejabberd:lang(),
        |                              state()) -&gt; {'error', jlib:xmlel()}
        |                                        | {'result',[jlib:xmlel(),...],state()}.
        |  process_iq_disco_info(_From, set, _Lang, _StateData) -&gt;
<font color=red>     0..|      {error, ?ERR_NOT_ALLOWED};</font>
        |  process_iq_disco_info(_From, get, Lang, StateData) -&gt;
<font color=red>     0..|      Config = StateData#state.config,</font>
<font color=red>     0..|      {result, [#xmlel{name = &lt;&lt;"identity"&gt;&gt;,</font>
        |                       attrs = [{&lt;&lt;"category"&gt;&gt;, &lt;&lt;"conference"&gt;&gt;},
        |                            {&lt;&lt;"type"&gt;&gt;, &lt;&lt;"text"&gt;&gt;},
        |                            {&lt;&lt;"name"&gt;&gt;, get_title(StateData)}]},
        |                #xmlel{name = &lt;&lt;"feature"&gt;&gt;, attrs = [{&lt;&lt;"var"&gt;&gt;, ?NS_MUC}]},
        |                config_opt_to_feature((Config#config.public),
        |                           &lt;&lt;"muc_public"&gt;&gt;, &lt;&lt;"muc_hidden"&gt;&gt;),
        |                config_opt_to_feature((Config#config.persistent),
        |                           &lt;&lt;"muc_persistent"&gt;&gt;, &lt;&lt;"muc_temporary"&gt;&gt;),
        |                config_opt_to_feature((Config#config.members_only),
        |                           &lt;&lt;"muc_membersonly"&gt;&gt;, &lt;&lt;"muc_open"&gt;&gt;),
        |                config_opt_to_feature((Config#config.anonymous),
        |                           &lt;&lt;"muc_semianonymous"&gt;&gt;, &lt;&lt;"muc_nonanonymous"&gt;&gt;),
        |                config_opt_to_feature((Config#config.moderated),
        |                           &lt;&lt;"muc_moderated"&gt;&gt;, &lt;&lt;"muc_unmoderated"&gt;&gt;),
        |                config_opt_to_feature((Config#config.password_protected),
        |                           &lt;&lt;"muc_passwordprotected"&gt;&gt;, &lt;&lt;"muc_unsecured"&gt;&gt;)
        |               ] ++ iq_disco_info_extras(Lang, StateData), StateData}.
        |  
        |  
        |  -spec rfieldt(binary(), binary(), binary()) -&gt; jlib:xmlel().
        |  rfieldt(Type, Var, Val) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"field"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"type"&gt;&gt;, Type}, {&lt;&lt;"var"&gt;&gt;, Var}],
        |             children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                children = [#xmlcdata{content = Val}]}]}.
        |  
        |  
        |  -spec rfield(binary(), binary(), binary() | iolist(), ejabberd:lang()) -&gt; jlib:xmlel().
        |  rfield(Label, Var, Val, Lang) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"field"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, Label)},
        |               {&lt;&lt;"var"&gt;&gt;, Var}],
        |             children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                children = [#xmlcdata{content = Val}]}]}.
        |  
        |  
        |  -spec iq_disco_info_extras(ejabberd:lang(), state()) -&gt; [jlib:xmlel(),...].
        |  iq_disco_info_extras(Lang, StateData) -&gt;
<font color=red>     0..|      Len = length(?DICT:to_list(StateData#state.users)),</font>
<font color=red>     0..|      RoomDescription = (StateData#state.config)#config.description,</font>
<font color=red>     0..|      [#xmlel{name = &lt;&lt;"x"&gt;&gt;,</font>
        |              attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_XDATA}, {&lt;&lt;"type"&gt;&gt;, &lt;&lt;"result"&gt;&gt;}],
        |              children = [rfieldt(&lt;&lt;"hidden"&gt;&gt;, &lt;&lt;"FORM_TYPE"&gt;&gt;,
        |                           &lt;&lt;"http://jabber.org/protocol/muc#roominfo"&gt;&gt;),
        |                          rfield(&lt;&lt;"Room description"&gt;&gt;, &lt;&lt;"muc#roominfo_description"&gt;&gt;,
        |                              RoomDescription, Lang),
        |                          rfield(&lt;&lt;"Number of occupants"&gt;&gt;, &lt;&lt;"muc#roominfo_occupants"&gt;&gt;,
        |                              (list_to_binary(integer_to_list(Len))), Lang)
        |                         ]}].
        |  
        |  
        |  -spec process_iq_disco_items(ejabberd:jid(), 'get' | 'set', ejabberd:lang(),
        |                              state()) -&gt; {'error',jlib:xmlel()}
        |                                        | {'result',[jlib:xmlel()],state()}.
        |  process_iq_disco_items(_From, set, _Lang, _StateData) -&gt;
<font color=red>     0..|      {error, ?ERR_NOT_ALLOWED};</font>
        |  process_iq_disco_items(From, get, _Lang, StateData) -&gt;
<font color=red>     0..|      case (StateData#state.config)#config.public_list of</font>
        |      true -&gt;
<font color=red>     0..|          {result, get_mucroom_disco_items(StateData), StateData};</font>
        |      _ -&gt;
<font color=red>     0..|          case is_occupant_or_admin(From, StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              {result, get_mucroom_disco_items(StateData), StateData};</font>
        |          _ -&gt;
<font color=red>     0..|              {error, ?ERR_FORBIDDEN}</font>
        |          end
        |      end.
        |  
        |  
        |  -spec get_title(state()) -&gt; binary() | mod_muc:room().
        |  get_title(StateData) -&gt;
<font color=red>     0..|      case (StateData#state.config)#config.title of</font>
        |      &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|          StateData#state.room;</font>
        |      Name -&gt;
<font color=red>     0..|          Name</font>
        |      end.
        |  
        |  
        |  -spec get_roomdesc_reply(ejabberd:jid(), state(), Tail :: binary()
        |                          ) -&gt; 'false' | {'item',_}.
        |  get_roomdesc_reply(JID, StateData, Tail) -&gt;
<font color=red>     0..|      IsOccupantOrAdmin = is_occupant_or_admin(JID, StateData),</font>
<font color=red>     0..|      if (StateData#state.config)#config.public or IsOccupantOrAdmin -&gt;</font>
<font color=red>     0..|          if (StateData#state.config)#config.public_list or IsOccupantOrAdmin -&gt;</font>
<font color=red>     0..|                      Title = get_title(StateData),</font>
<font color=red>     0..|              {item, &lt;&lt;Title/binary, Tail/binary&gt;&gt;};</font>
        |             true -&gt;
<font color=red>     0..|              {item, get_title(StateData)}</font>
        |          end;
        |         true -&gt;
<font color=red>     0..|          false</font>
        |      end.
        |  
        |  
        |  -spec get_roomdesc_tail(state(), ejabberd:lang()) -&gt; binary().
        |  get_roomdesc_tail(StateData, Lang) -&gt;
<font color=red>     0..|      Desc = case (StateData#state.config)#config.public of</font>
        |                 true -&gt;
<font color=red>     0..|                     &lt;&lt;&gt;&gt;;</font>
        |                 _ -&gt;
<font color=red>     0..|                     translate:translate(Lang, &lt;&lt;"private, "&gt;&gt;)</font>
        |             end,
<font color=red>     0..|      Count = count_users(StateData),</font>
<font color=red>     0..|      CountBin = list_to_binary(integer_to_list(Count)),</font>
<font color=red>     0..|      &lt;&lt;" (", Desc/binary, CountBin/binary, ")"&gt;&gt;.</font>
        |  
        |  
        |  -spec get_mucroom_disco_items(state()) -&gt; [jlib:xmlel()].
        |  get_mucroom_disco_items(StateData=#state{jid=RoomJID}) -&gt;
<font color=red>     0..|      [disco_item(User, RoomJID)</font>
<font color=red>     0..|       || {_LJID, User} &lt;- ?DICT:to_list(StateData#state.users)].</font>
        |  
        |  
        |  -spec disco_item(user(), 'undefined' | ejabberd:jid()) -&gt; jlib:xmlel().
        |  disco_item(User=#user{nick=Nick}, RoomJID) -&gt;
<font color=red>     0..|      #xmlel{</font>
        |          name = &lt;&lt;"item"&gt;&gt;,
        |          attrs = [{&lt;&lt;"jid"&gt;&gt;, jid:to_binary(occupant_jid(User, RoomJID))},
        |                   {&lt;&lt;"name"&gt;&gt;, Nick}]}.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Handle voice request or approval (XEP-0045 7.13, 8.6)
        |  -spec check_voice_approval(From :: ejabberd:jid(), Els :: [jlib:xmlel()],
        |          Lang :: ejabberd:lang(), StateData :: state()
        |          ) -&gt; {form, BRole :: binary()}
        |             | {role, BRole :: binary(), RoomNick :: mod_muc:nick()}
        |             | {error, any()}
        |             | ok.
        |  check_voice_approval(From, [#xmlel{name = &lt;&lt;"x"&gt;&gt;,
        |                                     children = Items}], _Lang, StateData) -&gt;
<font color=red>     0..|      BRole = get_field(&lt;&lt;"muc#role"&gt;&gt;, Items),</font>
<font color=red>     0..|      case Items of</font>
        |      [_Form, _Role] -&gt;
<font color=red>     0..|          case catch binary_to_role(BRole) of</font>
<font color=red>     0..|          {'EXIT', _} -&gt; {error, ?ERR_BAD_REQUEST};</font>
<font color=red>     0..|          _ -&gt; {form, BRole}</font>
        |          end;
        |      _ -&gt;
<font color=red>     0..|          case get_role(From, StateData) of</font>
        |          moderator -&gt;
<font color=red>     0..|              case get_field(&lt;&lt;"muc#request_allow"&gt;&gt;, Items) of</font>
        |              &lt;&lt;"true"&gt;&gt; -&gt;
<font color=red>     0..|                  case get_field(&lt;&lt;"muc#roomnick"&gt;&gt;, Items) of</font>
<font color=red>     0..|                  false -&gt; {error, ?ERR_BAD_REQUEST};</font>
<font color=red>     0..|                  RoomNick -&gt; {role, BRole, RoomNick}</font>
        |                  end;
<font color=red>     0..|              _ -&gt; ok</font>
        |              end;
<font color=red>     0..|          _ -&gt; {error, ?ERR_NOT_ALLOWED}</font>
        |          end
        |      end.
        |  
        |  
        |  -spec get_field(binary(), [jlib:xmlcdata() | jlib:xmlel()]) -&gt; any().
        |  get_field(Var, [#xmlel{name = &lt;&lt;"field"&gt;&gt;, attrs = Attrs} = Item|Items])
        |      when is_binary(Var) -&gt;
<font color=red>     0..|      case xml:get_attr(&lt;&lt;"var"&gt;&gt;, Attrs) of</font>
        |      {value, Var} -&gt;
<font color=red>     0..|          case xml:get_path_s(Item, [{elem, &lt;&lt;"value"&gt;&gt;}, cdata]) of</font>
<font color=red>     0..|          &lt;&lt;&gt;&gt; -&gt; get_field(Var, Items);</font>
<font color=red>     0..|          Value -&gt; Value</font>
        |          end;
        |      _ -&gt;
<font color=red>     0..|          get_field(Var, Items)</font>
        |      end;
        |  get_field(_Var, []) -&gt;
<font color=red>     0..|      false.</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Invitation support
        |  
        |  -spec check_invitation(ejabberd:simple_jid() | ejabberd:jid(),
        |          [jlib:xmlcdata() | jlib:xmlel()], ejabberd:lang(), state())
        |              -&gt; {'error',_} | {'ok',ejabberd:jid()}.
        |  check_invitation(FromJID, Els, Lang, StateData) -&gt;
<font color=red>     0..|      try</font>
<font color=red>     0..|          unsafe_check_invitation(FromJID, Els, Lang, StateData)</font>
<font color=red>     0..|      catch throw:{error, Reason} -&gt; {error, Reason}</font>
        |      end.
        |  
        |  
        |  -spec unsafe_check_invitation(ejabberd:jid(), [jlib:xmlcdata() | jlib:xmlel()],
        |                                ejabberd:lang(), state()) -&gt; {ok, [ejabberd:jid()]}.
        |  unsafe_check_invitation(FromJID, Els, Lang,
        |      StateData=#state{host=Host, server_host=ServerHost, jid=RoomJID}) -&gt;
<font color=red>     0..|      FAffiliation = get_affiliation(FromJID, StateData),</font>
<font color=red>     0..|      CanInvite = (StateData#state.config)#config.allow_user_invites</font>
<font color=red>     0..|           orelse (FAffiliation == admin)</font>
<font color=red>     0..|           orelse (FAffiliation == owner),</font>
<font color=red>     0..|      case CanInvite of</font>
        |      false -&gt;
<font color=red>     0..|          throw({error, ?ERR_FORBIDDEN});</font>
        |      true -&gt;
<font color=red>     0..|          InviteEls = find_invite_elems(Els),</font>
        |          %% Decode all JIDs first, so we fail early if any JID is invalid.
<font color=red>     0..|          JIDs = lists:map(fun decode_destination_jid/1, InviteEls),</font>
<font color=red>     0..|          lists:foreach(</font>
        |            fun(InviteEl) -&gt;
<font color=red>     0..|                    JID = decode_destination_jid(InviteEl),</font>
        |                    %% Create an invitation message and send it to the user.
<font color=red>     0..|                    Reason = decode_reason(InviteEl),</font>
<font color=red>     0..|                    ContinueEl =</font>
        |                        case xml:get_path_s(InviteEl, [{elem, &lt;&lt;"continue"&gt;&gt;}]) of
<font color=red>     0..|                            &lt;&lt;&gt;&gt; -&gt; [];</font>
<font color=red>     0..|                            Continue1 -&gt; [Continue1]</font>
        |                        end,
<font color=red>     0..|                    ReasonEl = #xmlel{</font>
        |                                  name = &lt;&lt;"reason"&gt;&gt;,
        |                                  children = [#xmlcdata{content = Reason}]},
<font color=red>     0..|                    OutInviteEl = #xmlel{</font>
        |                                     name = &lt;&lt;"invite"&gt;&gt;,
        |                                     attrs = [{&lt;&lt;"from"&gt;&gt;, jid:to_binary(FromJID)}],
        |                                     children = [ReasonEl] ++ ContinueEl},
<font color=red>     0..|                    PasswdEl = create_password_elem(StateData),</font>
<font color=red>     0..|                    BodyEl = invite_body_elem(FromJID, Reason, Lang, StateData),</font>
<font color=red>     0..|                    Msg = create_invite_message_elem(</font>
        |                            OutInviteEl, BodyEl, PasswdEl, Reason),
<font color=red>     0..|                    ejabberd_hooks:run(invitation_sent, Host,</font>
        |                                       [Host, ServerHost, RoomJID, FromJID, JID, Reason]),
<font color=red>     0..|                    ejabberd_router:route(StateData#state.jid, JID, Msg)</font>
        |            end, InviteEls),
<font color=red>     0..|          {ok, JIDs}</font>
        |      end.
        |  
        |  
        |  -spec decode_destination_jid(jlib:xmlel()) -&gt; ejabberd:jid().
        |  decode_destination_jid(InviteEl) -&gt;
<font color=red>     0..|      case jid:from_binary(xml:get_tag_attr_s(&lt;&lt;"to"&gt;&gt;, InviteEl)) of</font>
<font color=red>     0..|        error -&gt; throw({error, ?ERR_JID_MALFORMED});</font>
<font color=red>     0..|        JID   -&gt; JID</font>
        |      end.
        |  
        |  
        |  -spec find_invite_elems([jlib:xmlcdata() | jlib:xmlel()]) -&gt; [jlib:xmlel()].
        |  find_invite_elems(Els) -&gt;
<font color=red>     0..|      case xml:remove_cdata(Els) of</font>
        |      [#xmlel{name = &lt;&lt;"x"&gt;&gt;, children = Els1} = XEl] -&gt;
<font color=red>     0..|          case xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, XEl) of</font>
        |          ?NS_MUC_USER -&gt;
<font color=red>     0..|              ok;</font>
        |          _ -&gt;
<font color=red>     0..|              throw({error, ?ERR_BAD_REQUEST})</font>
        |          end,
        |  
<font color=red>     0..|          InviteEls =</font>
<font color=red>     0..|              [InviteEl || #xmlel{name = &lt;&lt;"invite"&gt;&gt;} = InviteEl &lt;- Els1],</font>
<font color=red>     0..|          case InviteEls of</font>
        |              [_|_] -&gt;
<font color=red>     0..|                  InviteEls;</font>
        |              _ -&gt;
<font color=red>     0..|                  throw({error, ?ERR_BAD_REQUEST})</font>
        |          end;
        |      _ -&gt;
<font color=red>     0..|          throw({error, ?ERR_BAD_REQUEST})</font>
        |      end.
        |  
        |  
        |  -spec create_password_elem(state()) -&gt; [jlib:xmlel()].
        |  create_password_elem(#state{config=#config{password_protected=IsProtected,
        |                                             password=Password}}) -&gt;
<font color=red>     0..|      case IsProtected of</font>
        |          true -&gt;
<font color=red>     0..|          [#xmlel{</font>
        |              name = &lt;&lt;"password"&gt;&gt;,
        |              children = [#xmlcdata{content = Password}]}];
        |          _ -&gt;
<font color=red>     0..|          []</font>
        |      end.
        |  
        |  
        |  -spec invite_body_elem(ejabberd:jid(), binary(), ejabberd:lang(), state()
        |                        ) -&gt; jlib:xmlel().
        |  invite_body_elem(FromJID, Reason, Lang, StateData) -&gt;
<font color=red>     0..|      Text = invite_body_text(FromJID, Reason, Lang, StateData),</font>
<font color=red>     0..|      #xmlel{</font>
        |          name = &lt;&lt;"body"&gt;&gt;,
        |          children = [#xmlcdata{content = Text}]}.
        |  
        |  
        |  -spec invite_body_text(ejabberd:jid(), binary(), ejabberd:lang(), state()) -&gt; binary().
        |  invite_body_text(FromJID, Reason, Lang,
        |          #state{
        |              jid=RoomJID,
        |              config=#config{
        |                  password_protected=IsProtected,
        |                  password=Password}}) -&gt;
<font color=red>     0..|      BFromJID = jid:to_binary(FromJID),</font>
<font color=red>     0..|      BRoomJID = jid:to_binary(RoomJID),</font>
<font color=red>     0..|      ITranslate = translate:translate(Lang, &lt;&lt;" invites you to the room "&gt;&gt;),</font>
<font color=red>     0..|      IMessage = &lt;&lt;BFromJID/binary, ITranslate/binary, BRoomJID/binary&gt;&gt;,</font>
<font color=red>     0..|      BPassword = case IsProtected of</font>
        |          true -&gt;
<font color=red>     0..|              PTranslate = translate:translate(Lang, &lt;&lt;"the password is"&gt;&gt;),</font>
<font color=red>     0..|              &lt;&lt;", ", PTranslate/binary, " '", Password/binary, "'"&gt;&gt;;</font>
        |          _ -&gt;
<font color=red>     0..|              &lt;&lt;&gt;&gt;</font>
        |          end,
<font color=red>     0..|      BReason = case Reason of</font>
<font color=red>     0..|          &lt;&lt;&gt;&gt; -&gt; &lt;&lt;&gt;&gt;;</font>
<font color=red>     0..|          _    -&gt; &lt;&lt;" (", Reason/binary, ") "&gt;&gt;</font>
        |          end,
<font color=red>     0..|      &lt;&lt;IMessage/binary, BPassword/binary, BReason/binary&gt;&gt;.</font>
        |  
        |  
        |  -spec create_invite_message_elem(Inv :: jlib:xmlel(), Body :: jlib:xmlel(),
        |          Passwd :: [jlib:xmlel()], Reason :: binary()
        |          ) -&gt; jlib:xmlel().
        |  create_invite_message_elem(InviteEl, BodyEl, PasswdEl, Reason)
        |      when is_list(PasswdEl), is_binary(Reason) -&gt;
<font color=red>     0..|      UserXEl = #xmlel{</font>
        |          name = &lt;&lt;"x"&gt;&gt;,
        |          attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_USER}],
        |          children = [InviteEl|PasswdEl]},
<font color=red>     0..|      #xmlel{</font>
        |          name = &lt;&lt;"message"&gt;&gt;,
        |          attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"normal"&gt;&gt;}],
        |          children = [UserXEl, BodyEl]}.
        |  
        |  
        |  %% @doc Handle a message sent to the room by a non-participant.
        |  %% If it is a decline, send to the inviter.
        |  %% Otherwise, an error message is sent to the sender.
        |  -spec handle_roommessage_from_nonparticipant(jlib:xmlel(), ejabberd:lang(),
        |                      state(), ejabberd:simple_jid() | ejabberd:jid()) -&gt; 'ok'.
        |  handle_roommessage_from_nonparticipant(Packet, Lang, StateData, From) -&gt;
<font color=red>     0..|      case catch check_decline_invitation(Packet) of</font>
        |          {true, Decline_data} -&gt;
<font color=red>     0..|              send_decline_invitation(Decline_data, StateData#state.jid, From);</font>
        |          _ -&gt;
<font color=red>     0..|              send_error_only_occupants(&lt;&lt;"messages"&gt;&gt;, Packet, Lang,</font>
        |                                        StateData#state.jid, From)
        |      end.
        |  
        |  
        |  %% @doc Check in the packet is a decline. If so, also returns the splitted
        |  %% packet. This function must be catched, because it crashes when the packet
        |  %% is not a decline message.
        |  -spec check_decline_invitation(jlib:xmlel()) -&gt;
        |      {'true',{jlib:xmlel(), jlib:xmlel(), jlib:xmlel(), 'error' | ejabberd:jid()}}.
        |  check_decline_invitation(Packet) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"message"&gt;&gt;} = Packet,</font>
<font color=red>     0..|      XEl = xml:get_subtag(Packet, &lt;&lt;"x"&gt;&gt;),</font>
<font color=red>     0..|      ?NS_MUC_USER = xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, XEl),</font>
<font color=red>     0..|      DEl = xml:get_subtag(XEl, &lt;&lt;"decline"&gt;&gt;),</font>
<font color=red>     0..|      ToString = xml:get_tag_attr_s(&lt;&lt;"to"&gt;&gt;, DEl),</font>
<font color=red>     0..|      ToJID = jid:from_binary(ToString),</font>
<font color=red>     0..|      {true, {Packet, XEl, DEl, ToJID}}.</font>
        |  
        |  
        |  %% @doc Send the decline to the inviter user.
        |  %% The original stanza must be slightly modified.
        |  -spec send_decline_invitation({jlib:xmlel(), jlib:xmlel(), jlib:xmlel(), ejabberd:jid()},
        |          ejabberd:jid(), ejabberd:simple_jid() | ejabberd:jid()) -&gt; 'ok'.
        |  send_decline_invitation({Packet, XEl, DEl, ToJID}, RoomJID, FromJID) -&gt;
<font color=red>     0..|      FromString = jid:to_binary(FromJID),</font>
<font color=red>     0..|      #xmlel{name = &lt;&lt;"decline"&gt;&gt;, attrs = DAttrs, children = DEls} = DEl,</font>
<font color=red>     0..|      DAttrs2 = lists:keydelete(&lt;&lt;"to"&gt;&gt;, 1, DAttrs),</font>
<font color=red>     0..|      DAttrs3 = [{&lt;&lt;"from"&gt;&gt;, FromString} | DAttrs2],</font>
<font color=red>     0..|      DEl2 = #xmlel{name = &lt;&lt;"decline"&gt;&gt;, attrs = DAttrs3, children = DEls},</font>
<font color=red>     0..|      XEl2 = replace_subelement(XEl, DEl2),</font>
<font color=red>     0..|      Packet2 = replace_subelement(Packet, XEl2),</font>
<font color=red>     0..|      ejabberd_router:route(RoomJID, ToJID, Packet2).</font>
        |  
        |  %% @doc Given an element and a new subelement,
        |  %% replace the instance of the subelement in element with the new subelement.
        |  -spec replace_subelement(jlib:xmlel(), jlib:xmlel()) -&gt; jlib:xmlel().
        |  replace_subelement(XE = #xmlel{children = SubEls}, NewSubEl) -&gt;
<font color=red>     0..|      {_, NameNewSubEl, _, _} = NewSubEl,</font>
<font color=red>     0..|      SubEls2 = lists:keyreplace(NameNewSubEl, 2, SubEls, NewSubEl),</font>
<font color=red>     0..|      XE#xmlel{children = SubEls2}.</font>
        |  
        |  -spec send_error_only_occupants(binary(), jlib:xmlel(),
        |                                  binary() | nonempty_string(),
        |                                  ejabberd:jid(), ejabberd:jid()) -&gt; 'ok'.
        |  send_error_only_occupants(What, Packet, Lang, RoomJID, From)
        |    when is_binary(What) -&gt;
<font color=red>     0..|      ErrText = &lt;&lt;"Only occupants are allowed to send ",</font>
        |                  What/bytes, " to the conference"&gt;&gt;,
<font color=red>     0..|      Err = jlib:make_error_reply(Packet, ?ERRT_NOT_ACCEPTABLE(Lang, ErrText)),</font>
<font color=red>     0..|      ejabberd_router:route(RoomJID, From, Err).</font>
        |  
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  % Logging
        |  
        |  -spec add_to_log(atom(), any(), state()) -&gt; 'ok'.
        |  add_to_log(Type, Data, StateData)
        |    when Type == roomconfig_change_disabledlogging -&gt;
        |      %% When logging is disabled, the config change message must be logged:
<font color=red>     0..|      mod_muc_log:add_to_log(</font>
        |        StateData#state.server_host, roomconfig_change, Data,
        |        jid:to_binary(StateData#state.jid), make_opts(StateData));
        |  add_to_log(Type, Data, StateData) -&gt;
<font color=red>     0..|      case (StateData#state.config)#config.logging of</font>
        |      true -&gt;
<font color=red>     0..|          mod_muc_log:add_to_log(</font>
        |            StateData#state.server_host, Type, Data,
        |            jid:to_binary(StateData#state.jid), make_opts(StateData));
        |      false -&gt;
<font color=red>     0..|          ok</font>
        |      end.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Users number checking
        |  
        |  -spec tab_add_online_user(ejabberd:jid(), state()) -&gt; any().
        |  tab_add_online_user(JID, StateData) -&gt;
<font color=red>     0..|      {LUser, LServer, _} = jid:to_lower(JID),</font>
<font color=red>     0..|      US = {LUser, LServer},</font>
<font color=red>     0..|      Room = StateData#state.room,</font>
<font color=red>     0..|      Host = StateData#state.host,</font>
<font color=red>     0..|      catch ets:insert(</font>
        |          muc_online_users,
        |          #muc_online_users{us = US, room = Room, host = Host}).
        |  
        |  
        |  -spec tab_remove_online_user(ejabberd:simple_jid() | ejabberd:jid(), state()) -&gt; any().
        |  tab_remove_online_user(JID, StateData) -&gt;
<font color=red>     0..|      {LUser, LServer, _} = jid:to_lower(JID),</font>
<font color=red>     0..|      US = {LUser, LServer},</font>
<font color=red>     0..|      Room = StateData#state.room,</font>
<font color=red>     0..|      Host = StateData#state.host,</font>
<font color=red>     0..|      catch ets:delete_object(</font>
        |          muc_online_users,
        |          #muc_online_users{us = US, room = Room, host = Host}).
        |  
        |  
        |  -spec tab_count_user(ejabberd:jid()) -&gt; non_neg_integer().
        |  tab_count_user(JID) -&gt;
<font color=red>     0..|      {LUser, LServer, _} = jid:to_lower(JID),</font>
<font color=red>     0..|      US = {LUser, LServer},</font>
<font color=red>     0..|      case catch ets:select(</font>
        |           muc_online_users,
        |           [{#muc_online_users{us = US, _ = '_'}, [], [[]]}]) of
        |      Res when is_list(Res) -&gt;
<font color=red>     0..|          length(Res);</font>
        |      _ -&gt;
<font color=red>     0..|          0</font>
        |      end.
        |  
        |  element_size(El) -&gt;
<font color=red>     0..|      exml:xml_size(El).</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% Routing functions
        |  
        |  -spec route_message(routed_message(), state()) -&gt; state().
        |  route_message(#routed_message{allowed = true, type = &lt;&lt;"groupchat"&gt;&gt;,
        |      from = From, packet = Packet, lang = Lang}, StateData) -&gt;
<font color=red>     0..|      Activity = get_user_activity(From, StateData),</font>
<font color=red>     0..|      Now = now_to_usec(os:timestamp()),</font>
<font color=red>     0..|      MinMessageInterval = trunc(gen_mod:get_module_opt(</font>
        |          StateData#state.server_host,
        |          mod_muc, min_message_interval, 0) * 1000000),
<font color=red>     0..|      Size = element_size(Packet),</font>
<font color=red>     0..|      {MessageShaper, MessageShaperInterval} =</font>
        |          shaper:update(Activity#activity.message_shaper, Size),
<font color=red>     0..|      if</font>
        |          Activity#activity.message /= undefined -&gt;
<font color=red>     0..|              ErrText = &lt;&lt;"Traffic rate limit is exceeded"&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(</font>
        |                  Packet, ?ERRT_RESOURCE_CONSTRAINT(Lang, ErrText)),
<font color=red>     0..|              ejabberd_router:route(</font>
        |                  StateData#state.jid,
        |                  From, Err),
<font color=red>     0..|              StateData;</font>
        |          Now &gt;= Activity#activity.message_time + MinMessageInterval,
        |              MessageShaperInterval == 0 -&gt;
<font color=red>     0..|              {RoomShaper, RoomShaperInterval} =</font>
        |                  shaper:update(StateData#state.room_shaper, Size),
<font color=red>     0..|              RoomQueueEmpty = queue:is_empty(</font>
        |                  StateData#state.room_queue),
<font color=red>     0..|              if</font>
        |                  RoomShaperInterval == 0, RoomQueueEmpty -&gt;
<font color=red>     0..|                      NewActivity = Activity#activity{</font>
        |                              message_time = Now,
        |                              message_shaper = MessageShaper},
<font color=red>     0..|                      StateData1 = store_user_activity(</font>
        |                          From, NewActivity, StateData),
<font color=red>     0..|                      StateData2 =</font>
        |                          StateData1#state{room_shaper = RoomShaper},
<font color=red>     0..|                      {next_state, normal_state, StateData3} =</font>
        |                          process_groupchat_message(From, Packet, StateData2),
<font color=red>     0..|                      StateData3;</font>
        |                  true -&gt;
<font color=red>     0..|                      StateData1 =</font>
        |                      if
        |                          RoomQueueEmpty -&gt;
<font color=red>     0..|                              erlang:send_after(RoomShaperInterval, self(),</font>
        |                                  process_room_queue),
<font color=red>     0..|                          StateData#state{room_shaper = RoomShaper};</font>
        |                          true -&gt;
<font color=red>     0..|                              StateData</font>
        |                      end,
<font color=red>     0..|                      NewActivity = Activity#activity{</font>
        |                          message_time = Now,
        |                          message_shaper = MessageShaper,
        |                          message = Packet},
<font color=red>     0..|                      RoomQueue = queue:in(</font>
        |                          {message, From},
        |                          StateData#state.room_queue),
<font color=red>     0..|                      StateData2 = store_user_activity(</font>
        |                          From, NewActivity, StateData1),
<font color=red>     0..|                      StateData3 = StateData2#state{room_queue = RoomQueue},</font>
<font color=red>     0..|                      StateData3</font>
        |              end;
        |          true -&gt;
<font color=red>     0..|              MessageInterval =</font>
        |                  (Activity#activity.message_time +
        |                  MinMessageInterval - Now) div 1000,
<font color=red>     0..|                  Interval = lists:max([MessageInterval,MessageShaperInterval]),</font>
<font color=red>     0..|                  erlang:send_after(</font>
        |                      Interval, self(), {process_user_message, From}),
<font color=red>     0..|                  NewActivity = Activity#activity{</font>
        |                          message = Packet,
        |                          message_shaper = MessageShaper},
<font color=red>     0..|                  StateData1 = store_user_activity(From, NewActivity, StateData),</font>
<font color=red>     0..|                  StateData1</font>
        |      end;
        |  route_message(#routed_message{allowed = true, type = &lt;&lt;"error"&gt;&gt;, from = From,
        |      packet = Packet, lang = Lang}, StateData) -&gt;
<font color=red>     0..|      case is_user_online(From, StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              ErrorText = &lt;&lt;"This participant is kicked from the room because he sent an error message"&gt;&gt;,</font>
<font color=red>     0..|              NewState = expulse_participant(Packet, From, StateData, translate:translate(Lang, ErrorText)),</font>
<font color=red>     0..|              NewState;</font>
        |          _ -&gt;
<font color=red>     0..|              StateData</font>
        |      end;
        |  route_message(#routed_message{allowed = true, type = &lt;&lt;"chat"&gt;&gt;, from = From, packet = Packet,
        |      lang = Lang}, StateData) -&gt;
<font color=red>     0..|      ErrText = &lt;&lt;"It is not allowed to send private messages to the conference"&gt;&gt;,</font>
<font color=red>     0..|      Err = jlib:make_error_reply(</font>
        |          Packet, ?ERRT_NOT_ACCEPTABLE(Lang, ErrText)),
<font color=red>     0..|      ejabberd_router:route(</font>
        |          StateData#state.jid,
        |          From, Err),
<font color=red>     0..|      StateData;</font>
        |  route_message(#routed_message{allowed = true, type = Type, from = From,
        |                                packet = #xmlel{name = &lt;&lt;"message"&gt;&gt;,
        |                                                children = Els} = Packet, lang = Lang},
        |                StateData) when (Type == &lt;&lt;&gt;&gt; orelse Type == &lt;&lt;"normal"&gt;&gt;) -&gt;
        |  
<font color=red>     0..|      Invite = xml:get_path_s(Packet, [{elem, &lt;&lt;"x"&gt;&gt;}, {elem, &lt;&lt;"invite"&gt;&gt;}]),</font>
<font color=red>     0..|      case Invite of</font>
        |          &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|              AppType = check_voice_approval(From, Els, Lang, StateData),</font>
<font color=red>     0..|              route_voice_approval(AppType, From, Packet, Lang, StateData);</font>
        |          _ -&gt;
<font color=red>     0..|              InType = check_invitation(From, Els, Lang, StateData),</font>
<font color=red>     0..|              route_invitation(InType, From, Packet, Lang, StateData)</font>
        |      end;
        |  route_message(#routed_message{allowed = true, from = From, packet = Packet,
        |                                lang = Lang}, StateData) -&gt;
<font color=red>     0..|      ErrText = &lt;&lt;"Improper message type"&gt;&gt;,</font>
<font color=red>     0..|      Err = jlib:make_error_reply(Packet, ?ERRT_NOT_ACCEPTABLE(Lang, ErrText)),</font>
<font color=red>     0..|      ejabberd_router:route(StateData#state.jid,</font>
        |                            From, Err),
<font color=red>     0..|      StateData;</font>
        |  route_message(#routed_message{type = &lt;&lt;"error"&gt;&gt;}, StateData) -&gt;
<font color=red>     0..|      StateData;</font>
        |  route_message(#routed_message{from = From, packet = Packet, lang = Lang},
        |                StateData) -&gt;
<font color=red>     0..|      handle_roommessage_from_nonparticipant(Packet, Lang, StateData, From),</font>
<font color=red>     0..|      StateData.</font>
        |  
        |  
        |  -spec route_error(mod_muc:nick(), ejabberd:jid(), jlib:xmlel(), state()) -&gt; state().
        |  route_error(Nick, From, Error, StateData) -&gt;
        |      %% TODO: s/Nick/&lt;&lt;&gt;&gt;/
<font color=red>     0..|      ejabberd_router:route(jid:replace_resource(StateData#state.jid, Nick),</font>
        |                            From, Error),
<font color=red>     0..|      StateData.</font>
        |  
        |  
        |  -spec route_voice_approval('ok' | {'error',jlib:xmlel()} | {'form',binary()}
        |          | {'role', binary(), binary()}, ejabberd:jid(), jlib:xmlel(),
        |          ejabberd:lang(), state()) -&gt; state().
        |  route_voice_approval({error, ErrType}, From, Packet, _Lang, StateData) -&gt;
<font color=red>     0..|      ejabberd_router:route(StateData#state.jid, From,</font>
        |                            jlib:make_error_reply(Packet, ErrType)),
<font color=red>     0..|      StateData;</font>
        |  route_voice_approval({form, RoleName}, From, _Packet, _Lang, StateData) -&gt;
<font color=red>     0..|      {Nick, _} = get_participant_data(From, StateData),</font>
<font color=red>     0..|      ApprovalForm = jlib:make_voice_approval_form(From, Nick, RoleName),</font>
<font color=red>     0..|      F = fun({_, Info}) -&gt;</font>
<font color=red>     0..|                  ejabberd_router:route(StateData#state.jid, Info#user.jid,</font>
        |                                        ApprovalForm)
        |          end,
<font color=red>     0..|      lists:foreach(F, search_role(moderator, StateData)),</font>
<font color=red>     0..|      StateData;</font>
        |  route_voice_approval({role, BRole, Nick}, From, Packet, Lang, StateData) -&gt;
<font color=red>     0..|      Items = [#xmlel{name = &lt;&lt;"item"&gt;&gt;,</font>
        |                      attrs = [{&lt;&lt;"role"&gt;&gt;, BRole},
        |                               {&lt;&lt;"nick"&gt;&gt;, Nick}]}],
<font color=red>     0..|      case process_admin_items_set(From, Items, Lang, StateData) of</font>
<font color=red>     0..|          {result, _Res, SD1} -&gt; SD1;</font>
        |          {error, Error} -&gt;
<font color=red>     0..|              ejabberd_router:route(StateData#state.jid, From,</font>
        |                                    jlib:make_error_reply(Packet, Error)),
<font color=red>     0..|              StateData</font>
        |      end;
        |  route_voice_approval(_Type, From, Packet, _Lang, StateData) -&gt;
<font color=red>     0..|      ejabberd_router:route(StateData#state.jid, From,</font>
        |                            jlib:make_error_reply(Packet, ?ERR_BAD_REQUEST)),
<font color=red>     0..|      StateData.</font>
        |  
        |  
        |  -spec route_invitation(InvitationsOrError,
        |                         From, Packet, Lang, state()) -&gt; state() when
        |        InvitationsOrError :: {'error', jlib:xmlcdata() | jlib:xmlel()}
        |                            | {'ok', ejabberd:jid()},
        |        From :: ejabberd:simple_jid() | ejabberd:jid(),
        |        Packet :: jlib:xmlel(),
        |        Lang :: ejabberd:lang().
        |  route_invitation({error, Error}, From, Packet, _Lang, StateData) -&gt;
<font color=red>     0..|      Err = jlib:make_error_reply(Packet, Error),</font>
<font color=red>     0..|      ejabberd_router:route(StateData#state.jid, From, Err),</font>
<font color=red>     0..|      StateData;</font>
        |  route_invitation({ok, IJIDs}, _From, _Packet, _Lang, StateData0) -&gt;
<font color=red>     0..|      Config = StateData0#state.config,</font>
<font color=red>     0..|      case Config#config.members_only of</font>
        |          true -&gt;
<font color=red>     0..|              lists:foldl(</font>
        |                fun(IJID, StateData) -&gt;
<font color=red>     0..|                        case get_affiliation(IJID, StateData) of</font>
        |                            none -&gt;
<font color=red>     0..|                                NSD = set_affiliation(</font>
        |                                        IJID,
        |                                        member,
        |                                        StateData),
<font color=red>     0..|                                case (NSD#state.config)#config.persistent of</font>
        |                                    true -&gt;
<font color=red>     0..|                                        mod_muc:store_room(</font>
        |                                          NSD#state.host,
        |                                          NSD#state.room,
        |                                          make_opts(NSD));
        |                                    _ -&gt;
<font color=red>     0..|                                        ok</font>
        |                                end,
<font color=red>     0..|                                NSD;</font>
        |                            _ -&gt;
<font color=red>     0..|                                StateData</font>
        |                        end
        |                end, StateData0, IJIDs);
        |          false -&gt;
<font color=red>     0..|              StateData0</font>
        |      end.
        |  
        |  
        |  -spec route_iq(routed_iq(), state()) -&gt; {ok | stop, state()}.
        |  route_iq(#routed_iq{iq = #iq{type = Type, xmlns = ?NS_MUC_ADMIN, lang = Lang,
        |      sub_el = SubEl}, from = From} = Routed, StateData) -&gt;
<font color=red>     0..|      Res = process_iq_admin(From, Type, Lang, SubEl, StateData),</font>
<font color=red>     0..|      do_route_iq(Res, Routed, StateData);</font>
        |  route_iq(#routed_iq{iq = #iq{type = Type, xmlns = ?NS_MUC_OWNER, lang = Lang,
        |      sub_el = SubEl}, from = From} = Routed, StateData) -&gt;
<font color=red>     0..|      Res = process_iq_owner(From, Type, Lang, SubEl, StateData),</font>
<font color=red>     0..|      do_route_iq(Res, Routed, StateData);</font>
        |  route_iq(#routed_iq{iq = #iq{type = Type, xmlns = ?NS_DISCO_INFO, lang = Lang},
        |      from = From} = Routed, StateData) -&gt;
<font color=red>     0..|      Res = process_iq_disco_info(From, Type, Lang, StateData),</font>
<font color=red>     0..|      do_route_iq(Res, Routed, StateData);</font>
        |  route_iq(#routed_iq{iq = #iq{type = Type, xmlns = ?NS_DISCO_ITEMS, lang = Lang},
        |      from = From} = Routed, StateData) -&gt;
<font color=red>     0..|      Res = process_iq_disco_items(From, Type, Lang, StateData),</font>
<font color=red>     0..|      do_route_iq(Res, Routed, StateData);</font>
        |  route_iq(#routed_iq{iq = IQ = #iq{}, packet = Packet, from = From},
        |           #state{host = Host, jid = RoomJID} = StateData) -&gt;
        |      %% Custom IQ, addressed to this room's JID.
<font color=red>     0..|      case mod_muc_iq:process_iq(Host, From, RoomJID, IQ) of</font>
<font color=red>     0..|          ignore -&gt; ok;</font>
        |          error -&gt;
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERR_FEATURE_NOT_IMPLEMENTED),</font>
<font color=red>     0..|              ejabberd_router:route(RoomJID, From, Err);</font>
        |          ResIQ -&gt;
<font color=red>     0..|              ejabberd_router:route(RoomJID, From, jlib:iq_to_xml(ResIQ))</font>
        |      end,
<font color=red>     0..|      {ok, StateData};</font>
        |  route_iq(#routed_iq{iq = reply}, StateData) -&gt;
<font color=red>     0..|      {ok, StateData};</font>
        |  route_iq(#routed_iq{packet = Packet, from = From}, StateData) -&gt;
<font color=red>     0..|      Err = jlib:make_error_reply(</font>
        |          Packet, ?ERR_FEATURE_NOT_IMPLEMENTED),
<font color=red>     0..|      ejabberd_router:route(StateData#state.jid, From, Err),</font>
<font color=red>     0..|      {ok, StateData}.</font>
        |  
        |  
        |  -spec do_route_iq({result, [jlib:xmlel()], state()} | {error, jlib:xmlel()},
        |                    routed_iq(), state()) -&gt; {ok | stop, state()}.
        |  do_route_iq(Res1, #routed_iq{iq = #iq{xmlns = XMLNS, sub_el = SubEl} = IQ,
        |      from = From}, StateData) -&gt;
<font color=red>     0..|      {IQRes, RoutingResult} = case Res1 of</font>
        |          {result, Res, SD} -&gt;
<font color=red>     0..|              {</font>
        |               IQ#iq{type = result,
        |                  sub_el = [#xmlel{name = &lt;&lt;"query"&gt;&gt;,
        |                                   attrs = [{&lt;&lt;"xmlns"&gt;&gt;, XMLNS}],
        |                                   children = Res}]},
        |               case SD of
<font color=red>     0..|                   stop -&gt; {stop, StateData};</font>
<font color=red>     0..|                   _ -&gt; {ok, SD}</font>
        |               end
        |              };
        |          {error, Error} -&gt;
<font color=red>     0..|              {</font>
        |               IQ#iq{type = error, sub_el = [SubEl, Error]},
        |               {ok, StateData}
        |              }
        |      end,
<font color=red>     0..|      ejabberd_router:route(StateData#state.jid, From,</font>
        |          jlib:iq_to_xml(IQRes)),
<font color=red>     0..|      RoutingResult.</font>
        |  
        |  
        |  -spec route_nick_message(routed_nick_message(), state()) -&gt; state().
        |  route_nick_message(#routed_nick_message{decide = {expulse_sender, Reason},
        |      packet = Packet, lang = Lang, from = From}, StateData) -&gt;
<font color=red>     0..|      ?DEBUG(Reason, []),</font>
<font color=red>     0..|      ErrorText = &lt;&lt;"This participant is kicked from the room because he",</font>
        |                    "sent an error message to another participant"&gt;&gt;,
<font color=red>     0..|      expulse_participant(Packet, From, StateData, translate:translate(Lang, ErrorText));</font>
        |  route_nick_message(#routed_nick_message{decide = forget_message}, StateData) -&gt;
<font color=red>     0..|      StateData;</font>
        |  route_nick_message(#routed_nick_message{decide = continue_delivery, allow_pm = true,
        |      online = true, packet = Packet, from = From, type = &lt;&lt;"groupchat"&gt;&gt;,
        |      lang = Lang, nick = ToNick}, StateData) -&gt;
<font color=red>     0..|      ErrText = &lt;&lt;"It is not allowed to send private messages of type groupchat"&gt;&gt;,</font>
<font color=red>     0..|      Err = jlib:make_error_reply(</font>
        |          Packet, ?ERRT_BAD_REQUEST(Lang, ErrText)),
<font color=red>     0..|      ejabberd_router:route(</font>
        |          jid:replace_resource(
        |         StateData#state.jid,
        |         ToNick),
        |          From, Err),
<font color=red>     0..|      StateData;</font>
        |  route_nick_message(#routed_nick_message{decide = continue_delivery, allow_pm = true,
        |      online = true, packet = Packet, from = From,
        |      lang = Lang, nick = ToNick, jid = false}, StateData) -&gt;
<font color=red>     0..|      ErrText = &lt;&lt;"Recipient is not in the conference room"&gt;&gt;,</font>
<font color=red>     0..|      Err = jlib:make_error_reply(</font>
        |          Packet, ?ERRT_ITEM_NOT_FOUND(Lang, ErrText)),
<font color=red>     0..|      ejabberd_router:route(</font>
        |          jid:replace_resource(
        |         StateData#state.jid,
        |         ToNick),
        |          From, Err),
<font color=red>     0..|      StateData;</font>
        |  route_nick_message(#routed_nick_message{decide = continue_delivery, allow_pm = true,
        |      online = true, packet = Packet, from = From, jid = ToJID}, StateData) -&gt;
<font color=red>     0..|      {ok, #user{nick = FromNick}} = ?DICT:find(jid:to_lower(From),</font>
        |          StateData#state.users),
<font color=red>     0..|      ejabberd_router:route(</font>
        |          jid:replace_resource(StateData#state.jid, FromNick), ToJID, Packet),
<font color=red>     0..|      StateData;</font>
        |  route_nick_message(#routed_nick_message{decide = continue_delivery,
        |                                          allow_pm = true,
        |                                          online = false} = Routed, StateData) -&gt;
        |      #routed_nick_message{packet = Packet, from = From,
<font color=red>     0..|                           lang = Lang, nick = ToNick} = Routed,</font>
<font color=red>     0..|      RoomJID = jid:replace_resource(StateData#state.jid, ToNick),</font>
<font color=red>     0..|      send_error_only_occupants(&lt;&lt;"messages"&gt;&gt;, Packet, Lang, RoomJID, From),</font>
<font color=red>     0..|      StateData;</font>
        |  route_nick_message(#routed_nick_message{decide = continue_delivery, allow_pm = false,
        |      packet = Packet, from = From,
        |      lang = Lang, nick = ToNick}, StateData) -&gt;
<font color=red>     0..|      ErrText = &lt;&lt;"It is not allowed to send private messages"&gt;&gt;,</font>
<font color=red>     0..|      Err = jlib:make_error_reply(</font>
        |          Packet, ?ERRT_FORBIDDEN(Lang, ErrText)),
<font color=red>     0..|      ejabberd_router:route(</font>
        |          jid:replace_resource(StateData#state.jid, ToNick), From, Err),
<font color=red>     0..|      StateData.</font>
        |  
        |  
        |  -spec route_nick_iq(routed_nick_iq(), state()) -&gt; 'ok'.
        |  route_nick_iq(#routed_nick_iq{allow_query = true, online = {true, _, _}, jid = false,
        |      iq = reply}, _StateData) -&gt;
<font color=red>     0..|      ok;</font>
        |  route_nick_iq(#routed_nick_iq{allow_query = true, online = {true, _, _}, jid = false,
        |      packet = Packet, lang = Lang, from = From, nick = ToNick}, StateData) -&gt;
<font color=red>     0..|      ErrText = &lt;&lt;"Recipient is not in the conference room"&gt;&gt;,</font>
<font color=red>     0..|      Err = jlib:make_error_reply(</font>
        |          Packet, ?ERRT_ITEM_NOT_FOUND(Lang, ErrText)),
<font color=red>     0..|      ejabberd_router:route(</font>
        |          jid:replace_resource(
        |         StateData#state.jid, ToNick),
        |          From, Err);
        |  route_nick_iq(#routed_nick_iq{allow_query = true, online = {true, NewId, FromFull},
        |      jid = ToJID, packet = Packet, stanza = StanzaId}, StateData) -&gt;
<font color=red>     0..|      {ok, #user{nick = FromNick}} = ?DICT:find(jid:to_lower(FromFull),</font>
        |          StateData#state.users),
<font color=red>     0..|      {ToJID2, Packet2} = handle_iq_vcard(FromFull, ToJID,</font>
        |          StanzaId, NewId,Packet),
<font color=red>     0..|      ejabberd_router:route(</font>
        |          jid:replace_resource(StateData#state.jid, FromNick),
        |          ToJID2, Packet2);
        |  route_nick_iq(#routed_nick_iq{online = {false, _, _}, iq = reply}, _StateData) -&gt;
<font color=red>     0..|      ok;</font>
        |  route_nick_iq(#routed_nick_iq{online = {false, _, _}, from = From, nick = ToNick,
        |                                packet = Packet, lang = Lang}, StateData) -&gt;
<font color=red>     0..|      RoomJID = jid:replace_resource(StateData#state.jid, ToNick),</font>
<font color=red>     0..|      send_error_only_occupants(&lt;&lt;"queries"&gt;&gt;, Packet, Lang, RoomJID, From);</font>
        |  route_nick_iq(#routed_nick_iq{iq = reply}, _StateData) -&gt;
<font color=red>     0..|      ok;</font>
        |  route_nick_iq(#routed_nick_iq{packet = Packet, lang = Lang, nick = ToNick,
        |                                from = From}, StateData) -&gt;
<font color=red>     0..|      ErrText = &lt;&lt;"Queries to the conference members are "</font>
        |                  "not allowed in this room"&gt;&gt;,
<font color=red>     0..|      Err = jlib:make_error_reply(Packet, ?ERRT_NOT_ALLOWED(Lang, ErrText)),</font>
<font color=red>     0..|      RouteFrom = jid:replace_resource(StateData#state.jid, ToNick),</font>
<font color=red>     0..|      ejabberd_router:route(RouteFrom, From, Err).</font>
        |  
        |  
        |  -spec decode_reason(jlib:xmlel()) -&gt; any().
        |  decode_reason(Elem) -&gt;
<font color=red>     0..|      xml:get_path_s(Elem, [{elem, &lt;&lt;"reason"&gt;&gt;}, cdata]).</font>
        |  
        |  
        |  -spec xfield(binary(), any(), binary(), binary(), ejabberd:lang()) -&gt; jlib:xmlel().
        |  xfield(Type, Label, Var, Val, Lang) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"field"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"type"&gt;&gt;, Type},
        |                           {&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, Label)},
        |                           {&lt;&lt;"var"&gt;&gt;, Var}],
        |             children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                children = [#xmlcdata{content = Val}]}]}.
        |  
        |  
        |  -spec boolxfield(any(), binary(), any(), ejabberd:lang()) -&gt; jlib:xmlel().
        |  boolxfield(Label, Var, Val, Lang) -&gt;
<font color=red>     0..|      xfield(&lt;&lt;"boolean"&gt;&gt;, Label, Var,</font>
        |          case Val of
<font color=red>     0..|              true -&gt; &lt;&lt;"1"&gt;&gt;;</font>
<font color=red>     0..|              _ -&gt; &lt;&lt;"0"&gt;&gt;</font>
        |          end, Lang).
        |  
        |  stringxfield(Label, Var, Val, Lang) -&gt;
<font color=red>     0..|      xfield(&lt;&lt;"text-single"&gt;&gt;, Label, Var, Val, Lang).</font>
        |  
        |  privatexfield(Label, Var, Val, Lang) -&gt;
<font color=red>     0..|      xfield(&lt;&lt;"text-private"&gt;&gt;, Label, Var, Val, Lang).</font>
        |  
        |  %% jidxfield(Label, Var, Val, Lang) -&gt;
        |  %%     xfield(&lt;&lt;"jid-single"&gt;&gt;, Label, Var, Val, Lang).
        |  %%
        |  %% jidmultixfield(Label, Var, JIDList, Lang) -&gt;
        |  %%     #xmlel{name = &lt;&lt;"field"&gt;&gt;,
        |  %%            attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"jid-multi"&gt;&gt;},
        |  %%                     {&lt;&lt;"label"&gt;&gt;, translate:translate(Lang, Label)},
        |  %%                     {&lt;&lt;"var"&gt;&gt;, Var}],
        |  %%            children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |  %%                               children = [#xmlcdata{content = jlib:jid_to_binary(JID)}]}
        |  %%                        || JID &lt;- JIDList]}.
        |  
</pre>
</body>
</html>
