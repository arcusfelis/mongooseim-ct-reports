<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/travis/build/esl/MongooseIM/apps/ejabberd/logs/ct_run.test@testing-gce-39759cef-e506-4525-ad63-8d26cb539700.c.eco-emissary-99515.internal.2016-01-26_09.43.10/supervisor2.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/esl/MongooseIM/apps/ejabberd/ebin/../src/supervisor2.erl by COVER 2016-01-26 at 09:44:12

****************************************************************************

        |  %% This file is a copy of supervisor.erl from the R16B Erlang/OTP
        |  %% distribution, with the following modifications:
        |  %%
        |  %% 1) the module name is supervisor2
        |  %%
        |  %% 2) a find_child/2 utility function has been added
        |  %%
        |  %% 3) Added an 'intrinsic' restart type. Like the transient type, this
        |  %%    type means the child should only be restarted if the child exits
        |  %%    abnormally. Unlike the transient type, if the child exits
        |  %%    normally, the supervisor itself also exits normally. If the
        |  %%    child is a supervisor and it exits normally (i.e. with reason of
        |  %%    'shutdown') then the child's parent also exits normally.
        |  %%
        |  %% 4) child specifications can contain, as the restart type, a tuple
        |  %%    {permanent, Delay} | {transient, Delay} | {intrinsic, Delay}
        |  %%    where Delay &gt;= 0 (see point (4) below for intrinsic). The delay,
        |  %%    in seconds, indicates what should happen if a child, upon being
        |  %%    restarted, exceeds the MaxT and MaxR parameters. Thus, if a
        |  %%    child exits, it is restarted as normal. If it exits sufficiently
        |  %%    quickly and often to exceed the boundaries set by the MaxT and
        |  %%    MaxR parameters, and a Delay is specified, then rather than
        |  %%    stopping the supervisor, the supervisor instead continues and
        |  %%    tries to start up the child again, Delay seconds later.
        |  %%
        |  %%    Note that you can never restart more frequently than the MaxT
        |  %%    and MaxR parameters allow: i.e. you must wait until *both* the
        |  %%    Delay has passed *and* the MaxT and MaxR parameters allow the
        |  %%    child to be restarted.
        |  %%
        |  %%    Also note that the Delay is a *minimum*. There is no guarantee
        |  %%    that the child will be restarted within that time, especially if
        |  %%    other processes are dying and being restarted at the same time -
        |  %%    essentially we have to wait for the delay to have passed and for
        |  %%    the MaxT and MaxR parameters to permit the child to be
        |  %%    restarted. This may require waiting for longer than Delay.
        |  %%
        |  %%    Sometimes, you may wish for a transient or intrinsic child to
        |  %%    exit abnormally so that it gets restarted, but still log
        |  %%    nothing. gen_server will log any exit reason other than
        |  %%    'normal', 'shutdown' or {'shutdown', _}. Thus the exit reason of
        |  %%    {'shutdown', 'restart'} is interpreted to mean you wish the
        |  %%    child to be restarted according to the delay parameters, but
        |  %%    gen_server will not log the error. Thus from gen_server's
        |  %%    perspective it's a normal exit, whilst from supervisor's
        |  %%    perspective, it's an abnormal exit.
        |  %%
        |  %% 5) normal, and {shutdown, _} exit reasons are all treated the same
        |  %%    (i.e. are regarded as normal exits)
        |  %%
        |  %% All modifications are (C) 2010-2013 GoPivotal, Inc.
        |  %%
        |  %% %CopyrightBegin%
        |  %%
        |  %% Copyright Ericsson AB 1996-2012. All Rights Reserved.
        |  %%
        |  %% The contents of this file are subject to the Erlang Public License,
        |  %% Version 1.1, (the "License"); you may not use this file except in
        |  %% compliance with the License. You should have received a copy of the
        |  %% Erlang Public License along with this software. If not, it can be
        |  %% retrieved online at http://www.erlang.org/.
        |  %%
        |  %% Software distributed under the License is distributed on an "AS IS"
        |  %% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
        |  %% the License for the specific language governing rights and limitations
        |  %% under the License.
        |  %%
        |  %% %CopyrightEnd%
        |  %%
        |  -module(supervisor2).
        |  
        |  -behaviour(gen_server).
        |  
        |  %% External exports
        |  -export([start_link/2, start_link/3,
        |  	 start_child/2, restart_child/2,
        |  	 delete_child/2, terminate_child/2,
        |  	 which_children/1, count_children/1,
        |  	 find_child/2, check_childspecs/1]).
        |  
        |  %% Internal exports
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2,
        |  	 terminate/2, code_change/3]).
        |  -export([try_again_restart/3]).
        |  
        |  %%--------------------------------------------------------------------------
        |  -ifdef(use_specs).
        |  -export_type([child_spec/0, startchild_ret/0, strategy/0, sup_name/0]).
        |  -endif.
        |  %%--------------------------------------------------------------------------
        |  
        |  -ifdef(use_specs).
        |  -type child()    :: 'undefined' | pid().
        |  -type child_id() :: term().
        |  -type mfargs()   :: {M :: module(), F :: atom(), A :: [term()] | undefined}.
        |  -type modules()  :: [module()] | 'dynamic'.
        |  -type delay()    :: non_neg_integer().
        |  -type restart()  :: 'permanent' | 'transient' | 'temporary' | 'intrinsic' | {'permanent', delay()} | {'transient', delay()} | {'intrinsic', delay()}.
        |  -type shutdown() :: 'brutal_kill' | timeout().
        |  -type worker()   :: 'worker' | 'supervisor'.
        |  -type sup_name() :: {'local', Name :: atom()} | {'global', Name :: atom()}.
        |  -type sup_ref()  :: (Name :: atom())
        |                    | {Name :: atom(), Node :: node()}
        |                    | {'global', Name :: atom()}
        |                    | pid().
        |  -type child_spec() :: {Id :: child_id(),
        |                         StartFunc :: mfargs(),
        |                         Restart :: restart(),
        |                         Shutdown :: shutdown(),
        |                         Type :: worker(),
        |                         Modules :: modules()}.
        |  
        |  -type strategy() :: 'one_for_all' | 'one_for_one'
        |                    | 'rest_for_one' | 'simple_one_for_one'.
        |  -endif.
        |  
        |  %%--------------------------------------------------------------------------
        |  
        |  -ifdef(use_specs).
        |  -record(child, {% pid is undefined when child is not running
        |  	        pid = undefined :: child() | {restarting,pid()} | [pid()],
        |  		name            :: child_id(),
        |  		mfargs          :: mfargs(),
        |  		restart_type    :: restart(),
        |  		shutdown        :: shutdown(),
        |  		child_type      :: worker(),
        |  		modules = []    :: modules()}).
        |  -type child_rec() :: #child{}.
        |  -else.
        |  -record(child, {
        |  	        pid = undefined,
        |  		name,
        |  		mfargs,
        |  		restart_type,
        |  		shutdown,
        |  		child_type,
        |  		modules = []}).
        |  -endif.
        |  
        |  -define(DICT, dict).
        |  -define(SETS, sets).
        |  -define(SET, set).
        |  
        |  -ifdef(use_specs).
        |  -record(state, {name,
        |  		strategy               :: strategy(),
        |  		children = []          :: [child_rec()],
        |  		dynamics               :: ?DICT() | ?SET(),
        |  		intensity              :: non_neg_integer(),
        |  		period                 :: pos_integer(),
        |  		restarts = [],
        |  	        module,
        |  	        args}).
        |  -type state() :: #state{}.
        |  -else.
        |  -record(state, {name,
        |  		strategy,
        |  		children = [],
        |  		dynamics,
        |  		intensity,
        |  		period,
        |  		restarts = [],
        |  	        module,
        |  	        args}).
        |  -endif.
        |  
        |  -define(is_simple(State), State#state.strategy =:= simple_one_for_one).
        |  -define(is_permanent(R), ((R =:= permanent) orelse
        |                            (is_tuple(R) andalso
        |                             tuple_size(R) == 2 andalso
        |                             element(1, R) =:= permanent))).
        |  -define(is_explicit_restart(R),
        |          R == {shutdown, restart}).
        |  
        |  -ifdef(use_specs).
        |  -callback init(Args :: term()) -&gt;
        |      {ok, {{RestartStrategy :: strategy(),
        |             MaxR            :: non_neg_integer(),
        |             MaxT            :: non_neg_integer()},
        |             [ChildSpec :: child_spec()]}}
        |      | ignore.
        |  -endif.
        |  -define(restarting(_Pid_), {restarting,_Pid_}).
        |  
        |  %%% ---------------------------------------------------
        |  %%% This is a general process supervisor built upon gen_server.erl.
        |  %%% Servers/processes should/could also be built using gen_server.erl.
        |  %%% SupName = {local, atom()} | {global, atom()}.
        |  %%% ---------------------------------------------------
        |  -ifdef(use_specs).
        |  -type startlink_err() :: {'already_started', pid()}
        |                           | {'shutdown', term()}
        |                           | term().
        |  -type startlink_ret() :: {'ok', pid()} | 'ignore' | {'error', startlink_err()}.
        |  
        |  -spec start_link(Module, Args) -&gt; startlink_ret() when
        |        Module :: module(),
        |        Args :: term().
        |  
        |  -endif.
        |  start_link(Mod, Args) -&gt;
<font color=red>     0..|      gen_server:start_link(?MODULE, {self, Mod, Args}, []).</font>
        |   
        |  -ifdef(use_specs).
        |  -spec start_link(SupName, Module, Args) -&gt; startlink_ret() when
        |        SupName :: sup_name(),
        |        Module :: module(),
        |        Args :: term().
        |  -endif.
        |  start_link(SupName, Mod, Args) -&gt;
<font color=red>     0..|      gen_server:start_link(SupName, ?MODULE, {SupName, Mod, Args}, []).</font>
        |   
        |  %%% ---------------------------------------------------
        |  %%% Interface functions.
        |  %%% ---------------------------------------------------
        |  -ifdef(use_specs).
        |  -type startchild_err() :: 'already_present'
        |  			| {'already_started', Child :: child()} | term().
        |  -type startchild_ret() :: {'ok', Child :: child()}
        |                          | {'ok', Child :: child(), Info :: term()}
        |  			| {'error', startchild_err()}.
        |  
        |  -spec start_child(SupRef, ChildSpec) -&gt; startchild_ret() when
        |        SupRef :: sup_ref(),
        |        ChildSpec :: child_spec() | (List :: [term()]).
        |  -endif.
        |  start_child(Supervisor, ChildSpec) -&gt;
<font color=red>     0..|      call(Supervisor, {start_child, ChildSpec}).</font>
        |  
        |  -ifdef(use_specs).
        |  -spec restart_child(SupRef, Id) -&gt; Result when
        |        SupRef :: sup_ref(),
        |        Id :: child_id(),
        |        Result :: {'ok', Child :: child()}
        |                | {'ok', Child :: child(), Info :: term()}
        |                | {'error', Error},
        |        Error :: 'running' | 'restarting' | 'not_found' | 'simple_one_for_one' |
        |  	       term().
        |  -endif.
        |  restart_child(Supervisor, Name) -&gt;
<font color=red>     0..|      call(Supervisor, {restart_child, Name}).</font>
        |  
        |  -ifdef(use_specs).
        |  -spec delete_child(SupRef, Id) -&gt; Result when
        |        SupRef :: sup_ref(),
        |        Id :: child_id(),
        |        Result :: 'ok' | {'error', Error},
        |        Error :: 'running' | 'restarting' | 'not_found' | 'simple_one_for_one'.
        |  -endif.
        |  delete_child(Supervisor, Name) -&gt;
<font color=red>     0..|      call(Supervisor, {delete_child, Name}).</font>
        |  
        |  %%-----------------------------------------------------------------
        |  %% Func: terminate_child/2
        |  %% Returns: ok | {error, Reason}
        |  %%          Note that the child is *always* terminated in some
        |  %%          way (maybe killed).
        |  %%-----------------------------------------------------------------
        |  -ifdef(use_specs).
        |  -spec terminate_child(SupRef, Id) -&gt; Result when
        |        SupRef :: sup_ref(),
        |        Id :: pid() | child_id(),
        |        Result :: 'ok' | {'error', Error},
        |        Error :: 'not_found' | 'simple_one_for_one'.
        |  -endif.
        |  terminate_child(Supervisor, Name) -&gt;
<font color=red>     0..|      call(Supervisor, {terminate_child, Name}).</font>
        |  
        |  -ifdef(use_specs).
        |  -spec which_children(SupRef) -&gt; [{Id,Child,Type,Modules}] when
        |        SupRef :: sup_ref(),
        |        Id :: child_id() | undefined,
        |        Child :: child() | 'restarting',
        |        Type :: worker(),
        |        Modules :: modules().
        |  -endif.
        |  which_children(Supervisor) -&gt;
<font color=red>     0..|      call(Supervisor, which_children).</font>
        |  
        |  -ifdef(use_specs).
        |  -spec count_children(SupRef) -&gt; PropListOfCounts when
        |        SupRef :: sup_ref(),
        |        PropListOfCounts :: [Count],
        |        Count :: {specs, ChildSpecCount :: non_neg_integer()}
        |               | {active, ActiveProcessCount :: non_neg_integer()}
        |               | {supervisors, ChildSupervisorCount :: non_neg_integer()}
        |               |{workers, ChildWorkerCount :: non_neg_integer()}.
        |  -endif.
        |  count_children(Supervisor) -&gt;
<font color=red>     0..|      call(Supervisor, count_children).</font>
        |  
        |  -ifdef(use_specs).
        |  -spec find_child(Supervisor, Name) -&gt; [pid()] when
        |        Supervisor :: sup_ref(),
        |        Name :: child_id().
        |  -endif.
        |  find_child(Supervisor, Name) -&gt;
<font color=red>     0..|      [Pid || {Name1, Pid, _Type, _Modules} &lt;- which_children(Supervisor),</font>
<font color=red>     0..|              Name1 =:= Name].</font>
        |  
        |  call(Supervisor, Req) -&gt;
<font color=red>     0..|      gen_server:call(Supervisor, Req, infinity).</font>
        |  
        |  -ifdef(use_specs).
        |  -spec check_childspecs(ChildSpecs) -&gt; Result when
        |        ChildSpecs :: [child_spec()],
        |        Result :: 'ok' | {'error', Error :: term()}.
        |  -endif.
        |  check_childspecs(ChildSpecs) when is_list(ChildSpecs) -&gt;
<font color=red>     0..|      case check_startspec(ChildSpecs) of</font>
<font color=red>     0..|  	{ok, _} -&gt; ok;</font>
<font color=red>     0..|  	Error -&gt; {error, Error}</font>
        |      end;
<font color=red>     0..|  check_childspecs(X) -&gt; {error, {badarg, X}}.</font>
        |  
        |  %%%-----------------------------------------------------------------
        |  %%% Called by timer:apply_after from restart/2
        |  -ifdef(use_specs).
        |  -spec try_again_restart(SupRef, Child, Reason) -&gt; ok when
        |        SupRef :: sup_ref(),
        |        Child :: child_id() | pid(),
        |        Reason :: term().
        |  -endif.
        |  try_again_restart(Supervisor, Child, Reason) -&gt;
<font color=red>     0..|      cast(Supervisor, {try_again_restart, Child, Reason}).</font>
        |  
        |  cast(Supervisor, Req) -&gt;
<font color=red>     0..|      gen_server:cast(Supervisor, Req).</font>
        |  
        |  %%% ---------------------------------------------------
        |  %%% 
        |  %%% Initialize the supervisor.
        |  %%% 
        |  %%% ---------------------------------------------------
        |  -ifdef(use_specs).
        |  -type init_sup_name() :: sup_name() | 'self'.
        |  
        |  -type stop_rsn() :: {'shutdown', term()}
        |                    | {'bad_return', {module(),'init', term()}}
        |                    | {'bad_start_spec', term()}
        |                    | {'start_spec', term()}
        |                    | {'supervisor_data', term()}.
        |  
        |  -spec init({init_sup_name(), module(), [term()]}) -&gt;
        |          {'ok', state()} | 'ignore' | {'stop', stop_rsn()}.
        |  -endif.
        |  init({SupName, Mod, Args}) -&gt;
<font color=red>     0..|      process_flag(trap_exit, true),</font>
<font color=red>     0..|      case Mod:init(Args) of</font>
        |  	{ok, {SupFlags, StartSpec}} -&gt;
<font color=red>     0..|  	    case init_state(SupName, SupFlags, Mod, Args) of</font>
        |  		{ok, State} when ?is_simple(State) -&gt;
<font color=red>     0..|  		    init_dynamic(State, StartSpec);</font>
        |  		{ok, State} -&gt;
<font color=red>     0..|  		    init_children(State, StartSpec);</font>
        |  		Error -&gt;
<font color=red>     0..|  		    {stop, {supervisor_data, Error}}</font>
        |  	    end;
        |  	ignore -&gt;
<font color=red>     0..|  	    ignore;</font>
        |  	Error -&gt;
<font color=red>     0..|  	    {stop, {bad_return, {Mod, init, Error}}}</font>
        |      end.
        |  
        |  init_children(State, StartSpec) -&gt;
<font color=red>     0..|      SupName = State#state.name,</font>
<font color=red>     0..|      case check_startspec(StartSpec) of</font>
        |          {ok, Children} -&gt;
<font color=red>     0..|              case start_children(Children, SupName) of</font>
        |                  {ok, NChildren} -&gt;
<font color=red>     0..|                      {ok, State#state{children = NChildren}};</font>
        |                  {error, NChildren, Reason} -&gt;
<font color=red>     0..|                      terminate_children(NChildren, SupName),</font>
<font color=red>     0..|                      {stop, {shutdown, Reason}}</font>
        |              end;
        |          Error -&gt;
<font color=red>     0..|              {stop, {start_spec, Error}}</font>
        |      end.
        |  
        |  init_dynamic(State, [StartSpec]) -&gt;
<font color=red>     0..|      case check_startspec([StartSpec]) of</font>
        |          {ok, Children} -&gt;
<font color=red>     0..|  	    {ok, State#state{children = Children}};</font>
        |          Error -&gt;
<font color=red>     0..|              {stop, {start_spec, Error}}</font>
        |      end;
        |  init_dynamic(_State, StartSpec) -&gt;
<font color=red>     0..|      {stop, {bad_start_spec, StartSpec}}.</font>
        |  
        |  %%-----------------------------------------------------------------
        |  %% Func: start_children/2
        |  %% Args: Children = [child_rec()] in start order
        |  %%       SupName = {local, atom()} | {global, atom()} | {pid(), Mod}
        |  %% Purpose: Start all children.  The new list contains #child's
        |  %%          with pids.
        |  %% Returns: {ok, NChildren} | {error, NChildren, Reason}
        |  %%          NChildren = [child_rec()] in termination order (reversed
        |  %%                        start order)
        |  %%-----------------------------------------------------------------
<font color=red>     0..|  start_children(Children, SupName) -&gt; start_children(Children, [], SupName).</font>
        |  
        |  start_children([Child|Chs], NChildren, SupName) -&gt;
<font color=red>     0..|      case do_start_child(SupName, Child) of</font>
        |  	{ok, undefined} when Child#child.restart_type =:= temporary -&gt;
<font color=red>     0..|  	    start_children(Chs, NChildren, SupName);</font>
        |  	{ok, Pid} -&gt;
<font color=red>     0..|  	    start_children(Chs, [Child#child{pid = Pid}|NChildren], SupName);</font>
        |  	{ok, Pid, _Extra} -&gt;
<font color=red>     0..|  	    start_children(Chs, [Child#child{pid = Pid}|NChildren], SupName);</font>
        |  	{error, Reason} -&gt;
<font color=red>     0..|  	    report_error(start_error, Reason, Child, SupName),</font>
<font color=red>     0..|  	    {error, lists:reverse(Chs) ++ [Child | NChildren],</font>
        |  	     {failed_to_start_child,Child#child.name,Reason}}
        |      end;
        |  start_children([], NChildren, _SupName) -&gt;
<font color=red>     0..|      {ok, NChildren}.</font>
        |  
        |  do_start_child(SupName, Child) -&gt;
<font color=red>     0..|      #child{mfargs = {M, F, Args}} = Child,</font>
<font color=red>     0..|      case catch apply(M, F, Args) of</font>
        |  	{ok, Pid} when is_pid(Pid) -&gt;
<font color=red>     0..|  	    NChild = Child#child{pid = Pid},</font>
<font color=red>     0..|  	    report_progress(NChild, SupName),</font>
<font color=red>     0..|  	    {ok, Pid};</font>
        |  	{ok, Pid, Extra} when is_pid(Pid) -&gt;
<font color=red>     0..|  	    NChild = Child#child{pid = Pid},</font>
<font color=red>     0..|  	    report_progress(NChild, SupName),</font>
<font color=red>     0..|  	    {ok, Pid, Extra};</font>
        |  	ignore -&gt;
<font color=red>     0..|  	    {ok, undefined};</font>
<font color=red>     0..|  	{error, What} -&gt; {error, What};</font>
<font color=red>     0..|  	What -&gt; {error, What}</font>
        |      end.
        |  
        |  do_start_child_i(M, F, A) -&gt;
<font color=red>     0..|      case catch apply(M, F, A) of</font>
        |  	{ok, Pid} when is_pid(Pid) -&gt;
<font color=red>     0..|  	    {ok, Pid};</font>
        |  	{ok, Pid, Extra} when is_pid(Pid) -&gt;
<font color=red>     0..|  	    {ok, Pid, Extra};</font>
        |  	ignore -&gt;
<font color=red>     0..|  	    {ok, undefined};</font>
        |  	{error, Error} -&gt;
<font color=red>     0..|  	    {error, Error};</font>
        |  	What -&gt;
<font color=red>     0..|  	    {error, What}</font>
        |      end.
        |  
        |  %%% ---------------------------------------------------
        |  %%% 
        |  %%% Callback functions.
        |  %%% 
        |  %%% ---------------------------------------------------
        |  -ifdef(use_specs).
        |  -type call() :: 'which_children' | 'count_children' | {_, _}.	% XXX: refine
        |  -spec handle_call(call(), term(), state()) -&gt; {'reply', term(), state()}.
        |  -endif.
        |  handle_call({start_child, EArgs}, _From, State) when ?is_simple(State) -&gt;
<font color=red>     0..|      Child = hd(State#state.children),</font>
<font color=red>     0..|      #child{mfargs = {M, F, A}} = Child,</font>
<font color=red>     0..|      Args = A ++ EArgs,</font>
<font color=red>     0..|      case do_start_child_i(M, F, Args) of</font>
        |  	{ok, undefined} when Child#child.restart_type =:= temporary -&gt;
<font color=red>     0..|  	    {reply, {ok, undefined}, State};</font>
        |  	{ok, Pid} -&gt;
<font color=red>     0..|  	    NState = save_dynamic_child(Child#child.restart_type, Pid, Args, State),</font>
<font color=red>     0..|  	    {reply, {ok, Pid}, NState};</font>
        |  	{ok, Pid, Extra} -&gt;
<font color=red>     0..|  	    NState = save_dynamic_child(Child#child.restart_type, Pid, Args, State),</font>
<font color=red>     0..|  	    {reply, {ok, Pid, Extra}, NState};</font>
        |  	What -&gt;
<font color=red>     0..|  	    {reply, What, State}</font>
        |      end;
        |  
        |  %% terminate_child for simple_one_for_one can only be done with pid
        |  handle_call({terminate_child, Name}, _From, State) when not is_pid(Name),
        |  							?is_simple(State) -&gt;
<font color=red>     0..|      {reply, {error, simple_one_for_one}, State};</font>
        |  
        |  handle_call({terminate_child, Name}, _From, State) -&gt;
<font color=red>     0..|      case get_child(Name, State, ?is_simple(State)) of</font>
        |  	{value, Child} -&gt;
<font color=red>     0..|  	    case do_terminate(Child, State#state.name) of</font>
        |  		#child{restart_type=RT} when RT=:=temporary; ?is_simple(State) -&gt;
<font color=red>     0..|  		    {reply, ok, state_del_child(Child, State)};</font>
        |  		NChild -&gt;
<font color=red>     0..|  		    {reply, ok, replace_child(NChild, State)}</font>
        |  		end;
        |  	false -&gt;
<font color=red>     0..|  	    {reply, {error, not_found}, State}</font>
        |      end;
        |  
        |  %%% The requests delete_child and restart_child are invalid for
        |  %%% simple_one_for_one supervisors.
        |  handle_call({_Req, _Data}, _From, State) when ?is_simple(State) -&gt;
<font color=red>     0..|      {reply, {error, simple_one_for_one}, State};</font>
        |  
        |  handle_call({start_child, ChildSpec}, _From, State) -&gt;
<font color=red>     0..|      case check_childspec(ChildSpec) of</font>
        |  	{ok, Child} -&gt;
<font color=red>     0..|  	    {Resp, NState} = handle_start_child(Child, State),</font>
<font color=red>     0..|  	    {reply, Resp, NState};</font>
        |  	What -&gt;
<font color=red>     0..|  	    {reply, {error, What}, State}</font>
        |      end;
        |  
        |  handle_call({restart_child, Name}, _From, State) -&gt;
<font color=red>     0..|      case get_child(Name, State) of</font>
        |  	{value, Child} when Child#child.pid =:= undefined -&gt;
<font color=red>     0..|  	    case do_start_child(State#state.name, Child) of</font>
        |  		{ok, Pid} -&gt;
<font color=red>     0..|  		    NState = replace_child(Child#child{pid = Pid}, State),</font>
<font color=red>     0..|  		    {reply, {ok, Pid}, NState};</font>
        |  		{ok, Pid, Extra} -&gt;
<font color=red>     0..|  		    NState = replace_child(Child#child{pid = Pid}, State),</font>
<font color=red>     0..|  		    {reply, {ok, Pid, Extra}, NState};</font>
        |  		Error -&gt;
<font color=red>     0..|  		    {reply, Error, State}</font>
        |  	    end;
        |  	{value, #child{pid=?restarting(_)}} -&gt;
<font color=red>     0..|  	    {reply, {error, restarting}, State};</font>
        |  	{value, _} -&gt;
<font color=red>     0..|  	    {reply, {error, running}, State};</font>
        |  	_ -&gt;
<font color=red>     0..|  	    {reply, {error, not_found}, State}</font>
        |      end;
        |  
        |  handle_call({delete_child, Name}, _From, State) -&gt;
<font color=red>     0..|      case get_child(Name, State) of</font>
        |  	{value, Child} when Child#child.pid =:= undefined -&gt;
<font color=red>     0..|  	    NState = remove_child(Child, State),</font>
<font color=red>     0..|  	    {reply, ok, NState};</font>
        |  	{value, #child{pid=?restarting(_)}} -&gt;
<font color=red>     0..|  	    {reply, {error, restarting}, State};</font>
        |  	{value, _} -&gt;
<font color=red>     0..|  	    {reply, {error, running}, State};</font>
        |  	_ -&gt;
<font color=red>     0..|  	    {reply, {error, not_found}, State}</font>
        |      end;
        |  
        |  handle_call(which_children, _From, #state{children = [#child{restart_type = temporary,
        |  							     child_type = CT,
        |  							     modules = Mods}]} =
        |  		State) when ?is_simple(State) -&gt;
<font color=red>     0..|      Reply = lists:map(fun(Pid) -&gt; {undefined, Pid, CT, Mods} end,</font>
        |                        ?SETS:to_list(dynamics_db(temporary, State#state.dynamics))),
<font color=red>     0..|      {reply, Reply, State};</font>
        |  
        |  handle_call(which_children, _From, #state{children = [#child{restart_type = RType,
        |  							 child_type = CT,
        |  							 modules = Mods}]} =
        |  		State) when ?is_simple(State) -&gt;
<font color=red>     0..|      Reply = lists:map(fun({?restarting(_),_}) -&gt; {undefined,restarting,CT,Mods};</font>
<font color=red>     0..|  			 ({Pid, _}) -&gt; {undefined, Pid, CT, Mods} end,</font>
        |  		      ?DICT:to_list(dynamics_db(RType, State#state.dynamics))),
<font color=red>     0..|      {reply, Reply, State};</font>
        |  
        |  handle_call(which_children, _From, State) -&gt;
<font color=red>     0..|      Resp =</font>
        |  	lists:map(fun(#child{pid = ?restarting(_), name = Name,
        |  			     child_type = ChildType, modules = Mods}) -&gt;
<font color=red>     0..|  			  {Name, restarting, ChildType, Mods};</font>
        |  		     (#child{pid = Pid, name = Name,
        |  			     child_type = ChildType, modules = Mods}) -&gt;
<font color=red>     0..|  			  {Name, Pid, ChildType, Mods}</font>
        |  		  end,
        |  		  State#state.children),
<font color=red>     0..|      {reply, Resp, State};</font>
        |  
        |  
        |  handle_call(count_children, _From, #state{children = [#child{restart_type = temporary,
        |  							     child_type = CT}]} = State)
        |    when ?is_simple(State) -&gt;
<font color=red>     0..|      {Active, Count} =</font>
        |  	?SETS:fold(fun(Pid, {Alive, Tot}) -&gt;
<font color=red>     0..|  			   case is_pid(Pid) andalso is_process_alive(Pid) of</font>
<font color=red>     0..|  			       true -&gt;{Alive+1, Tot +1};</font>
        |  			       false -&gt;
<font color=red>     0..|  				   {Alive, Tot + 1}</font>
        |  			   end
        |  		   end, {0, 0}, dynamics_db(temporary, State#state.dynamics)),
<font color=red>     0..|      Reply = case CT of</font>
<font color=red>     0..|  		supervisor -&gt; [{specs, 1}, {active, Active},</font>
        |  			       {supervisors, Count}, {workers, 0}];
<font color=red>     0..|  		worker -&gt; [{specs, 1}, {active, Active},</font>
        |  			   {supervisors, 0}, {workers, Count}]
        |  	    end,
<font color=red>     0..|      {reply, Reply, State};</font>
        |  
        |  handle_call(count_children, _From,  #state{children = [#child{restart_type = RType,
        |  							      child_type = CT}]} = State)
        |    when ?is_simple(State) -&gt;
<font color=red>     0..|      {Active, Count} =</font>
        |  	?DICT:fold(fun(Pid, _Val, {Alive, Tot}) -&gt;
<font color=red>     0..|  			   case is_pid(Pid) andalso is_process_alive(Pid) of</font>
        |  			       true -&gt;
<font color=red>     0..|  				   {Alive+1, Tot +1};</font>
        |  			       false -&gt;
<font color=red>     0..|  				   {Alive, Tot + 1}</font>
        |  			   end
        |  		   end, {0, 0}, dynamics_db(RType, State#state.dynamics)),
<font color=red>     0..|      Reply = case CT of</font>
<font color=red>     0..|  		supervisor -&gt; [{specs, 1}, {active, Active},</font>
        |  			       {supervisors, Count}, {workers, 0}];
<font color=red>     0..|  		worker -&gt; [{specs, 1}, {active, Active},</font>
        |  			   {supervisors, 0}, {workers, Count}]
        |  	    end,
<font color=red>     0..|      {reply, Reply, State};</font>
        |  
        |  handle_call(count_children, _From, State) -&gt;
        |      %% Specs and children are together on the children list...
<font color=red>     0..|      {Specs, Active, Supers, Workers} =</font>
        |  	lists:foldl(fun(Child, Counts) -&gt;
<font color=red>     0..|  			   count_child(Child, Counts)</font>
        |  		   end, {0,0,0,0}, State#state.children),
        |  
        |      %% Reformat counts to a property list.
<font color=red>     0..|      Reply = [{specs, Specs}, {active, Active},</font>
        |  	     {supervisors, Supers}, {workers, Workers}],
<font color=red>     0..|      {reply, Reply, State}.</font>
        |  
        |  
        |  count_child(#child{pid = Pid, child_type = worker},
        |  	    {Specs, Active, Supers, Workers}) -&gt;
<font color=red>     0..|      case is_pid(Pid) andalso is_process_alive(Pid) of</font>
<font color=red>     0..|  	true -&gt;  {Specs+1, Active+1, Supers, Workers+1};</font>
<font color=red>     0..|  	false -&gt; {Specs+1, Active, Supers, Workers+1}</font>
        |      end;
        |  count_child(#child{pid = Pid, child_type = supervisor},
        |  	    {Specs, Active, Supers, Workers}) -&gt;
<font color=red>     0..|      case is_pid(Pid) andalso is_process_alive(Pid) of</font>
<font color=red>     0..|  	true -&gt;  {Specs+1, Active+1, Supers+1, Workers};</font>
<font color=red>     0..|  	false -&gt; {Specs+1, Active, Supers+1, Workers}</font>
        |      end.
        |  
        |  
        |  %%% If a restart attempt failed, this message is sent via
        |  %%% timer:apply_after(0,...) in order to give gen_server the chance to
        |  %%% check it's inbox before trying again.
        |  -ifdef(use_specs).
        |  -spec handle_cast({try_again_restart, child_id() | pid(), term()}, state()) -&gt;
        |  			 {'noreply', state()} | {stop, shutdown, state()}.
        |  -endif.
        |  handle_cast({try_again_restart,Pid,Reason}, #state{children=[Child]}=State)
        |    when ?is_simple(State) -&gt;
<font color=red>     0..|      RT = Child#child.restart_type,</font>
<font color=red>     0..|      RPid = restarting(Pid),</font>
<font color=red>     0..|      case dynamic_child_args(RPid, dynamics_db(RT, State#state.dynamics)) of</font>
        |  	{ok, Args} -&gt;
<font color=red>     0..|  	    {M, F, _} = Child#child.mfargs,</font>
<font color=red>     0..|  	    NChild = Child#child{pid = RPid, mfargs = {M, F, Args}},</font>
<font color=red>     0..|              try_restart(Child#child.restart_type, Reason, NChild, State);</font>
        |  	error -&gt;
<font color=red>     0..|              {noreply, State}</font>
        |      end;
        |  
        |  handle_cast({try_again_restart,Name,Reason}, State) -&gt;
        |      %% we still support &gt;= R12-B3 in which lists:keyfind/3 doesn't exist
<font color=red>     0..|      case lists:keysearch(Name,#child.name,State#state.children) of</font>
        |  	{value, Child = #child{pid=?restarting(_), restart_type=RestartType}} -&gt;
<font color=red>     0..|              try_restart(RestartType, Reason, Child, State);</font>
        |  	_ -&gt;
<font color=red>     0..|  	    {noreply,State}</font>
        |      end.
        |  
        |  %%
        |  %% Take care of terminated children.
        |  %%
        |  -ifdef(use_specs).
        |  -spec handle_info(term(), state()) -&gt;
        |          {'noreply', state()} | {'stop', 'shutdown', state()}.
        |  -endif.
        |  handle_info({'EXIT', Pid, Reason}, State) -&gt;
<font color=red>     0..|      case restart_child(Pid, Reason, State) of</font>
        |  	{ok, State1} -&gt;
<font color=red>     0..|  	    {noreply, State1};</font>
        |  	{shutdown, State1} -&gt;
<font color=red>     0..|  	    {stop, shutdown, State1}</font>
        |      end;
        |  
        |  handle_info({delayed_restart, {RestartType, Reason, Child}}, State)
        |    when ?is_simple(State) -&gt;
<font color=red>     0..|      try_restart(RestartType, Reason, Child, State);</font>
        |  handle_info({delayed_restart, {RestartType, Reason, Child}}, State) -&gt;
<font color=red>     0..|      case get_child(Child#child.name, State) of</font>
        |          {value, Child1} -&gt;
<font color=red>     0..|              try_restart(RestartType, Reason, Child1, State);</font>
        |          _What -&gt;
<font color=red>     0..|              {noreply, State}</font>
        |      end;
        |  
        |  handle_info(Msg, State) -&gt;
<font color=red>     0..|      error_logger:error_msg("Supervisor received unexpected message: ~p~n", </font>
        |  			   [Msg]),
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %%
        |  %% Terminate this server.
        |  %%
        |  -ifdef(use_specs).
        |  -spec terminate(term(), state()) -&gt; 'ok'.
        |  -endif.
        |  terminate(_Reason, #state{children=[Child]} = State) when ?is_simple(State) -&gt;
<font color=red>     0..|      terminate_dynamic_children(Child, dynamics_db(Child#child.restart_type,</font>
        |                                                    State#state.dynamics),
        |                                 State#state.name);
        |  terminate(_Reason, State) -&gt;
<font color=red>     0..|      terminate_children(State#state.children, State#state.name).</font>
        |  
        |  %%
        |  %% Change code for the supervisor.
        |  %% Call the new call-back module and fetch the new start specification.
        |  %% Combine the new spec. with the old. If the new start spec. is
        |  %% not valid the code change will not succeed.
        |  %% Use the old Args as argument to Module:init/1.
        |  %% NOTE: This requires that the init function of the call-back module
        |  %%       does not have any side effects.
        |  %%
        |  -ifdef(use_specs).
        |  -spec code_change(term(), state(), term()) -&gt;
        |          {'ok', state()} | {'error', term()}.
        |  -endif.
        |  code_change(_, State, _) -&gt;
<font color=red>     0..|      case (State#state.module):init(State#state.args) of</font>
        |  	{ok, {SupFlags, StartSpec}} -&gt;
<font color=red>     0..|  	    case catch check_flags(SupFlags) of</font>
        |  		ok -&gt;
<font color=red>     0..|  		    {Strategy, MaxIntensity, Period} = SupFlags,</font>
<font color=red>     0..|                      update_childspec(State#state{strategy = Strategy,</font>
        |                                                   intensity = MaxIntensity,
        |                                                   period = Period},
        |                                       StartSpec);
        |  		Error -&gt;
<font color=red>     0..|  		    {error, Error}</font>
        |  	    end;
        |  	ignore -&gt;
<font color=red>     0..|  	    {ok, State};</font>
        |  	Error -&gt;
<font color=red>     0..|  	    Error</font>
        |      end.
        |  
        |  check_flags({Strategy, MaxIntensity, Period}) -&gt;
<font color=red>     0..|      validStrategy(Strategy),</font>
<font color=red>     0..|      validIntensity(MaxIntensity),</font>
<font color=red>     0..|      validPeriod(Period),</font>
<font color=red>     0..|      ok;</font>
        |  check_flags(What) -&gt;
<font color=red>     0..|      {bad_flags, What}.</font>
        |  
        |  update_childspec(State, StartSpec) when ?is_simple(State) -&gt;
<font color=red>     0..|      case check_startspec(StartSpec) of</font>
        |          {ok, [Child]} -&gt;
<font color=red>     0..|              {ok, State#state{children = [Child]}};</font>
        |          Error -&gt;
<font color=red>     0..|              {error, Error}</font>
        |      end;
        |  update_childspec(State, StartSpec) -&gt;
<font color=red>     0..|      case check_startspec(StartSpec) of</font>
        |  	{ok, Children} -&gt;
<font color=red>     0..|  	    OldC = State#state.children, % In reverse start order !</font>
<font color=red>     0..|  	    NewC = update_childspec1(OldC, Children, []),</font>
<font color=red>     0..|  	    {ok, State#state{children = NewC}};</font>
        |          Error -&gt;
<font color=red>     0..|  	    {error, Error}</font>
        |      end.
        |  
        |  update_childspec1([Child|OldC], Children, KeepOld) -&gt;
<font color=red>     0..|      case update_chsp(Child, Children) of</font>
        |  	{ok,NewChildren} -&gt;
<font color=red>     0..|  	    update_childspec1(OldC, NewChildren, KeepOld);</font>
        |  	false -&gt;
<font color=red>     0..|  	    update_childspec1(OldC, Children, [Child|KeepOld])</font>
        |      end;
        |  update_childspec1([], Children, KeepOld) -&gt;
        |      %% Return them in (kept) reverse start order.
<font color=red>     0..|      lists:reverse(Children ++ KeepOld).</font>
        |  
        |  update_chsp(OldCh, Children) -&gt;
<font color=red>     0..|      case lists:map(fun(Ch) when OldCh#child.name =:= Ch#child.name -&gt;</font>
<font color=red>     0..|  			   Ch#child{pid = OldCh#child.pid};</font>
        |  		      (Ch) -&gt;
<font color=red>     0..|  			   Ch</font>
        |  		   end,
        |  		   Children) of
        |  	Children -&gt;
<font color=red>     0..|  	    false;  % OldCh not found in new spec.</font>
        |  	NewC -&gt;
<font color=red>     0..|  	    {ok, NewC}</font>
        |      end.
        |      
        |  %%% ---------------------------------------------------
        |  %%% Start a new child.
        |  %%% ---------------------------------------------------
        |  
        |  handle_start_child(Child, State) -&gt;
<font color=red>     0..|      case get_child(Child#child.name, State) of</font>
        |  	false -&gt;
<font color=red>     0..|  	    case do_start_child(State#state.name, Child) of</font>
        |  		{ok, undefined} when Child#child.restart_type =:= temporary -&gt;
<font color=red>     0..|  		    {{ok, undefined}, State};</font>
        |  		{ok, Pid} -&gt;
<font color=red>     0..|  		    {{ok, Pid}, save_child(Child#child{pid = Pid}, State)};</font>
        |  		{ok, Pid, Extra} -&gt;
<font color=red>     0..|  		    {{ok, Pid, Extra}, save_child(Child#child{pid = Pid}, State)};</font>
        |  		{error, What} -&gt;
<font color=red>     0..|  		    {{error, {What, Child}}, State}</font>
        |  	    end;
        |  	{value, OldChild} when is_pid(OldChild#child.pid) -&gt;
<font color=red>     0..|  	    {{error, {already_started, OldChild#child.pid}}, State};</font>
        |  	{value, _OldChild} -&gt;
<font color=red>     0..|  	    {{error, already_present}, State}</font>
        |      end.
        |  
        |  %%% ---------------------------------------------------
        |  %%% Restart. A process has terminated.
        |  %%% Returns: {ok, state()} | {shutdown, state()}
        |  %%% ---------------------------------------------------
        |  
        |  restart_child(Pid, Reason, #state{children = [Child]} = State) when ?is_simple(State) -&gt;
<font color=red>     0..|      RestartType = Child#child.restart_type,</font>
<font color=red>     0..|      case dynamic_child_args(Pid, dynamics_db(RestartType, State#state.dynamics)) of</font>
        |  	{ok, Args} -&gt;
<font color=red>     0..|  	    {M, F, _} = Child#child.mfargs,</font>
<font color=red>     0..|  	    NChild = Child#child{pid = Pid, mfargs = {M, F, Args}},</font>
<font color=red>     0..|  	    do_restart(RestartType, Reason, NChild, State);</font>
        |  	error -&gt;
<font color=red>     0..|              {ok, State}</font>
        |      end;
        |  
        |  restart_child(Pid, Reason, State) -&gt;
<font color=red>     0..|      Children = State#state.children,</font>
        |      %% we still support &gt;= R12-B3 in which lists:keyfind/3 doesn't exist
<font color=red>     0..|      case lists:keysearch(Pid, #child.pid, Children) of</font>
        |  	{value, #child{restart_type = RestartType} = Child} -&gt;
<font color=red>     0..|  	    do_restart(RestartType, Reason, Child, State);</font>
        |  	false -&gt;
<font color=red>     0..|  	    {ok, State}</font>
        |      end.
        |  
        |  try_restart(RestartType, Reason, Child, State) -&gt;
<font color=red>     0..|      case handle_restart(RestartType, Reason, Child, State) of</font>
<font color=red>     0..|          {ok, NState}       -&gt; {noreply, NState};</font>
<font color=red>     0..|          {shutdown, State2} -&gt; {stop, shutdown, State2}</font>
        |      end.
        |  
        |  do_restart(RestartType, Reason, Child, State) -&gt;
<font color=red>     0..|      maybe_report_error(RestartType, Reason, Child, State),</font>
<font color=red>     0..|      handle_restart(RestartType, Reason, Child, State).</font>
        |  
        |  maybe_report_error(permanent, Reason, Child, State) -&gt;
<font color=red>     0..|      report_child_termination(Reason, Child, State);</font>
        |  maybe_report_error({permanent, _}, Reason, Child, State) -&gt;
<font color=red>     0..|      report_child_termination(Reason, Child, State);</font>
        |  maybe_report_error(_Type, Reason, Child, State) -&gt;
<font color=red>     0..|      case is_abnormal_termination(Reason) of</font>
<font color=red>     0..|          true  -&gt; report_child_termination(Reason, Child, State);</font>
<font color=red>     0..|          false -&gt; ok</font>
        |      end.
        |  
        |  report_child_termination(Reason, Child, State) -&gt;
<font color=red>     0..|      report_error(child_terminated, Reason, Child, State#state.name).</font>
        |  
        |  handle_restart(permanent, _Reason, Child, State) -&gt;
<font color=red>     0..|      restart(Child, State);</font>
        |  handle_restart(transient, Reason, Child, State) -&gt;
<font color=red>     0..|      restart_if_explicit_or_abnormal(fun restart/2,</font>
        |                                      fun delete_child_and_continue/2,
        |                                      Reason, Child, State);
        |  handle_restart(intrinsic, Reason, Child, State) -&gt;
<font color=red>     0..|      restart_if_explicit_or_abnormal(fun restart/2,</font>
        |                                      fun delete_child_and_stop/2,
        |                                      Reason, Child, State);
        |  handle_restart(temporary, _Reason, Child, State) -&gt;
<font color=red>     0..|      delete_child_and_continue(Child, State);</font>
        |  handle_restart({permanent, _Delay}=Restart, Reason, Child, State) -&gt;
<font color=red>     0..|      do_restart_delay(Restart, Reason, Child, State);</font>
        |  handle_restart({transient, _Delay}=Restart, Reason, Child, State) -&gt;
<font color=red>     0..|      restart_if_explicit_or_abnormal(defer_to_restart_delay(Restart, Reason),</font>
        |                                      fun delete_child_and_continue/2,
        |                                      Reason, Child, State);
        |  handle_restart({intrinsic, _Delay}=Restart, Reason, Child, State) -&gt;
<font color=red>     0..|      restart_if_explicit_or_abnormal(defer_to_restart_delay(Restart, Reason),</font>
        |                                      fun delete_child_and_stop/2,
        |                                      Reason, Child, State).
        |  
        |  restart_if_explicit_or_abnormal(RestartHow, Otherwise, Reason, Child, State) -&gt;
<font color=red>     0..|      case ?is_explicit_restart(Reason) orelse is_abnormal_termination(Reason) of</font>
<font color=red>     0..|          true  -&gt; RestartHow(Child, State);</font>
<font color=red>     0..|          false -&gt; Otherwise(Child, State)</font>
        |      end.
        |  
        |  defer_to_restart_delay(Restart, Reason) -&gt;
<font color=red>     0..|      fun(Child, State) -&gt; do_restart_delay(Restart, Reason, Child, State) end.</font>
        |  
        |  delete_child_and_continue(Child, State) -&gt;
<font color=red>     0..|      {ok, state_del_child(Child, State)}.</font>
        |  
        |  delete_child_and_stop(Child, State) -&gt;
<font color=red>     0..|      {shutdown, state_del_child(Child, State)}.</font>
        |  
<font color=red>     0..|  is_abnormal_termination(normal)        -&gt; false;</font>
<font color=red>     0..|  is_abnormal_termination(shutdown)      -&gt; false;</font>
<font color=red>     0..|  is_abnormal_termination({shutdown, _}) -&gt; false;</font>
<font color=red>     0..|  is_abnormal_termination(_Other)        -&gt; true.</font>
        |  
        |  do_restart_delay({RestartType, Delay}, Reason, Child, State) -&gt;
<font color=red>     0..|      case add_restart(State) of</font>
        |          {ok, NState} -&gt;
<font color=red>     0..|              maybe_restart(NState#state.strategy, Child, NState);</font>
        |          {terminate, _NState} -&gt;
        |              %% we've reached the max restart intensity, but the
        |              %% add_restart will have added to the restarts
        |              %% field. Given we don't want to die here, we need to go
        |              %% back to the old restarts field otherwise we'll never
        |              %% attempt to restart later, which is why we ignore
        |              %% NState for this clause.
<font color=red>     0..|              _TRef = erlang:send_after(trunc(Delay*1000), self(),</font>
        |                                        {delayed_restart,
        |                                         {{RestartType, Delay}, Reason, Child}}),
<font color=red>     0..|              {ok, state_del_child(Child, State)}</font>
        |      end.
        |  
        |  restart(Child, State) -&gt;
<font color=red>     0..|      case add_restart(State) of</font>
        |  	{ok, NState} -&gt;
<font color=red>     0..|  	    maybe_restart(NState#state.strategy, Child, NState);</font>
        |  	{terminate, NState} -&gt;
<font color=red>     0..|  	    report_error(shutdown, reached_max_restart_intensity,</font>
        |  			 Child, State#state.name),
<font color=red>     0..|  	    {shutdown, remove_child(Child, NState)}</font>
        |      end.
        |  
        |  maybe_restart(Strategy, Child, State) -&gt;
<font color=red>     0..|      case restart(Strategy, Child, State) of</font>
        |          {try_again, Reason, NState2} -&gt;
        |              %% Leaving control back to gen_server before
        |              %% trying again. This way other incoming requsts
        |              %% for the supervisor can be handled - e.g. a
        |              %% shutdown request for the supervisor or the
        |              %% child.
<font color=red>     0..|              Id = if ?is_simple(State) -&gt; Child#child.pid;</font>
<font color=red>     0..|                      true -&gt; Child#child.name</font>
        |                   end,
<font color=red>     0..|              timer:apply_after(0,?MODULE,try_again_restart,[self(),Id,Reason]),</font>
<font color=red>     0..|              {ok,NState2};</font>
        |          Other -&gt;
<font color=red>     0..|              Other</font>
        |      end.
        |  
        |  restart(simple_one_for_one, Child, State) -&gt;
<font color=red>     0..|      #child{pid = OldPid, mfargs = {M, F, A}} = Child,</font>
<font color=red>     0..|      Dynamics = ?DICT:erase(OldPid, dynamics_db(Child#child.restart_type,</font>
        |  					       State#state.dynamics)),
<font color=red>     0..|      case do_start_child_i(M, F, A) of</font>
        |  	{ok, Pid} -&gt;
<font color=red>     0..|  	    NState = State#state{dynamics = ?DICT:store(Pid, A, Dynamics)},</font>
<font color=red>     0..|  	    {ok, NState};</font>
        |  	{ok, Pid, _Extra} -&gt;
<font color=red>     0..|  	    NState = State#state{dynamics = ?DICT:store(Pid, A, Dynamics)},</font>
<font color=red>     0..|  	    {ok, NState};</font>
        |  	{error, Error} -&gt;
<font color=red>     0..|  	    NState = State#state{dynamics = ?DICT:store(restarting(OldPid), A,</font>
        |  							Dynamics)},
<font color=red>     0..|  	    report_error(start_error, Error, Child, State#state.name),</font>
<font color=red>     0..|  	    {try_again, Error, NState}</font>
        |      end;
        |  restart(one_for_one, Child, State) -&gt;
<font color=red>     0..|      OldPid = Child#child.pid,</font>
<font color=red>     0..|      case do_start_child(State#state.name, Child) of</font>
        |  	{ok, Pid} -&gt;
<font color=red>     0..|  	    NState = replace_child(Child#child{pid = Pid}, State),</font>
<font color=red>     0..|  	    {ok, NState};</font>
        |  	{ok, Pid, _Extra} -&gt;
<font color=red>     0..|  	    NState = replace_child(Child#child{pid = Pid}, State),</font>
<font color=red>     0..|  	    {ok, NState};</font>
        |  	{error, Reason} -&gt;
<font color=red>     0..|  	    NState = replace_child(Child#child{pid = restarting(OldPid)}, State),</font>
<font color=red>     0..|  	    report_error(start_error, Reason, Child, State#state.name),</font>
<font color=red>     0..|  	    {try_again, Reason, NState}</font>
        |      end;
        |  restart(rest_for_one, Child, State) -&gt;
<font color=red>     0..|      {ChAfter, ChBefore} = split_child(Child#child.pid, State#state.children),</font>
<font color=red>     0..|      ChAfter2 = terminate_children(ChAfter, State#state.name),</font>
<font color=red>     0..|      case start_children(ChAfter2, State#state.name) of</font>
        |  	{ok, ChAfter3} -&gt;
<font color=red>     0..|  	    {ok, State#state{children = ChAfter3 ++ ChBefore}};</font>
        |  	{error, ChAfter3, Reason} -&gt;
<font color=red>     0..|  	    NChild = Child#child{pid=restarting(Child#child.pid)},</font>
<font color=red>     0..|  	    NState = State#state{children = ChAfter3 ++ ChBefore},</font>
<font color=red>     0..|  	    {try_again, Reason, replace_child(NChild,NState)}</font>
        |      end;
        |  restart(one_for_all, Child, State) -&gt;
<font color=red>     0..|      Children1 = del_child(Child#child.pid, State#state.children),</font>
<font color=red>     0..|      Children2 = terminate_children(Children1, State#state.name),</font>
<font color=red>     0..|      case start_children(Children2, State#state.name) of</font>
        |  	{ok, NChs} -&gt;
<font color=red>     0..|  	    {ok, State#state{children = NChs}};</font>
        |  	{error, NChs, Reason} -&gt;
<font color=red>     0..|  	    NChild = Child#child{pid=restarting(Child#child.pid)},</font>
<font color=red>     0..|  	    NState = State#state{children = NChs},</font>
<font color=red>     0..|  	    {try_again, Reason, replace_child(NChild,NState)}</font>
        |      end.
        |  
<font color=red>     0..|  restarting(Pid) when is_pid(Pid) -&gt; ?restarting(Pid);</font>
<font color=red>     0..|  restarting(RPid) -&gt; RPid.</font>
        |  
        |  %%-----------------------------------------------------------------
        |  %% Func: terminate_children/2
        |  %% Args: Children = [child_rec()] in termination order
        |  %%       SupName = {local, atom()} | {global, atom()} | {pid(),Mod}
        |  %% Returns: NChildren = [child_rec()] in
        |  %%          startup order (reversed termination order)
        |  %%-----------------------------------------------------------------
        |  terminate_children(Children, SupName) -&gt;
<font color=red>     0..|      terminate_children(Children, SupName, []).</font>
        |  
        |  %% Temporary children should not be restarted and thus should
        |  %% be skipped when building the list of terminated children, although
        |  %% we do want them to be shut down as many functions from this module
        |  %% use this function to just clear everything.
        |  terminate_children([Child = #child{restart_type=temporary} | Children], SupName, Res) -&gt;
<font color=red>     0..|      do_terminate(Child, SupName),</font>
<font color=red>     0..|      terminate_children(Children, SupName, Res);</font>
        |  terminate_children([Child | Children], SupName, Res) -&gt;
<font color=red>     0..|      NChild = do_terminate(Child, SupName),</font>
<font color=red>     0..|      terminate_children(Children, SupName, [NChild | Res]);</font>
        |  terminate_children([], _SupName, Res) -&gt;
<font color=red>     0..|      Res.</font>
        |  
        |  do_terminate(Child, SupName) when is_pid(Child#child.pid) -&gt;
<font color=red>     0..|      case shutdown(Child#child.pid, Child#child.shutdown) of</font>
        |          ok -&gt;
<font color=red>     0..|              ok;</font>
        |          {error, normal} when not ?is_permanent(Child#child.restart_type) -&gt;
<font color=red>     0..|              ok;</font>
        |          {error, OtherReason} -&gt;
<font color=red>     0..|              report_error(shutdown_error, OtherReason, Child, SupName)</font>
        |      end,
<font color=red>     0..|      Child#child{pid = undefined};</font>
        |  do_terminate(Child, _SupName) -&gt;
<font color=red>     0..|      Child#child{pid = undefined}.</font>
        |  
        |  %%-----------------------------------------------------------------
        |  %% Shutdowns a child. We must check the EXIT value 
        |  %% of the child, because it might have died with another reason than
        |  %% the wanted. In that case we want to report the error. We put a 
        |  %% monitor on the child an check for the 'DOWN' message instead of 
        |  %% checking for the 'EXIT' message, because if we check the 'EXIT' 
        |  %% message a "naughty" child, who does unlink(Sup), could hang the 
        |  %% supervisor. 
        |  %% Returns: ok | {error, OtherReason}  (this should be reported)
        |  %%-----------------------------------------------------------------
        |  shutdown(Pid, brutal_kill) -&gt;
<font color=red>     0..|      case monitor_child(Pid) of</font>
        |  	ok -&gt;
<font color=red>     0..|  	    exit(Pid, kill),</font>
<font color=red>     0..|  	    receive</font>
        |  		{'DOWN', _MRef, process, Pid, killed} -&gt;
<font color=red>     0..|  		    ok;</font>
        |  		{'DOWN', _MRef, process, Pid, OtherReason} -&gt;
<font color=red>     0..|  		    {error, OtherReason}</font>
        |  	    end;
        |  	{error, Reason} -&gt;      
<font color=red>     0..|  	    {error, Reason}</font>
        |      end;
        |  shutdown(Pid, Time) -&gt;
<font color=red>     0..|      case monitor_child(Pid) of</font>
        |  	ok -&gt;
<font color=red>     0..|  	    exit(Pid, shutdown), %% Try to shutdown gracefully</font>
<font color=red>     0..|  	    receive </font>
        |  		{'DOWN', _MRef, process, Pid, shutdown} -&gt;
<font color=red>     0..|  		    ok;</font>
        |  		{'DOWN', _MRef, process, Pid, OtherReason} -&gt;
<font color=red>     0..|  		    {error, OtherReason}</font>
        |  	    after Time -&gt;
<font color=red>     0..|  		    exit(Pid, kill),  %% Force termination.</font>
<font color=red>     0..|  		    receive</font>
        |  			{'DOWN', _MRef, process, Pid, OtherReason} -&gt;
<font color=red>     0..|  			    {error, OtherReason}</font>
        |  		    end
        |  	    end;
        |  	{error, Reason} -&gt;      
<font color=red>     0..|  	    {error, Reason}</font>
        |      end.
        |  
        |  %% Help function to shutdown/2 switches from link to monitor approach
        |  monitor_child(Pid) -&gt;
        |      
        |      %% Do the monitor operation first so that if the child dies 
        |      %% before the monitoring is done causing a 'DOWN'-message with
        |      %% reason noproc, we will get the real reason in the 'EXIT'-message
        |      %% unless a naughty child has already done unlink...
<font color=red>     0..|      erlang:monitor(process, Pid),</font>
<font color=red>     0..|      unlink(Pid),</font>
        |  
<font color=red>     0..|      receive</font>
        |  	%% If the child dies before the unlik we must empty
        |  	%% the mail-box of the 'EXIT'-message and the 'DOWN'-message.
        |  	{'EXIT', Pid, Reason} -&gt; 
<font color=red>     0..|  	    receive </font>
        |  		{'DOWN', _, process, Pid, _} -&gt;
<font color=red>     0..|  		    {error, Reason}</font>
        |  	    end
        |      after 0 -&gt; 
        |  	    %% If a naughty child did unlink and the child dies before
        |  	    %% monitor the result will be that shutdown/2 receives a 
        |  	    %% 'DOWN'-message with reason noproc.
        |  	    %% If the child should die after the unlink there
        |  	    %% will be a 'DOWN'-message with a correct reason
        |  	    %% that will be handled in shutdown/2. 
<font color=red>     0..|  	    ok   </font>
        |      end.
        |  
        |  
        |  %%-----------------------------------------------------------------
        |  %% Func: terminate_dynamic_children/3
        |  %% Args: Child    = child_rec()
        |  %%       Dynamics = ?DICT() | ?SET()
        |  %%       SupName  = {local, atom()} | {global, atom()} | {pid(),Mod}
        |  %% Returns: ok
        |  %%
        |  %%
        |  %% Shutdown all dynamic children. This happens when the supervisor is
        |  %% stopped. Because the supervisor can have millions of dynamic children, we
        |  %% can have an significative overhead here.
        |  %%-----------------------------------------------------------------
        |  terminate_dynamic_children(Child, Dynamics, SupName) -&gt;
<font color=red>     0..|      {Pids, EStack0} = monitor_dynamic_children(Child, Dynamics),</font>
<font color=red>     0..|      Sz = ?SETS:size(Pids),</font>
<font color=red>     0..|      EStack = case Child#child.shutdown of</font>
        |                   brutal_kill -&gt;
<font color=red>     0..|                       ?SETS:fold(fun(P, _) -&gt; exit(P, kill) end, ok, Pids),</font>
<font color=red>     0..|                       wait_dynamic_children(Child, Pids, Sz, undefined, EStack0);</font>
        |                   infinity -&gt;
<font color=red>     0..|                       ?SETS:fold(fun(P, _) -&gt; exit(P, shutdown) end, ok, Pids),</font>
<font color=red>     0..|                       wait_dynamic_children(Child, Pids, Sz, undefined, EStack0);</font>
        |                   Time -&gt;
<font color=red>     0..|                       ?SETS:fold(fun(P, _) -&gt; exit(P, shutdown) end, ok, Pids),</font>
<font color=red>     0..|                       TRef = erlang:start_timer(Time, self(), kill),</font>
<font color=red>     0..|                       wait_dynamic_children(Child, Pids, Sz, TRef, EStack0)</font>
        |               end,
        |      %% Unroll stacked errors and report them
<font color=red>     0..|      ?DICT:fold(fun(Reason, Ls, _) -&gt;</font>
<font color=red>     0..|                         report_error(shutdown_error, Reason,</font>
        |                                      Child#child{pid=Ls}, SupName)
        |                 end, ok, EStack).
        |  
        |  
        |  monitor_dynamic_children(#child{restart_type=temporary}, Dynamics) -&gt;
<font color=red>     0..|      ?SETS:fold(fun(P, {Pids, EStack}) -&gt;</font>
<font color=red>     0..|                         case monitor_child(P) of</font>
        |                             ok -&gt;
<font color=red>     0..|                                 {?SETS:add_element(P, Pids), EStack};</font>
        |                             {error, normal} -&gt;
<font color=red>     0..|                                 {Pids, EStack};</font>
        |                             {error, Reason} -&gt;
<font color=red>     0..|                                 {Pids, ?DICT:append(Reason, P, EStack)}</font>
        |                         end
        |                 end, {?SETS:new(), ?DICT:new()}, Dynamics);
        |  monitor_dynamic_children(#child{restart_type=RType}, Dynamics) -&gt;
<font color=red>     0..|      ?DICT:fold(fun(P, _, {Pids, EStack}) when is_pid(P) -&gt;</font>
<font color=red>     0..|                         case monitor_child(P) of</font>
        |                             ok -&gt;
<font color=red>     0..|                                 {?SETS:add_element(P, Pids), EStack};</font>
        |                             {error, normal} when not ?is_permanent(RType) -&gt;
<font color=red>     0..|                                 {Pids, EStack};</font>
        |                             {error, Reason} -&gt;
<font color=red>     0..|                                 {Pids, ?DICT:append(Reason, P, EStack)}</font>
        |                         end;
        |  		  (?restarting(_), _, {Pids, EStack}) -&gt;
<font color=red>     0..|  		       {Pids, EStack}</font>
        |                 end, {?SETS:new(), ?DICT:new()}, Dynamics).
        |  
        |  wait_dynamic_children(_Child, _Pids, 0, undefined, EStack) -&gt;
<font color=red>     0..|      EStack;</font>
        |  wait_dynamic_children(_Child, _Pids, 0, TRef, EStack) -&gt;
        |  	%% If the timer has expired before its cancellation, we must empty the
        |  	%% mail-box of the 'timeout'-message.
<font color=red>     0..|      erlang:cancel_timer(TRef),</font>
<font color=red>     0..|      receive</font>
        |          {timeout, TRef, kill} -&gt;
<font color=red>     0..|              EStack</font>
        |      after 0 -&gt;
<font color=red>     0..|              EStack</font>
        |      end;
        |  wait_dynamic_children(#child{shutdown=brutal_kill} = Child, Pids, Sz,
        |                        TRef, EStack) -&gt;
<font color=red>     0..|      receive</font>
        |          {'DOWN', _MRef, process, Pid, killed} -&gt;
<font color=red>     0..|              wait_dynamic_children(Child, ?SETS:del_element(Pid, Pids), Sz-1,</font>
        |                                    TRef, EStack);
        |  
        |          {'DOWN', _MRef, process, Pid, Reason} -&gt;
<font color=red>     0..|              wait_dynamic_children(Child, ?SETS:del_element(Pid, Pids), Sz-1,</font>
        |                                    TRef, ?DICT:append(Reason, Pid, EStack))
        |      end;
        |  wait_dynamic_children(#child{restart_type=RType} = Child, Pids, Sz,
        |                        TRef, EStack) -&gt;
<font color=red>     0..|      receive</font>
        |          {'DOWN', _MRef, process, Pid, shutdown} -&gt;
<font color=red>     0..|              wait_dynamic_children(Child, ?SETS:del_element(Pid, Pids), Sz-1,</font>
        |                                    TRef, EStack);
        |  
        |          {'DOWN', _MRef, process, Pid, normal} when not ?is_permanent(RType) -&gt;
<font color=red>     0..|              wait_dynamic_children(Child, ?SETS:del_element(Pid, Pids), Sz-1,</font>
        |                                    TRef, EStack);
        |  
        |          {'DOWN', _MRef, process, Pid, Reason} -&gt;
<font color=red>     0..|              wait_dynamic_children(Child, ?SETS:del_element(Pid, Pids), Sz-1,</font>
        |                                    TRef, ?DICT:append(Reason, Pid, EStack));
        |  
        |          {timeout, TRef, kill} -&gt;
<font color=red>     0..|              ?SETS:fold(fun(P, _) -&gt; exit(P, kill) end, ok, Pids),</font>
<font color=red>     0..|              wait_dynamic_children(Child, Pids, Sz-1, undefined, EStack)</font>
        |      end.
        |  
        |  %%-----------------------------------------------------------------
        |  %% Child/State manipulating functions.
        |  %%-----------------------------------------------------------------
        |  
        |  %% Note we do not want to save the parameter list for temporary processes as
        |  %% they will not be restarted, and hence we do not need this information.
        |  %% Especially for dynamic children to simple_one_for_one supervisors
        |  %% it could become very costly as it is not uncommon to spawn
        |  %% very many such processes.
        |  save_child(#child{restart_type = temporary,
        |  		  mfargs = {M, F, _}} = Child, #state{children = Children} = State) -&gt;
<font color=red>     0..|      State#state{children = [Child#child{mfargs = {M, F, undefined}} |Children]};</font>
        |  save_child(Child, #state{children = Children} = State) -&gt;
<font color=red>     0..|      State#state{children = [Child |Children]}.</font>
        |  
        |  save_dynamic_child(temporary, Pid, _, #state{dynamics = Dynamics} = State) -&gt;
<font color=red>     0..|      State#state{dynamics = ?SETS:add_element(Pid, dynamics_db(temporary, Dynamics))};</font>
        |  save_dynamic_child(RestartType, Pid, Args, #state{dynamics = Dynamics} = State) -&gt;
<font color=red>     0..|      State#state{dynamics = ?DICT:store(Pid, Args, dynamics_db(RestartType, Dynamics))}.</font>
        |  
        |  dynamics_db(temporary, undefined) -&gt;
<font color=red>     0..|      ?SETS:new();</font>
        |  dynamics_db(_, undefined) -&gt;
<font color=red>     0..|      ?DICT:new();</font>
        |  dynamics_db(_,Dynamics) -&gt;
<font color=red>     0..|      Dynamics.</font>
        |  
        |  dynamic_child_args(Pid, Dynamics) -&gt;
<font color=red>     0..|      case ?SETS:is_set(Dynamics) of</font>
        |          true -&gt;
<font color=red>     0..|              {ok, undefined};</font>
        |          false -&gt;
<font color=red>     0..|              ?DICT:find(Pid, Dynamics)</font>
        |      end.
        |  
        |  state_del_child(#child{pid = Pid, restart_type = temporary}, State) when ?is_simple(State) -&gt;
<font color=red>     0..|      NDynamics = ?SETS:del_element(Pid, dynamics_db(temporary, State#state.dynamics)),</font>
<font color=red>     0..|      State#state{dynamics = NDynamics};</font>
        |  state_del_child(#child{pid = Pid, restart_type = RType}, State) when ?is_simple(State) -&gt;
<font color=red>     0..|      NDynamics = ?DICT:erase(Pid, dynamics_db(RType, State#state.dynamics)),</font>
<font color=red>     0..|      State#state{dynamics = NDynamics};</font>
        |  state_del_child(Child, State) -&gt;
<font color=red>     0..|      NChildren = del_child(Child#child.name, State#state.children),</font>
<font color=red>     0..|      State#state{children = NChildren}.</font>
        |  
        |  del_child(Name, [Ch=#child{pid = ?restarting(_)}|_]=Chs) when Ch#child.name =:= Name -&gt;
<font color=red>     0..|      Chs;</font>
        |  del_child(Name, [Ch|Chs]) when Ch#child.name =:= Name, Ch#child.restart_type =:= temporary -&gt;
<font color=red>     0..|      Chs;</font>
        |  del_child(Name, [Ch|Chs]) when Ch#child.name =:= Name -&gt;
<font color=red>     0..|      [Ch#child{pid = undefined} | Chs];</font>
        |  del_child(Pid, [Ch|Chs]) when Ch#child.pid =:= Pid, Ch#child.restart_type =:= temporary -&gt;
<font color=red>     0..|      Chs;</font>
        |  del_child(Pid, [Ch|Chs]) when Ch#child.pid =:= Pid -&gt;
<font color=red>     0..|      [Ch#child{pid = undefined} | Chs];</font>
        |  del_child(Name, [Ch|Chs]) -&gt;
<font color=red>     0..|      [Ch|del_child(Name, Chs)];</font>
        |  del_child(_, []) -&gt;
<font color=red>     0..|      [].</font>
        |  
        |  %% Chs = [S4, S3, Ch, S1, S0]
        |  %% Ret: {[S4, S3, Ch], [S1, S0]}
        |  split_child(Name, Chs) -&gt;
<font color=red>     0..|      split_child(Name, Chs, []).</font>
        |  
        |  split_child(Name, [Ch|Chs], After) when Ch#child.name =:= Name -&gt;
<font color=red>     0..|      {lists:reverse([Ch#child{pid = undefined} | After]), Chs};</font>
        |  split_child(Pid, [Ch|Chs], After) when Ch#child.pid =:= Pid -&gt;
<font color=red>     0..|      {lists:reverse([Ch#child{pid = undefined} | After]), Chs};</font>
        |  split_child(Name, [Ch|Chs], After) -&gt;
<font color=red>     0..|      split_child(Name, Chs, [Ch | After]);</font>
        |  split_child(_, [], After) -&gt;
<font color=red>     0..|      {lists:reverse(After), []}.</font>
        |  
        |  get_child(Name, State) -&gt;
<font color=red>     0..|      get_child(Name, State, false).</font>
        |  get_child(Pid, State, AllowPid) when AllowPid, is_pid(Pid) -&gt;
<font color=red>     0..|      get_dynamic_child(Pid, State);</font>
        |  get_child(Name, State, _) -&gt;
<font color=red>     0..|      lists:keysearch(Name, #child.name, State#state.children).</font>
        |  
        |  get_dynamic_child(Pid, #state{children=[Child], dynamics=Dynamics}) -&gt;
<font color=red>     0..|      DynamicsDb = dynamics_db(Child#child.restart_type, Dynamics),</font>
<font color=red>     0..|      case is_dynamic_pid(Pid, DynamicsDb) of</font>
        |  	true -&gt;
<font color=red>     0..|  	    {value, Child#child{pid=Pid}};</font>
        |  	false -&gt;
<font color=red>     0..|  	    RPid = restarting(Pid),</font>
<font color=red>     0..|  	    case is_dynamic_pid(RPid, DynamicsDb) of</font>
        |  		true -&gt;
<font color=red>     0..|  		    {value, Child#child{pid=RPid}};</font>
        |  		false -&gt;
<font color=red>     0..|  		    case erlang:is_process_alive(Pid) of</font>
<font color=red>     0..|  			true -&gt; false;</font>
<font color=red>     0..|  			false -&gt; {value, Child}</font>
        |  		    end
        |  	    end
        |      end.
        |  
        |  is_dynamic_pid(Pid, Dynamics) -&gt;
<font color=red>     0..|      case ?SETS:is_set(Dynamics) of</font>
        |  	true -&gt;
<font color=red>     0..|  	    ?SETS:is_element(Pid, Dynamics);</font>
        |  	false -&gt;
<font color=red>     0..|  	    ?DICT:is_key(Pid, Dynamics)</font>
        |      end.
        |  
        |  replace_child(Child, State) -&gt;
<font color=red>     0..|      Chs = do_replace_child(Child, State#state.children),</font>
<font color=red>     0..|      State#state{children = Chs}.</font>
        |  
        |  do_replace_child(Child, [Ch|Chs]) when Ch#child.name =:= Child#child.name -&gt;
<font color=red>     0..|      [Child | Chs];</font>
        |  do_replace_child(Child, [Ch|Chs]) -&gt;
<font color=red>     0..|      [Ch|do_replace_child(Child, Chs)].</font>
        |  
        |  remove_child(Child, State) -&gt;
<font color=red>     0..|      Chs = lists:keydelete(Child#child.name, #child.name, State#state.children),</font>
<font color=red>     0..|      State#state{children = Chs}.</font>
        |  
        |  %%-----------------------------------------------------------------
        |  %% Func: init_state/4
        |  %% Args: SupName = {local, atom()} | {global, atom()} | self
        |  %%       Type = {Strategy, MaxIntensity, Period}
        |  %%         Strategy = one_for_one | one_for_all | simple_one_for_one |
        |  %%                    rest_for_one
        |  %%         MaxIntensity = integer() &gt;= 0
        |  %%         Period = integer() &gt; 0
        |  %%       Mod :== atom()
        |  %%       Args :== term()
        |  %% Purpose: Check that Type is of correct type (!)
        |  %% Returns: {ok, state()} | Error
        |  %%-----------------------------------------------------------------
        |  init_state(SupName, Type, Mod, Args) -&gt;
<font color=red>     0..|      case catch init_state1(SupName, Type, Mod, Args) of</font>
        |  	{ok, State} -&gt;
<font color=red>     0..|  	    {ok, State};</font>
        |  	Error -&gt;
<font color=red>     0..|  	    Error</font>
        |      end.
        |  
        |  init_state1(SupName, {Strategy, MaxIntensity, Period}, Mod, Args) -&gt;
<font color=red>     0..|      validStrategy(Strategy),</font>
<font color=red>     0..|      validIntensity(MaxIntensity),</font>
<font color=red>     0..|      validPeriod(Period),</font>
<font color=red>     0..|      {ok, #state{name = supname(SupName,Mod),</font>
        |  		strategy = Strategy,
        |  		intensity = MaxIntensity,
        |  		period = Period,
        |  		module = Mod,
        |  		args = Args}};
        |  init_state1(_SupName, Type, _, _) -&gt;
<font color=red>     0..|      {invalid_type, Type}.</font>
        |  
<font color=red>     0..|  validStrategy(simple_one_for_one) -&gt; true;</font>
<font color=red>     0..|  validStrategy(one_for_one)        -&gt; true;</font>
<font color=red>     0..|  validStrategy(one_for_all)        -&gt; true;</font>
<font color=red>     0..|  validStrategy(rest_for_one)       -&gt; true;</font>
<font color=red>     0..|  validStrategy(What)               -&gt; throw({invalid_strategy, What}).</font>
        |  
        |  validIntensity(Max) when is_integer(Max),
<font color=red>     0..|                           Max &gt;=  0 -&gt; true;</font>
<font color=red>     0..|  validIntensity(What)               -&gt; throw({invalid_intensity, What}).</font>
        |  
        |  validPeriod(Period) when is_integer(Period),
<font color=red>     0..|                           Period &gt; 0 -&gt; true;</font>
<font color=red>     0..|  validPeriod(What)                   -&gt; throw({invalid_period, What}).</font>
        |  
<font color=red>     0..|  supname(self, Mod) -&gt; {self(), Mod};</font>
<font color=red>     0..|  supname(N, _)      -&gt; N.</font>
        |  
        |  %%% ------------------------------------------------------
        |  %%% Check that the children start specification is valid.
        |  %%% Shall be a six (6) tuple
        |  %%%    {Name, Func, RestartType, Shutdown, ChildType, Modules}
        |  %%% where Name is an atom
        |  %%%       Func is {Mod, Fun, Args} == {atom(), atom(), list()}
        |  %%%       RestartType is permanent | temporary | transient |
        |  %%%                      intrinsic | {permanent, Delay} |
        |  %%%                      {transient, Delay} | {intrinsic, Delay}
        |  %%                       where Delay &gt;= 0
        |  %%%       Shutdown = integer() &gt; 0 | infinity | brutal_kill
        |  %%%       ChildType = supervisor | worker
        |  %%%       Modules = [atom()] | dynamic
        |  %%% Returns: {ok, [child_rec()]} | Error
        |  %%% ------------------------------------------------------
        |  
<font color=red>     0..|  check_startspec(Children) -&gt; check_startspec(Children, []).</font>
        |  
        |  check_startspec([ChildSpec|T], Res) -&gt;
<font color=red>     0..|      case check_childspec(ChildSpec) of</font>
        |  	{ok, Child} -&gt;
<font color=red>     0..|  	    case lists:keymember(Child#child.name, #child.name, Res) of</font>
<font color=red>     0..|  		true -&gt; {duplicate_child_name, Child#child.name};</font>
<font color=red>     0..|  		false -&gt; check_startspec(T, [Child | Res])</font>
        |  	    end;
<font color=red>     0..|  	Error -&gt; Error</font>
        |      end;
        |  check_startspec([], Res) -&gt;
<font color=red>     0..|      {ok, lists:reverse(Res)}.</font>
        |  
        |  check_childspec({Name, Func, RestartType, Shutdown, ChildType, Mods}) -&gt;
<font color=red>     0..|      catch check_childspec(Name, Func, RestartType, Shutdown, ChildType, Mods);</font>
<font color=red>     0..|  check_childspec(X) -&gt; {invalid_child_spec, X}.</font>
        |  
        |  check_childspec(Name, Func, RestartType, Shutdown, ChildType, Mods) -&gt;
<font color=red>     0..|      validName(Name),</font>
<font color=red>     0..|      validFunc(Func),</font>
<font color=red>     0..|      validRestartType(RestartType),</font>
<font color=red>     0..|      validChildType(ChildType),</font>
<font color=red>     0..|      validShutdown(Shutdown, ChildType),</font>
<font color=red>     0..|      validMods(Mods),</font>
<font color=red>     0..|      {ok, #child{name = Name, mfargs = Func, restart_type = RestartType,</font>
        |  		shutdown = Shutdown, child_type = ChildType, modules = Mods}}.
        |  
<font color=red>     0..|  validChildType(supervisor) -&gt; true;</font>
<font color=red>     0..|  validChildType(worker) -&gt; true;</font>
<font color=red>     0..|  validChildType(What) -&gt; throw({invalid_child_type, What}).</font>
        |  
<font color=red>     0..|  validName(_Name) -&gt; true.</font>
        |  
        |  validFunc({M, F, A}) when is_atom(M), 
        |                            is_atom(F), 
<font color=red>     0..|                            is_list(A) -&gt; true;</font>
<font color=red>     0..|  validFunc(Func)                      -&gt; throw({invalid_mfa, Func}).</font>
        |  
<font color=red>     0..|  validRestartType(permanent)          -&gt; true;</font>
<font color=red>     0..|  validRestartType(temporary)          -&gt; true;</font>
<font color=red>     0..|  validRestartType(transient)          -&gt; true;</font>
<font color=red>     0..|  validRestartType(intrinsic)          -&gt; true;</font>
<font color=red>     0..|  validRestartType({permanent, Delay}) -&gt; validDelay(Delay);</font>
<font color=red>     0..|  validRestartType({intrinsic, Delay}) -&gt; validDelay(Delay);</font>
<font color=red>     0..|  validRestartType({transient, Delay}) -&gt; validDelay(Delay);</font>
<font color=red>     0..|  validRestartType(RestartType)        -&gt; throw({invalid_restart_type,</font>
        |                                                 RestartType}).
        |  
        |  validDelay(Delay) when is_number(Delay),
<font color=red>     0..|                         Delay &gt;= 0 -&gt; true;</font>
<font color=red>     0..|  validDelay(What)                  -&gt; throw({invalid_delay, What}).</font>
        |  
        |  validShutdown(Shutdown, _) 
<font color=red>     0..|    when is_integer(Shutdown), Shutdown &gt; 0 -&gt; true;</font>
<font color=red>     0..|  validShutdown(infinity, _)             -&gt; true;</font>
<font color=red>     0..|  validShutdown(brutal_kill, _)          -&gt; true;</font>
<font color=red>     0..|  validShutdown(Shutdown, _)             -&gt; throw({invalid_shutdown, Shutdown}).</font>
        |  
<font color=red>     0..|  validMods(dynamic) -&gt; true;</font>
        |  validMods(Mods) when is_list(Mods) -&gt;
<font color=red>     0..|      lists:foreach(fun(Mod) -&gt;</font>
<font color=red>     0..|  		    if</font>
<font color=red>     0..|  			is_atom(Mod) -&gt; ok;</font>
<font color=red>     0..|  			true -&gt; throw({invalid_module, Mod})</font>
        |  		    end
        |  		  end,
        |  		  Mods);
<font color=red>     0..|  validMods(Mods) -&gt; throw({invalid_modules, Mods}).</font>
        |  
        |  %%% ------------------------------------------------------
        |  %%% Add a new restart and calculate if the max restart
        |  %%% intensity has been reached (in that case the supervisor
        |  %%% shall terminate).
        |  %%% All restarts accured inside the period amount of seconds
        |  %%% are kept in the #state.restarts list.
        |  %%% Returns: {ok, State'} | {terminate, State'}
        |  %%% ------------------------------------------------------
        |  
        |  add_restart(State) -&gt;  
<font color=red>     0..|      I = State#state.intensity,</font>
<font color=red>     0..|      P = State#state.period,</font>
<font color=red>     0..|      R = State#state.restarts,</font>
<font color=red>     0..|      Now = erlang:now(),</font>
<font color=red>     0..|      R1 = add_restart([Now|R], Now, P),</font>
<font color=red>     0..|      State1 = State#state{restarts = R1},</font>
<font color=red>     0..|      case length(R1) of</font>
        |  	CurI when CurI  =&lt; I -&gt;
<font color=red>     0..|  	    {ok, State1};</font>
        |  	_ -&gt;
<font color=red>     0..|  	    {terminate, State1}</font>
        |      end.
        |  
        |  add_restart([R|Restarts], Now, Period) -&gt;
<font color=red>     0..|      case inPeriod(R, Now, Period) of</font>
        |  	true -&gt;
<font color=red>     0..|  	    [R|add_restart(Restarts, Now, Period)];</font>
        |  	_ -&gt;
<font color=red>     0..|  	    []</font>
        |      end;
        |  add_restart([], _, _) -&gt;
<font color=red>     0..|      [].</font>
        |  
        |  inPeriod(Time, Now, Period) -&gt;
<font color=red>     0..|      case difference(Time, Now) of</font>
        |  	T when T &gt; Period -&gt;
<font color=red>     0..|  	    false;</font>
        |  	_ -&gt;
<font color=red>     0..|  	    true</font>
        |      end.
        |  
        |  %%
        |  %% Time = {MegaSecs, Secs, MicroSecs} (NOTE: MicroSecs is ignored)
        |  %% Calculate the time elapsed in seconds between two timestamps.
        |  %% If MegaSecs is equal just subtract Secs.
        |  %% Else calculate the Mega difference and add the Secs difference,
        |  %% note that Secs difference can be negative, e.g.
        |  %%      {827, 999999, 676} diff {828, 1, 653753} == &gt; 2 secs.
        |  %%
        |  difference({TimeM, TimeS, _}, {CurM, CurS, _}) when CurM &gt; TimeM -&gt;
<font color=red>     0..|      ((CurM - TimeM) * 1000000) + (CurS - TimeS);</font>
        |  difference({_, TimeS, _}, {_, CurS, _}) -&gt;
<font color=red>     0..|      CurS - TimeS.</font>
        |  
        |  %%% ------------------------------------------------------
        |  %%% Error and progress reporting.
        |  %%% ------------------------------------------------------
        |  
        |  report_error(Error, Reason, Child, SupName) -&gt;
<font color=red>     0..|      ErrorMsg = [{supervisor, SupName},</font>
        |  		{errorContext, Error},
        |  		{reason, Reason},
        |  		{offender, extract_child(Child)}],
<font color=red>     0..|      error_logger:error_report(supervisor_report, ErrorMsg).</font>
        |  
        |  
        |  extract_child(Child) when is_list(Child#child.pid) -&gt;
<font color=red>     0..|      [{nb_children, length(Child#child.pid)},</font>
        |       {name, Child#child.name},
        |       {mfargs, Child#child.mfargs},
        |       {restart_type, Child#child.restart_type},
        |       {shutdown, Child#child.shutdown},
        |       {child_type, Child#child.child_type}];
        |  extract_child(Child) -&gt;
<font color=red>     0..|      [{pid, Child#child.pid},</font>
        |       {name, Child#child.name},
        |       {mfargs, Child#child.mfargs},
        |       {restart_type, Child#child.restart_type},
        |       {shutdown, Child#child.shutdown},
        |       {child_type, Child#child.child_type}].
        |  
        |  report_progress(Child, SupName) -&gt;
<font color=red>     0..|      Progress = [{supervisor, SupName},</font>
        |  		{started, extract_child(Child)}],
<font color=red>     0..|      error_logger:info_report(progress, Progress).</font>
</pre>
</body>
</html>
