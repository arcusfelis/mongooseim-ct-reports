<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/travis/build/esl/MongooseIM/apps/ejabberd/logs/ct_run.test@testing-gce-39759cef-e506-4525-ad63-8d26cb539700.c.eco-emissary-99515.internal.2016-01-26_09.43.10/ejabberd_c2s.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/esl/MongooseIM/apps/ejabberd/ebin/../src/ejabberd_c2s.erl by COVER 2016-01-26 at 09:44:19

****************************************************************************

        |  %%%----------------------------------------------------------------------
        |  %%% File    : ejabberd_c2s.erl
        |  %%% Author  : Alexey Shchepin &lt;alexey@process-one.net&gt;
        |  %%% Purpose : Serve C2S connection
        |  %%% Created : 16 Nov 2002 by Alexey Shchepin &lt;alexey@process-one.net&gt;
        |  %%%
        |  %%%
        |  %%% ejabberd, Copyright (C) 2002-2011   ProcessOne
        |  %%%
        |  %%% This program is free software; you can redistribute it and/or
        |  %%% modify it under the terms of the GNU General Public License as
        |  %%% published by the Free Software Foundation; either version 2 of the
        |  %%% License, or (at your option) any later version.
        |  %%%
        |  %%% This program is distributed in the hope that it will be useful,
        |  %%% but WITHOUT ANY WARRANTY; without even the implied warranty of
        |  %%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        |  %%% General Public License for more details.
        |  %%%
        |  %%% You should have received a copy of the GNU General Public License
        |  %%% along with this program; if not, write to the Free Software
        |  %%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
        |  %%% 02111-1307 USA
        |  %%%
        |  %%%----------------------------------------------------------------------
        |  
        |  -module(ejabberd_c2s).
        |  -author('alexey@process-one.net').
        |  -update_info({update, 0}).
        |  %% External exports
        |  -export([start/2,
        |           stop/1,
        |           start_link/2,
        |           send_text/2,
        |           send_element/2,
        |           socket_type/0,
        |           get_presence/1,
        |           get_aux_field/2,
        |           set_aux_field/3,
        |           del_aux_field/2,
        |           get_subscription/2,
        |           get_subscribed/1]).
        |  
        |  %% gen_fsm callbacks
        |  -export([init/1,
        |           wait_for_stream/2,
        |           wait_for_auth/2,
        |           wait_for_feature_request/2,
        |           wait_for_bind_or_resume/2,
        |           wait_for_session_or_sm/2,
        |           wait_for_sasl_response/2,
        |           session_established/2, session_established/3,
        |           resume_session/2, resume_session/3,
        |           handle_event/3,
        |           handle_sync_event/4,
        |           code_change/4,
        |           handle_info/3,
        |           terminate/3,
        |           print_state/1]).
        |  
        |  -include("ejabberd.hrl").
        |  -include("ejabberd_c2s.hrl").
        |  -include("jlib.hrl").
        |  -xep([{xep, 18}, {version, "0.2"}]).
        |  -behaviour(?GEN_FSM).
        |  
        |  -export_type([broadcast/0]).
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% API
        |  %%%----------------------------------------------------------------------
        |  
        |  -spec start(_, list())
        |  -&gt; {'error',_} | {'ok','undefined' | pid()} | {'ok','undefined' | pid(),_}.
        |  start(SockData, Opts) -&gt;
<font color=red>     0..|      ?SUPERVISOR_START.</font>
        |  
        |  
        |  start_link(SockData, Opts) -&gt;
<font color=red>     0..|      ?GEN_FSM:start_link(ejabberd_c2s, [SockData, Opts],</font>
        |                          fsm_limit_opts(Opts) ++ ?FSMOPTS).
        |  
        |  socket_type() -&gt;
<font color=red>     0..|      xml_stream.</font>
        |  
        |  
        |  %% @doc Return Username, Resource and presence information
        |  get_presence(FsmRef) -&gt;
<font color=red>     0..|      ?GEN_FSM:sync_send_all_state_event(FsmRef, get_presence, 1000).</font>
        |  
        |  
        |  -spec get_aux_field(Key :: aux_key(),
        |                      State :: state()) -&gt; 'error' | {'ok', aux_value()}.
        |  get_aux_field(Key, #state{aux_fields = Opts}) -&gt;
<font color=red>     0..|      case lists:keyfind(Key, 1, Opts) of</font>
        |          {_, Val} -&gt;
<font color=red>     0..|              {ok, Val};</font>
        |          _ -&gt;
<font color=red>     0..|              error</font>
        |      end.
        |  
        |  
        |  -spec set_aux_field(Key :: aux_key(),
        |                      Val :: aux_value(),
        |                      State :: state()) -&gt; state().
        |  set_aux_field(Key, Val, #state{aux_fields = Opts} = State) -&gt;
<font color=red>     0..|      Opts1 = lists:keydelete(Key, 1, Opts),</font>
<font color=red>     0..|      State#state{aux_fields = [{Key, Val}|Opts1]}.</font>
        |  
        |  
        |  -spec del_aux_field(Key :: aux_key(), State :: state()) -&gt; aux_value().
        |  del_aux_field(Key, #state{aux_fields = Opts} = State) -&gt;
<font color=red>     0..|      Opts1 = lists:keydelete(Key, 1, Opts),</font>
<font color=red>     0..|      State#state{aux_fields = Opts1}.</font>
        |  
        |  
        |  -spec get_subscription(From :: ejabberd:jid() | ejabberd:simple_jid(),
        |                         State :: state()) -&gt; 'both' | 'from' | 'none' | 'to'.
        |  get_subscription(From = #jid{}, StateData) -&gt;
<font color=red>     0..|      get_subscription(jid:to_lower(From), StateData);</font>
        |  get_subscription(LFrom, StateData) -&gt;
<font color=red>     0..|      LBFrom = setelement(3, LFrom, &lt;&lt;&gt;&gt;),</font>
<font color=red>     0..|      F = is_subscribed_to_my_presence(LFrom, LBFrom, StateData),</font>
<font color=red>     0..|      T = am_i_subscribed_to_presence(LFrom, LBFrom, StateData),</font>
<font color=red>     0..|      if F and T -&gt; both;</font>
<font color=red>     0..|         F -&gt; from;</font>
<font color=red>     0..|         T -&gt; to;</font>
<font color=red>     0..|         true -&gt; none</font>
        |      end.
        |  
        |  stop(FsmRef) -&gt;
<font color=red>     0..|      ?GEN_FSM:send_event(FsmRef, closed).</font>
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% Callback functions from gen_fsm
        |  %%%----------------------------------------------------------------------
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: init/1
        |  %% Returns: {ok, StateName, StateData}          |
        |  %%          {ok, StateName, StateData, Timeout} |
        |  %%          ignore                              |
        |  %%          {stop, StopReason}
        |  %%----------------------------------------------------------------------
        |  init([{SockMod, Socket}, Opts]) -&gt;
<font color=red>     0..|      Access = case lists:keyfind(access, 1, Opts) of</font>
<font color=red>     0..|                   {_, A} -&gt; A;</font>
<font color=red>     0..|                   _ -&gt; all</font>
        |               end,
<font color=red>     0..|      Shaper = case lists:keyfind(shaper, 1, Opts) of</font>
<font color=red>     0..|                   {_, S} -&gt; S;</font>
<font color=red>     0..|                   _ -&gt; none</font>
        |               end,
<font color=red>     0..|      XMLSocket =</font>
        |      case lists:keyfind(xml_socket, 1, Opts) of
<font color=red>     0..|          {_, XS} -&gt; XS;</font>
<font color=red>     0..|          _ -&gt; false</font>
        |      end,
<font color=red>     0..|      Zlib = case lists:keyfind(zlib, 1, Opts) of</font>
<font color=red>     0..|                 {_, ZlibLimit} -&gt; {true, ZlibLimit};</font>
<font color=red>     0..|                 _ -&gt; {false, 0}</font>
        |             end,
<font color=red>     0..|      StartTLS = lists:member(starttls, Opts),</font>
<font color=red>     0..|      StartTLSRequired = lists:member(starttls_required, Opts),</font>
<font color=red>     0..|      TLSEnabled = lists:member(tls, Opts),</font>
<font color=red>     0..|      TLS = StartTLS orelse StartTLSRequired orelse TLSEnabled,</font>
<font color=red>     0..|      TLSOpts1 =</font>
<font color=red>     0..|      lists:filter(fun({certfile, _}) -&gt; true;</font>
<font color=red>     0..|                      ({ciphers, _}) -&gt; true;</font>
<font color=red>     0..|                      (_) -&gt; false</font>
        |                   end, Opts),
<font color=red>     0..|      TLSOpts = [verify_none | TLSOpts1],</font>
<font color=red>     0..|      IP = peerip(SockMod, Socket),</font>
        |      %% Check if IP is blacklisted:
<font color=red>     0..|      case is_ip_blacklisted(IP) of</font>
        |          true -&gt;
<font color=red>     0..|              ?INFO_MSG("Connection attempt from blacklisted IP: ~s (~w)",</font>
        |                        [jlib:ip_to_list(IP), IP]),
<font color=red>     0..|              {stop, normal};</font>
        |          false -&gt;
<font color=red>     0..|              Socket1 =</font>
        |              if
        |                  TLSEnabled -&gt;
<font color=red>     0..|                      SockMod:starttls(Socket, TLSOpts);</font>
        |                  true -&gt;
<font color=red>     0..|                      Socket</font>
        |              end,
<font color=red>     0..|              SocketMonitor = SockMod:monitor(Socket1),</font>
<font color=red>     0..|              {ok, wait_for_stream, #state{server         = ?MYNAME,</font>
        |                                           socket         = Socket1,
        |                                           sockmod        = SockMod,
        |                                           socket_monitor = SocketMonitor,
        |                                           xml_socket     = XMLSocket,
        |                                           zlib           = Zlib,
        |                                           tls            = TLS,
        |                                           tls_required   = StartTLSRequired,
        |                                           tls_enabled    = TLSEnabled,
        |                                           tls_options    = TLSOpts,
        |                                           streamid       = new_id(),
        |                                           access         = Access,
        |                                           shaper         = Shaper,
        |                                           ip             = IP},
        |               ?C2S_OPEN_TIMEOUT}
        |      end.
        |  
        |  %% @doc Return list of all available resources of contacts,
        |  get_subscribed(FsmRef) -&gt;
<font color=red>     0..|      ?GEN_FSM:sync_send_all_state_event(FsmRef, get_subscribed, 1000).</font>
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: StateName/2
        |  %%----------------------------------------------------------------------
        |  
        |  -spec wait_for_stream(Item :: ejabberd:xml_stream_item(),
        |                        StateData :: state()) -&gt; fsm_return().
        |  wait_for_stream({xmlstreamstart, _Name, _} = StreamStart, StateData) -&gt;
<font color=red>     0..|      handle_stream_start(StreamStart, StateData);</font>
        |  wait_for_stream(timeout, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  %% TODO: this clause is most likely dead code - can't be triggered
        |  %%       with XMPP level tests;
        |  %%       see github.com/esl/ejabberd_tests/tree/element-before-stream-start
        |  wait_for_stream({xmlstreamelement, _}, StateData) -&gt;
<font color=red>     0..|      c2s_stream_error(?INVALID_XML_ERR, StateData);</font>
        |  wait_for_stream({xmlstreamend, _}, StateData) -&gt;
<font color=red>     0..|      c2s_stream_error(?INVALID_XML_ERR, StateData);</font>
        |  wait_for_stream({xmlstreamerror, _}, StateData) -&gt;
<font color=red>     0..|      send_header(StateData, ?MYNAME, &lt;&lt; "1.0"&gt;&gt;, &lt;&lt;""&gt;&gt;),</font>
<font color=red>     0..|      c2s_stream_error(?INVALID_XML_ERR, StateData);</font>
        |  wait_for_stream(closed, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData}.</font>
        |  
        |  handle_stream_start({xmlstreamstart, _Name, Attrs}, #state{} = S0) -&gt;
<font color=red>     0..|      Server = jid:nameprep(xml:get_attr_s(&lt;&lt;"to"&gt;&gt;, Attrs)),</font>
<font color=red>     0..|      Lang = get_xml_lang(Attrs),</font>
<font color=red>     0..|      S = S0#state{server = Server, lang = Lang},</font>
<font color=red>     0..|      case {xml:get_attr_s(&lt;&lt;"xmlns:stream"&gt;&gt;, Attrs),</font>
        |            lists:member(Server, ?MYHOSTS)} of
        |          {?NS_STREAM, true} -&gt;
<font color=red>     0..|              change_shaper(S, jid:make(&lt;&lt;&gt;&gt;, Server, &lt;&lt;&gt;&gt;)),</font>
<font color=red>     0..|              Version = xml:get_attr_s(&lt;&lt;"version"&gt;&gt;, Attrs),</font>
<font color=red>     0..|              stream_start_by_protocol_version(Version, S);</font>
        |          {?NS_STREAM, false} -&gt;
<font color=red>     0..|              stream_start_error(?HOST_UNKNOWN_ERR, S);</font>
        |          {_InvalidNS, _} -&gt;
<font color=red>     0..|              stream_start_error(?INVALID_NS_ERR, S)</font>
        |      end.
        |  
        |  stream_start_error(Error, StateData) -&gt;
<font color=red>     0..|      send_header(StateData, ?MYNAME, &lt;&lt;""&gt;&gt;, default_language()),</font>
<font color=red>     0..|      c2s_stream_error(Error, StateData).</font>
        |  
        |  -spec c2s_stream_error(Error, State) -&gt; Result when
        |        Error :: jlib:xmlel(),
        |        State :: state(),
        |        Result :: {stop, normal, state()}.
        |  c2s_stream_error(Error, StateData) -&gt;
<font color=red>     0..|      send_element(StateData, Error),</font>
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData}.</font>
        |  
        |  %% See RFC 6120 4.3.2:
        |  %%
        |  %%   If the initiating entity includes in the initial stream header
        |  %%   the 'version' attribute set to a value of at least &lt;&lt;"1.0"&gt;&gt; [...]
        |  %%   receiving entity MUST send a &lt;features/&gt; child element [...]
        |  %%
        |  %% (http://xmpp.org/rfcs/rfc6120.html#streams-negotiation-features)
        |  stream_start_by_protocol_version(&lt;&lt;"1.0"&gt;&gt;, #state{} = S) -&gt;
<font color=red>     0..|      stream_start_negotiate_features(S);</font>
        |  stream_start_by_protocol_version(_Pre_1_0, #state{lang = Lang, server = Server} = S) -&gt;
<font color=red>     0..|      send_header(S, Server, &lt;&lt;""&gt;&gt;, default_language()),</font>
<font color=red>     0..|      case is_tls_required_but_unavailable(S) of</font>
        |          false -&gt;
<font color=red>     0..|              wait_for_legacy_auth(S);</font>
        |          true -&gt;
<font color=red>     0..|              c2s_stream_error(?POLICY_VIOLATION_ERR(Lang, &lt;&lt;"Use of STARTTLS required"&gt;&gt;), S)</font>
        |      end.
        |  
        |  stream_start_negotiate_features(#state{} = S) -&gt;
<font color=red>     0..|      send_header(S, S#state.server, &lt;&lt;"1.0"&gt;&gt;, default_language()),</font>
<font color=red>     0..|      case {S#state.authenticated, S#state.resource} of</font>
        |          {false, _} -&gt;
<font color=red>     0..|              stream_start_features_before_auth(S);</font>
        |          {_, &lt;&lt;&gt;&gt;} -&gt;
<font color=red>     0..|              stream_start_features_before_bind(S);</font>
        |          {_, _} -&gt;
<font color=red>     0..|              send_element(S, #xmlel{name = &lt;&lt;"stream:features"&gt;&gt;}),</font>
<font color=red>     0..|              fsm_next_state(wait_for_session_or_sm, S)</font>
        |      end.
        |  
        |  is_tls_required_but_unavailable(#state{} = S) -&gt;
<font color=red>     0..|      (not S#state.tls_enabled) and S#state.tls_required.</font>
        |  
        |  %% TODO: Consider making this a completely different path (different FSM states!)
        |  %%       than SASL auth negotiation - once wait_for_auth is targeted by refactoring.
        |  %% For legacy auth see XEP-0078: Non-SASL Authentication
        |  %% (http://xmpp.org/extensions/xep-0078.html).
        |  wait_for_legacy_auth(#state{} = S) -&gt;
<font color=red>     0..|      fsm_next_state(wait_for_auth, S).</font>
        |  
        |  stream_start_features_before_auth(#state{server = Server} = S) -&gt;
<font color=red>     0..|      SASLState = cyrsasl:server_new(&lt;&lt;"jabber"&gt;&gt;, Server, &lt;&lt;&gt;&gt;, [],</font>
        |                                     mk_get_password_with_authmodule(Server),
        |                                     mk_check_password3_with_authmodule(Server),
        |                                     mk_check_password5_with_authmodule(Server)),
<font color=red>     0..|      SockMod = (S#state.sockmod):get_sockmod(S#state.socket),</font>
        |  
<font color=red>     0..|      send_element(S, stream_features(determine_features(SockMod, S))),</font>
<font color=red>     0..|      fsm_next_state(wait_for_feature_request,</font>
        |                     S#state{sasl_state = SASLState}).
        |  
        |  stream_start_features_before_bind(#state{server = Server} = S) -&gt;
<font color=red>     0..|      Features = ( [#xmlel{name = &lt;&lt;"bind"&gt;&gt;,</font>
        |                           attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_BIND}]},
        |                    #xmlel{name = &lt;&lt;"session"&gt;&gt;,
        |                           attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_SESSION}]}]
        |                   ++ maybe_roster_versioning_feature(Server)
        |                   ++ hook_enabled_features(Server) ),
<font color=red>     0..|      send_element(S, stream_features(Features)),</font>
<font color=red>     0..|      fsm_next_state(wait_for_bind_or_resume, S).</font>
        |  
        |  maybe_roster_versioning_feature(Server) -&gt;
<font color=red>     0..|      ejabberd_hooks:run_fold(roster_get_versioning_feature,</font>
        |                              Server, [], [Server]).
        |  
        |  stream_features(FeatureElements) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"stream:features"&gt;&gt;,</font>
        |             children = FeatureElements}.
        |  
        |  %% From RFC 6120, section 5.3.1:
        |  %%
        |  %% If TLS is mandatory-to-negotiate, the receiving entity SHOULD NOT
        |  %% advertise support for any stream feature except STARTTLS during the
        |  %% initial stage of the stream negotiation process, because further stream
        |  %% features might depend on prior negotiation of TLS given the order of
        |  %% layers in XMPP (e.g., the particular SASL mechanisms offered by the
        |  %% receiving entity will likely depend on whether TLS has been negotiated).
        |  %%
        |  %% http://xmpp.org/rfcs/rfc6120.html#tls-rules-mtn
        |  determine_features(SockMod, #state{tls = TLS, tls_enabled = TLSEnabled,
        |                                     tls_required = TLSRequired,
        |                                     server = Server} = S) -&gt;
<font color=red>     0..|      OtherFeatures = maybe_compress_feature(SockMod, S)</font>
        |                   ++ maybe_sasl_mechanisms(Server)
        |                   ++ hook_enabled_features(Server),
<font color=red>     0..|      case can_use_tls(SockMod, TLS, TLSEnabled) of</font>
        |          true -&gt;
<font color=red>     0..|              case TLSRequired of</font>
<font color=red>     0..|                  true -&gt; [starttls(required)];</font>
<font color=red>     0..|                  _    -&gt; [starttls(optional)] ++ OtherFeatures</font>
        |              end;
        |          false -&gt;
<font color=red>     0..|              OtherFeatures</font>
        |      end.
        |  
        |  maybe_compress_feature(SockMod, #state{zlib = {ZLib, _}}) -&gt;
<font color=red>     0..|      case can_use_zlib_compression(ZLib, SockMod) of</font>
<font color=red>     0..|          true -&gt; [compression_zlib()];</font>
<font color=red>     0..|          _ -&gt; []</font>
        |      end.
        |  
        |  maybe_sasl_mechanisms(Server) -&gt;
<font color=red>     0..|      case cyrsasl:listmech(Server) of</font>
<font color=red>     0..|          [] -&gt; [];</font>
        |          Mechanisms -&gt;
<font color=red>     0..|              [#xmlel{name = &lt;&lt;"mechanisms"&gt;&gt;,</font>
        |                      attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_SASL}],
<font color=red>     0..|                      children = [ mechanism(S) || S &lt;- Mechanisms ]}]</font>
        |      end.
        |  
        |  hook_enabled_features(Server) -&gt;
<font color=red>     0..|      ejabberd_hooks:run_fold(c2s_stream_features, Server, [], [Server]).</font>
        |  
        |  starttls(TLSRequired)
        |    when TLSRequired =:= required;
        |         TLSRequired =:= optional -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"starttls"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_TLS}],
<font color=red>     0..|             children = [ #xmlel{name = &lt;&lt;"required"&gt;&gt;} || TLSRequired =:= required ]}.</font>
        |  
        |  can_use_tls(SockMod, TLS, TLSEnabled) -&gt;
<font color=red>     0..|      TLS == true andalso (TLSEnabled == false) andalso SockMod == gen_tcp.</font>
        |  
        |  can_use_zlib_compression(Zlib, SockMod) -&gt;
<font color=red>     0..|      Zlib andalso ( (SockMod == gen_tcp) orelse</font>
<font color=red>     0..|                     (SockMod == tls) ).</font>
        |  
        |  compression_zlib() -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"compression"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_FEATURE_COMPRESS}],
        |             children = [#xmlel{name = &lt;&lt;"method"&gt;&gt;,
        |                                children = [#xmlcdata{content = &lt;&lt;"zlib"&gt;&gt;}]}]}.
        |  
        |  mechanism(S) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"mechanism"&gt;&gt;,</font>
        |             children = [#xmlcdata{content = S}]}.
        |  
        |  mk_get_password_with_authmodule(Server) -&gt;
<font color=red>     0..|      fun(U) -&gt;</font>
<font color=red>     0..|              ejabberd_auth:get_password_with_authmodule(U, Server)</font>
        |      end.
        |  
        |  mk_check_password3_with_authmodule(Server) -&gt;
<font color=red>     0..|      fun(U, P) -&gt;</font>
<font color=red>     0..|              ejabberd_auth:check_password_with_authmodule(U, Server, P)</font>
        |      end.
        |  
        |  mk_check_password5_with_authmodule(Server) -&gt;
<font color=red>     0..|      fun(U, P, D, DG) -&gt;</font>
<font color=red>     0..|              ejabberd_auth:check_password_with_authmodule(U, Server, P, D, DG)</font>
        |      end.
        |  
        |  get_xml_lang(Attrs) -&gt;
<font color=red>     0..|      case xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs) of</font>
        |          Lang when size(Lang) =&lt; 35 -&gt;
        |              %% As stated in BCP47, 4.4.1:
        |              %% Protocols or specifications that
        |              %% specify limited buffer sizes for
        |              %% language tags MUST allow for
        |              %% language tags of at least 35 characters.
<font color=red>     0..|              Lang;</font>
        |          _ -&gt;
        |              %% Do not store long language tag to
        |              %% avoid possible DoS/flood attacks
<font color=red>     0..|             &lt;&lt;&gt;&gt;</font>
        |      end.
        |  
        |  default_language() -&gt;
<font color=red>     0..|      case ?MYLANG of</font>
<font color=red>     0..|          undefined -&gt; &lt;&lt;"en"&gt;&gt;;</font>
<font color=red>     0..|          DL -&gt; DL</font>
        |      end.
        |  
        |  -spec wait_for_auth(Item :: ejabberd:xml_stream_item(),
        |                      State :: state()) -&gt; fsm_return().
        |  wait_for_auth({xmlstreamelement,
        |                 #xmlel{name = &lt;&lt;"enable"&gt;&gt;} = El}, StateData) -&gt;
<font color=red>     0..|      maybe_unexpected_sm_request(wait_for_auth, El, StateData);</font>
        |  wait_for_auth({xmlstreamelement, El}, StateData) -&gt;
<font color=red>     0..|      case is_auth_packet(El) of</font>
        |          {auth, _ID, get, {U, _, _, _}} -&gt;
<font color=red>     0..|              XE = jlib:make_result_iq_reply(El),</font>
<font color=red>     0..|              UCdata = case U of</font>
        |                           &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|                               [];</font>
        |                           _ -&gt;
<font color=red>     0..|                               [#xmlcdata{content = U}]</font>
        |                       end,
<font color=red>     0..|              Res = case ejabberd_auth:plain_password_required(</font>
        |                           StateData#state.server) of
        |                        false -&gt;
<font color=red>     0..|                            XE#xmlel{children = [#xmlel{name = &lt;&lt;"query"&gt;&gt;,</font>
        |                                                        attrs = [{&lt;&lt;"xmlns"&gt;&gt;,
        |                                                                  ?NS_AUTH}],
        |                                                        children = [#xmlel{name = &lt;&lt;"username"&gt;&gt;,
        |                                                                           children = UCdata},
        |                                                                    #xmlel{name = &lt;&lt;"password"&gt;&gt;},
        |                                                                    #xmlel{name = &lt;&lt;"digest"&gt;&gt;},
        |                                                                    #xmlel{name = &lt;&lt;"resource"&gt;&gt;}]}]};
        |                        true -&gt;
<font color=red>     0..|                            XE#xmlel{children = [#xmlel{name = &lt;&lt;"query"&gt;&gt;,</font>
        |                                                        attrs = [{&lt;&lt;"xmlns"&gt;&gt;,
        |                                                                  ?NS_AUTH}],
        |                                                        children = [#xmlel{name = &lt;&lt;"username"&gt;&gt;,
        |                                                                           children = UCdata},
        |                                                                    #xmlel{name = &lt;&lt;"password"&gt;&gt;},
        |                                                                    #xmlel{name = &lt;&lt;"resource"&gt;&gt;}]}]}
        |                    end,
<font color=red>     0..|              send_element(StateData, Res),</font>
<font color=red>     0..|              fsm_next_state(wait_for_auth, StateData);</font>
        |          {auth, _ID, set, {_U, _P, _D, &lt;&lt;&gt;&gt;}} -&gt;
<font color=red>     0..|              Err = jlib:make_error_reply(</font>
        |                      El,
        |                      ?ERR_AUTH_NO_RESOURCE_PROVIDED(StateData#state.lang)),
<font color=red>     0..|              send_element(StateData, Err),</font>
<font color=red>     0..|              fsm_next_state(wait_for_auth, StateData);</font>
        |          {auth, _ID, set, {U, P, D, R}} -&gt;
<font color=red>     0..|              JID = jid:make(U, StateData#state.server, R),</font>
<font color=red>     0..|              maybe_legacy_auth(JID, El, StateData, U, P, D, R);</font>
        |                          _ -&gt;
<font color=red>     0..|              process_unauthenticated_stanza(StateData, El),</font>
<font color=red>     0..|                              fsm_next_state(wait_for_auth, StateData)</font>
        |                      end;
        |  wait_for_auth(timeout, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  wait_for_auth({xmlstreamend, _Name}, StateData) -&gt;
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  wait_for_auth({xmlstreamerror, _}, StateData) -&gt;
<font color=red>     0..|      send_element(StateData, ?INVALID_XML_ERR),</font>
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  wait_for_auth(closed, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData}.</font>
        |  
        |  maybe_legacy_auth(error, El, StateData, U, _P, _D, R) -&gt;
<font color=red>     0..|                              ?INFO_MSG(</font>
        |                                 "(~w) Forbidden legacy authentication for "
        |                                 "username '~s' with resource '~s'",
        |                                 [StateData#state.socket, U, R]),
<font color=red>     0..|                              Err = jlib:make_error_reply(El, ?ERR_JID_MALFORMED),</font>
<font color=red>     0..|                              send_element(StateData, Err),</font>
<font color=red>     0..|                              fsm_next_state(wait_for_auth, StateData);</font>
        |  maybe_legacy_auth(JID, El, StateData, U, P, D, R) -&gt;
<font color=red>     0..|      case user_allowed(JID, StateData) of</font>
        |                          true -&gt;
<font color=red>     0..|              do_legacy_auth(JID, El, StateData, U, P, D, R);</font>
        |          _ -&gt;
        |  
<font color=red>     0..|                              ?INFO_MSG(</font>
        |                                 "(~w) Forbidden legacy authentication for ~s",
        |                                 [StateData#state.socket,
        |                                  jid:to_binary(JID)]),
<font color=red>     0..|                              Err = jlib:make_error_reply(El, ?ERR_NOT_ALLOWED),</font>
<font color=red>     0..|                              send_element(StateData, Err),</font>
<font color=red>     0..|                              fsm_next_state(wait_for_auth, StateData)</font>
        |      end.
        |  
        |  do_legacy_auth(JID, El, StateData, U, P, D, R) -&gt;
<font color=red>     0..|      case check_password_with_auth_module(U, StateData, P, D) of</font>
        |          {true, AuthModule} -&gt;
<font color=red>     0..|              do_open_legacy_session(El, StateData, U, R, JID,</font>
        |                                     AuthModule);
        |          _ -&gt;
<font color=red>     0..|              IP = peerip(StateData#state.sockmod, StateData#state.socket),</font>
<font color=red>     0..|              ?INFO_MSG(</font>
        |                 "(~w) Failed legacy authentication for ~s from IP ~s (~w)",
        |                 [StateData#state.socket,
        |                  jid:to_binary(JID), jlib:ip_to_list(IP), IP]),
<font color=red>     0..|              Err = jlib:make_error_reply(</font>
        |                      El, ?ERR_NOT_AUTHORIZED),
<font color=red>     0..|              ejabberd_hooks:run(auth_failed, StateData#state.server,</font>
        |                                 [U, StateData#state.server]),
<font color=red>     0..|              send_element(StateData, Err),</font>
<font color=red>     0..|              fsm_next_state(wait_for_auth, StateData)</font>
        |      end.
        |  
        |  check_password_with_auth_module(User, #state{server = Server}, Password, &lt;&lt;&gt;&gt;) -&gt;
<font color=red>     0..|      ejabberd_auth:check_password_with_authmodule(User, Server, Password);</font>
        |  check_password_with_auth_module(User, StateData, _, Digest) -&gt;
<font color=red>     0..|      DGen = fun(PW) -&gt;</font>
<font color=red>     0..|                     Sid = StateData#state.streamid,</font>
<font color=red>     0..|                     sha:sha1_hex(&lt;&lt;Sid/binary,</font>
        |                                    PW/binary&gt;&gt;)
        |             end,
<font color=red>     0..|      ejabberd_auth:check_password_with_authmodule(User, StateData#state.server,</font>
        |                                                   &lt;&lt;&gt;&gt;, Digest, DGen).
        |  
        |  do_open_legacy_session(El, StateData, U, R, JID, AuthModule) -&gt;
<font color=red>     0..|      ?INFO_MSG(</font>
        |         "(~w) Accepted legacy authentication for ~s by ~p",
        |         [StateData#state.socket,
        |          jid:to_binary(JID), AuthModule]),
<font color=red>     0..|      Res1 = jlib:make_result_iq_reply(El),</font>
<font color=red>     0..|      Res = Res1#xmlel{children = []},</font>
<font color=red>     0..|      send_element(StateData, Res),</font>
<font color=red>     0..|      NewStateData = StateData#state{</font>
        |                       user = U,
        |                       resource = R,
        |                       jid = JID,
        |                       auth_module = AuthModule},
<font color=red>     0..|      do_open_session_common(JID, NewStateData).</font>
        |  
        |  -spec wait_for_feature_request(Item :: ejabberd:xml_stream_item(),
        |                                 State :: state()) -&gt; fsm_return().
        |  wait_for_feature_request({xmlstreamelement,
        |                            #xmlel{name = &lt;&lt;"enable"&gt;&gt;} = El}, StateData) -&gt;
<font color=red>     0..|      maybe_unexpected_sm_request(wait_for_feature_request, El, StateData);</font>
        |  wait_for_feature_request({xmlstreamelement, El}, StateData) -&gt;
<font color=red>     0..|      #xmlel{name = Name, attrs = Attrs, children = Els} = El,</font>
<font color=red>     0..|      {Zlib, ZlibLimit} = StateData#state.zlib,</font>
<font color=red>     0..|      TLS = StateData#state.tls,</font>
<font color=red>     0..|      TLSEnabled = StateData#state.tls_enabled,</font>
<font color=red>     0..|      TLSRequired = StateData#state.tls_required,</font>
<font color=red>     0..|      SockMod = (StateData#state.sockmod):get_sockmod(StateData#state.socket),</font>
<font color=red>     0..|      case {xml:get_attr_s(&lt;&lt;"xmlns"&gt;&gt;, Attrs), Name} of</font>
        |          {?NS_SASL, &lt;&lt;"auth"&gt;&gt;} when TLSEnabled or not TLSRequired -&gt;
<font color=red>     0..|              Mech = xml:get_attr_s(&lt;&lt;"mechanism"&gt;&gt;, Attrs),</font>
<font color=red>     0..|              ClientIn = jlib:decode_base64(xml:get_cdata(Els)),</font>
<font color=red>     0..|              StepResult = cyrsasl:server_start(StateData#state.sasl_state, Mech, ClientIn),</font>
<font color=red>     0..|              {NewFSMState, NewStateData} = handle_sasl_step(StateData, StepResult),</font>
<font color=red>     0..|              fsm_next_state(NewFSMState, NewStateData);</font>
        |          {?NS_TLS_BIN, &lt;&lt;"starttls"&gt;&gt;} when TLS == true,
        |                                             TLSEnabled == false,
        |                                             SockMod == gen_tcp -&gt;
<font color=red>     0..|              TLSOpts = case ejabberd_config:get_local_option(</font>
        |                               {domain_certfile, StateData#state.server}) of
        |                            undefined -&gt;
<font color=red>     0..|                                StateData#state.tls_options;</font>
        |                            CertFile -&gt;
<font color=red>     0..|                                [{certfile, CertFile} |</font>
        |                                 lists:keydelete(
        |                                   certfile, 1, StateData#state.tls_options)]
        |                        end,
<font color=red>     0..|              Socket = StateData#state.socket,</font>
<font color=red>     0..|              TLSSocket = (StateData#state.sockmod):starttls(</font>
        |                                                      Socket, TLSOpts,
        |                                                      exml:to_binary(tls_proceed())),
<font color=red>     0..|              fsm_next_state(wait_for_stream,</font>
        |                             StateData#state{socket = TLSSocket,
        |                                             streamid = new_id(),
        |                                             tls_enabled = true
        |                                            });
        |          {?NS_COMPRESS_BIN, &lt;&lt;"compress"&gt;&gt;} when Zlib == true,
        |                                                  ((SockMod == gen_tcp) or
        |                                                   (SockMod == tls)) -&gt;
<font color=red>     0..|              case xml:get_subtag(El, &lt;&lt;"method"&gt;&gt;) of</font>
        |                  false -&gt;
<font color=red>     0..|                      send_element(StateData, compress_setup_failed()),</font>
<font color=red>     0..|                      fsm_next_state(wait_for_feature_request, StateData);</font>
        |                  Method -&gt;
<font color=red>     0..|                      case xml:get_tag_cdata(Method) of</font>
        |                          &lt;&lt;"zlib"&gt;&gt; -&gt;
<font color=red>     0..|                              Socket = StateData#state.socket,</font>
<font color=red>     0..|                              ZlibSocket = (StateData#state.sockmod):compress(Socket, ZlibLimit,</font>
        |                                                                              exml:to_binary(compressed())),
<font color=red>     0..|                              fsm_next_state(wait_for_stream,</font>
        |                                             StateData#state{socket = ZlibSocket,
        |                                                             streamid = new_id()
        |                                                            });
        |                          _ -&gt;
<font color=red>     0..|                              send_element(StateData, compress_unsupported_method()),</font>
<font color=red>     0..|                              fsm_next_state(wait_for_feature_request, StateData)</font>
        |                      end
        |              end;
        |          _ -&gt;
<font color=red>     0..|              if</font>
        |                  TLSRequired and not TLSEnabled -&gt;
<font color=red>     0..|                      Lang = StateData#state.lang,</font>
<font color=red>     0..|                      send_element(StateData, ?POLICY_VIOLATION_ERR(</font>
        |                                                 Lang, &lt;&lt;"Use of STARTTLS required"&gt;&gt;)),
<font color=red>     0..|                      send_trailer(StateData),</font>
<font color=red>     0..|                      {stop, normal, StateData};</font>
        |                  true -&gt;
<font color=red>     0..|                      process_unauthenticated_stanza(StateData, El),</font>
<font color=red>     0..|                      fsm_next_state(wait_for_feature_request, StateData)</font>
        |              end
        |      end;
        |  wait_for_feature_request(timeout, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  wait_for_feature_request({xmlstreamend, _Name}, StateData) -&gt;
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  wait_for_feature_request({xmlstreamerror, _}, StateData) -&gt;
<font color=red>     0..|      send_element(StateData, ?INVALID_XML_ERR),</font>
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  wait_for_feature_request(closed, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData}.</font>
        |  
        |  compressed() -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"compressed"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_COMPRESS}]}.
        |  
        |  compress_unsupported_method() -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"failure"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_COMPRESS}],
        |             children = [#xmlel{name = &lt;&lt;"unsupported-method"&gt;&gt;}]}.
        |  
        |  tls_proceed() -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"proceed"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_TLS}]}.
        |  
        |  compress_setup_failed() -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"failure"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_COMPRESS}],
        |             children = [#xmlel{name = &lt;&lt;"setup-failed"&gt;&gt;}]}.
        |  
        |  -spec wait_for_sasl_response(Item :: ejabberd:xml_stream_item(),
        |                               State :: state()) -&gt; fsm_return().
        |  wait_for_sasl_response({xmlstreamelement,
        |                          #xmlel{name = &lt;&lt;"enable"&gt;&gt;} = El}, StateData) -&gt;
<font color=red>     0..|      maybe_unexpected_sm_request(wait_for_sasl_response, El, StateData);</font>
        |  wait_for_sasl_response({xmlstreamelement, El}, StateData) -&gt;
<font color=red>     0..|      #xmlel{name = Name, attrs = Attrs, children = Els} = El,</font>
<font color=red>     0..|      case {xml:get_attr_s(&lt;&lt;"xmlns"&gt;&gt;, Attrs), Name} of</font>
        |          {?NS_SASL, &lt;&lt;"response"&gt;&gt;} -&gt;
<font color=red>     0..|              ClientIn = jlib:decode_base64(xml:get_cdata(Els)),</font>
<font color=red>     0..|              StepResult = cyrsasl:server_step(StateData#state.sasl_state,ClientIn),</font>
<font color=red>     0..|              {NewFSMState, NewStateData} = handle_sasl_step(StateData, StepResult),</font>
<font color=red>     0..|              fsm_next_state(NewFSMState, NewStateData);</font>
        |          _ -&gt;
<font color=red>     0..|              process_unauthenticated_stanza(StateData, El),</font>
<font color=red>     0..|              fsm_next_state(wait_for_feature_request, StateData)</font>
        |      end;
        |  wait_for_sasl_response(timeout, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  wait_for_sasl_response({xmlstreamend, _Name}, StateData) -&gt;
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  wait_for_sasl_response({xmlstreamerror, _}, StateData) -&gt;
<font color=red>     0..|      send_element(StateData, ?INVALID_XML_ERR),</font>
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  wait_for_sasl_response(closed, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData}.</font>
        |  
        |  -spec wait_for_bind_or_resume(Item :: ejabberd:xml_stream_item(),
        |                                State :: state()) -&gt; fsm_return().
        |  wait_for_bind_or_resume({xmlstreamelement,
        |                           #xmlel{name = &lt;&lt;"enable"&gt;&gt;} = El}, StateData) -&gt;
<font color=red>     0..|      maybe_unexpected_sm_request(wait_for_bind_or_resume, El, StateData);</font>
        |  wait_for_bind_or_resume({xmlstreamelement,
        |                           #xmlel{name = &lt;&lt;"resume"&gt;&gt;} = El}, StateData) -&gt;
<font color=red>     0..|      maybe_resume_session(wait_for_bind_or_resume, El, StateData);</font>
        |  wait_for_bind_or_resume({xmlstreamelement, El}, StateData) -&gt;
<font color=red>     0..|      case jlib:iq_query_info(El) of</font>
        |          #iq{type = set, xmlns = ?NS_BIND, sub_el = SubEl} = IQ -&gt;
<font color=red>     0..|              U = StateData#state.user,</font>
<font color=red>     0..|              R1 = xml:get_path_s(SubEl, [{elem, &lt;&lt;"resource"&gt;&gt;}, cdata]),</font>
<font color=red>     0..|              R = case jid:resourceprep(R1) of</font>
<font color=red>     0..|                      error -&gt; error;</font>
        |                      &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|                          list_to_binary(lists:concat(</font>
        |                                           [randoms:get_string() | tuple_to_list(now())]));
<font color=red>     0..|                      Resource -&gt; Resource</font>
        |                  end,
<font color=red>     0..|              case R of</font>
        |                  error -&gt;
<font color=red>     0..|                      Err = jlib:make_error_reply(El, ?ERR_BAD_REQUEST),</font>
<font color=red>     0..|                      send_element(StateData, Err),</font>
<font color=red>     0..|                      fsm_next_state(wait_for_bind_or_resume, StateData);</font>
        |                  _ -&gt;
<font color=red>     0..|                      JID = jid:make(U, StateData#state.server, R),</font>
<font color=red>     0..|                      Res = IQ#iq{type = result,</font>
        |                                  sub_el = [#xmlel{name = &lt;&lt;"bind"&gt;&gt;,
        |                                                   attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_BIND}],
        |                                                   children = [#xmlel{name = &lt;&lt;"jid"&gt;&gt;,
        |                                                                      children = [#xmlcdata{content = jid:to_binary(JID)}]}]}]},
<font color=red>     0..|                      XmlEl = jlib:iq_to_xml(Res),</font>
<font color=red>     0..|                      send_element(StateData, XmlEl),</font>
<font color=red>     0..|                      fsm_next_state(wait_for_session_or_sm,</font>
        |                                     StateData#state{resource = R, jid = JID})
        |              end;
        |          _ -&gt;
<font color=red>     0..|              fsm_next_state(wait_for_bind_or_resume, StateData)</font>
        |      end;
        |  
        |  wait_for_bind_or_resume(timeout, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  
        |  wait_for_bind_or_resume({xmlstreamend, _Name}, StateData) -&gt;
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  
        |  wait_for_bind_or_resume({xmlstreamerror, _}, StateData) -&gt;
<font color=red>     0..|      send_element(StateData, ?INVALID_XML_ERR),</font>
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  
        |  wait_for_bind_or_resume(closed, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData}.</font>
        |  
        |  -spec wait_for_session_or_sm(Item :: ejabberd:xml_stream_item(),
        |                               State :: state()) -&gt; fsm_return().
        |  wait_for_session_or_sm({xmlstreamelement,
        |                          #xmlel{name = &lt;&lt;"enable"&gt;&gt;} = El}, StateData) -&gt;
<font color=red>     0..|      maybe_enable_stream_mgmt(wait_for_session_or_sm, El, StateData);</font>
        |  
        |  wait_for_session_or_sm({xmlstreamelement,
        |                          #xmlel{name = &lt;&lt;"r"&gt;&gt;} = El}, StateData) -&gt;
<font color=red>     0..|      maybe_send_sm_ack(xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, El),</font>
        |                        StateData#state.stream_mgmt,
        |                        StateData#state.stream_mgmt_in,
        |                        wait_for_session_or_sm, StateData);
        |  
        |  wait_for_session_or_sm({xmlstreamelement, El}, StateData0) -&gt;
<font color=red>     0..|      StateData = maybe_increment_sm_incoming(StateData0#state.stream_mgmt,</font>
        |                                              StateData0),
<font color=red>     0..|      case jlib:iq_query_info(El) of</font>
        |          #iq{type = set, xmlns = ?NS_SESSION} -&gt;
<font color=red>     0..|              maybe_open_session(El, StateData);</font>
        |          _ -&gt;
<font color=red>     0..|              fsm_next_state(wait_for_session_or_sm, StateData)</font>
        |      end;
        |  
        |  wait_for_session_or_sm(timeout, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  
        |  wait_for_session_or_sm({xmlstreamend, _Name}, StateData) -&gt;
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  
        |  wait_for_session_or_sm({xmlstreamerror, _}, StateData) -&gt;
<font color=red>     0..|      send_element(StateData, ?INVALID_XML_ERR),</font>
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  
        |  wait_for_session_or_sm(closed, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData}.</font>
        |  
        |  maybe_open_session(El, #state{jid = JID} = StateData) -&gt;
<font color=red>     0..|      case user_allowed(JID, StateData) of</font>
        |          true -&gt;
<font color=red>     0..|              do_open_session(El, JID, StateData);</font>
        |          _ -&gt;
<font color=red>     0..|              ejabberd_hooks:run(forbidden_session_hook,</font>
        |                                 StateData#state.server, [JID]),
<font color=red>     0..|              ?INFO_MSG("(~w) Forbidden session for ~s",</font>
        |                        [StateData#state.socket,
        |                         jid:to_binary(JID)]),
<font color=red>     0..|              Err = jlib:make_error_reply(El, ?ERR_NOT_ALLOWED),</font>
<font color=red>     0..|              send_element(StateData, Err),</font>
<font color=red>     0..|              fsm_next_state(wait_for_session_or_sm, StateData)</font>
        |      end.
        |  
        |  do_open_session(El, JID, StateData) -&gt;
<font color=red>     0..|                      ?INFO_MSG("(~w) Opened session for ~s",</font>
        |                                [StateData#state.socket,
        |                                 jid:to_binary(JID)]),
<font color=red>     0..|                      Res = jlib:make_result_iq_reply(El),</font>
<font color=red>     0..|                      Packet = {jid:to_bare(StateData#state.jid), StateData#state.jid, Res},</font>
<font color=red>     0..|                      {_, _, NewStateData0, _} = send_and_maybe_buffer_stanza(Packet, StateData, wait_for_session_or_sm),</font>
<font color=red>     0..|      do_open_session_common(JID, NewStateData0).</font>
        |  
        |  do_open_session_common(JID, #state{user = U, resource = R} = NewStateData0) -&gt;
<font color=red>     0..|                      change_shaper(NewStateData0, JID),</font>
<font color=red>     0..|                      {Fs, Ts, Pending} = ejabberd_hooks:run_fold(</font>
        |                                            roster_get_subscription_lists,
        |                                            NewStateData0#state.server,
        |                                            {[], [], []},
        |                                            [U, NewStateData0#state.server]),
<font color=red>     0..|                      LJID = jid:to_lower(jid:to_bare(JID)),</font>
<font color=red>     0..|                      Fs1 = [LJID | Fs],</font>
<font color=red>     0..|                      Ts1 = [LJID | Ts],</font>
<font color=red>     0..|                      PrivList =</font>
        |                      ejabberd_hooks:run_fold(
        |                        privacy_get_user_list, NewStateData0#state.server,
        |                        #userlist{},
        |                        [U, NewStateData0#state.server]),
<font color=red>     0..|                      SID = {now(), self()},</font>
<font color=red>     0..|                      Conn = get_conn_type(NewStateData0),</font>
<font color=red>     0..|                      Info = [{ip, NewStateData0#state.ip}, {conn, Conn},</font>
        |                              {auth_module, NewStateData0#state.auth_module}],
<font color=red>     0..|                      ejabberd_sm:open_session(</font>
        |                        SID, U, NewStateData0#state.server, R, Info),
<font color=red>     0..|                      NewStateData =</font>
        |                      NewStateData0#state{
        |                        sid = SID,
        |                        conn = Conn,
        |                        pres_f = ?SETS:from_list(Fs1),
        |                        pres_t = ?SETS:from_list(Ts1),
        |                        pending_invitations = Pending,
        |                        privacy_list = PrivList},
<font color=red>     0..|                      fsm_next_state_pack(session_established,</font>
        |                          NewStateData).
        |  
        |  -spec session_established(Item :: ejabberd:xml_stream_item(),
        |                            State :: state()) -&gt; fsm_return().
        |  session_established({xmlstreamelement,
        |                       #xmlel{name = &lt;&lt;"enable"&gt;&gt;} = El}, StateData) -&gt;
<font color=red>     0..|      maybe_enable_stream_mgmt(session_established, El, StateData);</font>
        |  
        |  session_established({xmlstreamelement,
        |                       #xmlel{name = &lt;&lt;"a"&gt;&gt;} = El}, StateData) -&gt;
<font color=red>     0..|      stream_mgmt_handle_ack(session_established, El, StateData);</font>
        |  
        |  session_established({xmlstreamelement,
        |                       #xmlel{name = &lt;&lt;"r"&gt;&gt;} = El}, StateData) -&gt;
<font color=red>     0..|      maybe_send_sm_ack(xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, El),</font>
        |                        StateData#state.stream_mgmt,
        |                        StateData#state.stream_mgmt_in,
        |                        session_established, StateData);
        |  
        |  session_established({xmlstreamelement, El}, StateData) -&gt;
<font color=red>     0..|      FromJID = StateData#state.jid,</font>
        |      % Check 'from' attribute in stanza RFC 3920 Section 9.1.2
<font color=red>     0..|      case check_from(El, FromJID) of</font>
        |          'invalid-from' -&gt;
<font color=red>     0..|              send_element(StateData, ?INVALID_FROM),</font>
<font color=red>     0..|              send_trailer(StateData),</font>
<font color=red>     0..|              {stop, normal, StateData};</font>
        |          _NewEl -&gt;
<font color=red>     0..|              NewState = maybe_increment_sm_incoming(StateData#state.stream_mgmt,</font>
        |                                                     StateData),
<font color=red>     0..|              check_amp_maybe_send(FromJID#jid.lserver, NewState, {FromJID, El})</font>
        |      end;
        |  
        |  %% We hibernate the process to reduce memory consumption after a
        |  %% configurable activity timeout
        |  session_established(timeout, StateData) -&gt;
        |      %% TODO: Options must be stored in state:
<font color=red>     0..|      Options = [],</font>
<font color=red>     0..|      proc_lib:hibernate(?GEN_FSM, enter_loop,</font>
        |                         [?MODULE, Options, session_established, StateData]),
<font color=red>     0..|      fsm_next_state(session_established, StateData);</font>
        |  session_established({xmlstreamend, _Name}, StateData) -&gt;
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  
        |  session_established({xmlstreamerror, &lt;&lt;"XML stanza is too big"&gt;&gt; = E}, StateData) -&gt;
<font color=red>     0..|      send_element(StateData, ?POLICY_VIOLATION_ERR(StateData#state.lang, E)),</font>
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  session_established({xmlstreamerror, _}, StateData) -&gt;
<font color=red>     0..|      send_element(StateData, ?INVALID_XML_ERR),</font>
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  session_established(closed, StateData) -&gt;
<font color=red>     0..|      ?DEBUG("Session established closed - trying to enter resume_session",[]),</font>
<font color=red>     0..|      maybe_enter_resume_session(StateData#state.stream_mgmt_id, StateData).</font>
        |  
        |  
        |  %%% XEP-0079 (AMP) related
        |  check_amp_maybe_send(Host, State, {_FromJID, _El} = HookData) -&gt;
<font color=red>     0..|      case ejabberd_hooks:run_fold(amp_check_packet, Host, HookData, []) of</font>
<font color=red>     0..|          drop      -&gt; fsm_next_state(session_established, State);</font>
<font color=red>     0..|          {_,NewEl} -&gt; session_established2(NewEl, State)</font>
        |      end.
        |  
        |  %% @doc Process packets sent by user (coming from user on c2s XMPP
        |  %% connection)
        |  -spec session_established2(El :: jlib:xmlel(), state()) -&gt; fsm_return().
        |  session_established2(El, StateData) -&gt;
<font color=red>     0..|      #xmlel{name = Name, attrs = Attrs} = El,</font>
<font color=red>     0..|      User = StateData#state.user,</font>
<font color=red>     0..|      Server = StateData#state.server,</font>
<font color=red>     0..|      FromJID = StateData#state.jid,</font>
<font color=red>     0..|      To = xml:get_attr_s(&lt;&lt;"to"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      ToJID = case To of</font>
        |                  &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|                      jid:make(User, Server, &lt;&lt;&gt;&gt;);</font>
        |                  _ -&gt;
<font color=red>     0..|                      jid:from_binary(To)</font>
        |              end,
<font color=red>     0..|      NewEl1 = jlib:remove_attr(&lt;&lt;"xmlns"&gt;&gt;, jlib:remove_delay_tags(El)),</font>
<font color=red>     0..|      NewEl = case xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs) of</font>
        |                  &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|                      case StateData#state.lang of</font>
<font color=red>     0..|                          &lt;&lt;&gt;&gt; -&gt; NewEl1;</font>
        |                          Lang -&gt;
<font color=red>     0..|                              xml:replace_tag_attr(&lt;&lt;"xml:lang"&gt;&gt;, Lang, NewEl1)</font>
        |                      end;
        |                  _ -&gt;
<font color=red>     0..|                      NewEl1</font>
        |              end,
<font color=red>     0..|      NewState =</font>
        |      case ToJID of
        |          error -&gt;
<font color=red>     0..|              case xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs) of</font>
<font color=red>     0..|                  &lt;&lt;"error"&gt;&gt; -&gt; StateData;</font>
<font color=red>     0..|                  &lt;&lt;"result"&gt;&gt; -&gt; StateData;</font>
        |                  _ -&gt;
<font color=red>     0..|                      Err = jlib:make_error_reply(NewEl, ?ERR_JID_MALFORMED),</font>
<font color=red>     0..|                      send_element(StateData, Err),</font>
<font color=red>     0..|                      StateData</font>
        |              end;
        |          _ -&gt;
<font color=red>     0..|              case Name of</font>
        |                  &lt;&lt;"presence"&gt;&gt; -&gt;
<font color=red>     0..|                      PresenceEl = ejabberd_hooks:run_fold(</font>
        |                                     c2s_update_presence,
        |                                     Server,
        |                                     NewEl,
        |                                     [User, Server]),
<font color=red>     0..|                      ejabberd_hooks:run(</font>
        |                        user_send_packet,
        |                        Server,
        |                        [FromJID, ToJID, PresenceEl]),
<font color=red>     0..|                      case ToJID of</font>
        |                          #jid{user = User,
        |                               server = Server,
        |                               resource = &lt;&lt;&gt;&gt;} -&gt;
<font color=red>     0..|                              ?DEBUG("presence_update(~p,~n\t~p,~n\t~p)",</font>
        |                                     [FromJID, PresenceEl, StateData]),
<font color=red>     0..|                              presence_update(FromJID, PresenceEl,</font>
        |                                              StateData);
        |                          _ -&gt;
<font color=red>     0..|                              presence_track(FromJID, ToJID, PresenceEl,</font>
        |                                             StateData)
        |                      end;
        |                  &lt;&lt;"iq"&gt;&gt; -&gt;
<font color=red>     0..|                      case jlib:iq_query_info(NewEl) of</font>
        |                          #iq{xmlns = Xmlns} = IQ
        |                            when Xmlns == ?NS_PRIVACY;
        |                                 Xmlns == ?NS_BLOCKING -&gt;
<font color=red>     0..|                              process_privacy_iq(</font>
        |                                FromJID, ToJID, IQ, StateData);
        |                          _ -&gt;
<font color=red>     0..|                              ejabberd_hooks:run(</font>
        |                                user_send_packet,
        |                                Server,
        |                                [FromJID, ToJID, NewEl]),
<font color=red>     0..|                              check_privacy_route(FromJID, StateData, FromJID, ToJID, NewEl),</font>
<font color=red>     0..|                              StateData</font>
        |                      end;
        |                  &lt;&lt;"message"&gt;&gt; -&gt;
<font color=red>     0..|                      ejabberd_hooks:run(user_send_packet,</font>
        |                                         Server,
        |                                         [FromJID, ToJID, NewEl]),
<font color=red>     0..|                      check_privacy_route(FromJID, StateData, FromJID,</font>
        |                                          ToJID, NewEl),
<font color=red>     0..|                      StateData;</font>
        |                  _ -&gt;
<font color=red>     0..|                      StateData</font>
        |              end
        |      end,
<font color=red>     0..|      ejabberd_hooks:run(c2s_loop_debug, [{xmlstreamelement, El}]),</font>
<font color=red>     0..|      fsm_next_state(session_established, NewState).</font>
        |  
        |  %%-------------------------------------------------------------------------
        |  %% session may be terminated for exmaple by mod_ping there is still valid
        |  %% connection and resource want to send stanza.
        |  resume_session({xmlstreamelement, _}, StateData) -&gt;
<font color=red>     0..|      Err = ?POLICY_VIOLATION_ERR(StateData#state.lang,</font>
        |                                  &lt;&lt;"session in resume state cannot accept incoming stanzas"&gt;&gt;),
<font color=red>     0..|      maybe_send_element_safe(StateData, Err),</font>
<font color=red>     0..|      maybe_send_trailer_safe(StateData),</font>
<font color=red>     0..|      {next_state, resume_session, StateData, hibernate};</font>
        |  
        |  %%-------------------------------------------------------------------------
        |  %% ignore mod_ping closed messages because we are already in resume session
        |  %% state
        |  resume_session(closed, StateData) -&gt;
<font color=red>     0..|      {next_state, resume_session, StateData, hibernate};</font>
        |  resume_session(timeout, StateData) -&gt;
<font color=red>     0..|      {next_state, resume_session, StateData, hibernate};</font>
        |  resume_session(Msg, StateData) -&gt;
<font color=red>     0..|      ?WARNING_MSG("unexpected message ~p",[Msg]),</font>
<font color=red>     0..|      {next_state, resume_session, StateData, hibernate}.</font>
        |  
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: StateName/3
        |  %% Returns: {next_state, NextStateName, NextStateData}            |
        |  %%          {next_state, NextStateName, NextStateData, Timeout}   |
        |  %%          {reply, Reply, NextStateName, NextStateData}          |
        |  %%          {reply, Reply, NextStateName, NextStateData, Timeout} |
        |  %%          {stop, Reason, NewStateData}                          |
        |  %%          {stop, Reason, Reply, NewStateData}
        |  %%----------------------------------------------------------------------
        |  
        |  session_established(resume, _From, SD) -&gt;
<font color=red>     0..|      handover_session(SD).</font>
        |  
        |  resume_session(resume, _From, SD) -&gt;
<font color=red>     0..|      handover_session(SD).</font>
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: handle_event/3
        |  %% Returns: {next_state, NextStateName, NextStateData}          |
        |  %%          {next_state, NextStateName, NextStateData, Timeout} |
        |  %%          {stop, Reason, NewStateData}
        |  %%----------------------------------------------------------------------
        |  handle_event(keep_alive_packet, session_established,
        |               #state{server = Server, jid = JID} = StateData) -&gt;
<font color=red>     0..|      ejabberd_hooks:run(user_sent_keep_alive, Server, [JID]),</font>
<font color=red>     0..|      fsm_next_state(session_established, StateData);</font>
        |  handle_event(_Event, StateName, StateData) -&gt;
<font color=red>     0..|      fsm_next_state(StateName, StateData).</font>
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: handle_sync_event/4
        |  %% Returns: {next_state, NextStateName, NextStateData}            |
        |  %%          {next_state, NextStateName, NextStateData, Timeout}   |
        |  %%          {reply, Reply, NextStateName, NextStateData}          |
        |  %%          {reply, Reply, NextStateName, NextStateData, Timeout} |
        |  %%          {stop, Reason, NewStateData}                          |
        |  %%          {stop, Reason, Reply, NewStateData}
        |  %%----------------------------------------------------------------------
        |  -spec handle_sync_event(Evt :: atom(),
        |                          From :: any(),
        |                          StateName :: statename(),
        |                          State :: state())
        |  -&gt; {'reply', Reply :: [any()], statename(), state()}
        |     | {'reply', Reply :: 'ok' | {_,_,_,_}, statename(), state(), integer()}.
        |  handle_sync_event(get_presence, _From, StateName, StateData) -&gt;
<font color=red>     0..|      User = StateData#state.user,</font>
<font color=red>     0..|      PresLast = StateData#state.pres_last,</font>
        |  
<font color=red>     0..|      Show = get_showtag(PresLast),</font>
<font color=red>     0..|      Status = get_statustag(PresLast),</font>
<font color=red>     0..|      Resource = StateData#state.resource,</font>
        |  
<font color=red>     0..|      Reply = {User, Resource, Show, Status},</font>
<font color=red>     0..|      fsm_reply(Reply, StateName, StateData);</font>
        |  handle_sync_event(get_subscribed, _From, StateName, StateData) -&gt;
<font color=red>     0..|      Subscribed = ?SETS:to_list(StateData#state.pres_f),</font>
<font color=red>     0..|      {reply, Subscribed, StateName, StateData};</font>
        |  handle_sync_event(_Event, _From, StateName, StateData) -&gt;
<font color=red>     0..|      Reply = ok,</font>
<font color=red>     0..|      fsm_reply(Reply, StateName, StateData).</font>
        |  
        |  
        |  code_change(_OldVsn, StateName, StateData, _Extra) -&gt;
<font color=red>     0..|      {ok, StateName, StateData}.</font>
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: handle_info/3
        |  %% Returns: {next_state, NextStateName, NextStateData}          |
        |  %%          {next_state, NextStateName, NextStateData, Timeout} |
        |  %%          {stop, Reason, NewStateData}
        |  %%----------------------------------------------------------------------
        |  handle_info({send_text, Text}, StateName, StateData) -&gt;
<font color=red>     0..|      send_text(StateData, Text),</font>
<font color=red>     0..|      ejabberd_hooks:run(c2s_loop_debug, [Text]),</font>
<font color=red>     0..|      fsm_next_state(StateName, StateData);</font>
        |  handle_info(replaced, _StateName, StateData) -&gt;
<font color=red>     0..|      Lang = StateData#state.lang,</font>
<font color=red>     0..|      maybe_send_element_safe(StateData,</font>
        |                              ?SERRT_CONFLICT(Lang, &lt;&lt;"Replaced by new connection"&gt;&gt;)),
<font color=red>     0..|      maybe_send_trailer_safe(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData#state{authenticated = replaced}};</font>
        |  %% Process Packets that are to be send to the user
        |  handle_info({broadcast, Broadcast}, StateName, StateData) -&gt;
<font color=red>     0..|      ejabberd_hooks:run(c2s_loop_debug, [{broadcast, Broadcast}]),</font>
<font color=red>     0..|      ?DEBUG("broadcast=~p", [Broadcast]),</font>
<font color=red>     0..|      handle_broadcast_result(handle_routed_broadcast(Broadcast, StateData), StateName, StateData);</font>
        |  handle_info({route, From, To, Packet}, StateName, StateData) -&gt;
<font color=red>     0..|      ejabberd_hooks:run(c2s_loop_debug, [{route, From, To, Packet}]),</font>
<font color=red>     0..|      case Packet#xmlel.name of</font>
        |          &lt;&lt;"broadcast"&gt;&gt; -&gt;
<font color=red>     0..|              self() ! legacy_packet_to_broadcast(Packet),</font>
<font color=red>     0..|              fsm_next_state(StateName, StateData);</font>
        |          PacketName -&gt;
<font color=red>     0..|              case handle_routed(PacketName, From, To, Packet, StateData) of</font>
        |                  {true, NewAttrs, NewState} -&gt;
<font color=red>     0..|                      Attrs2 = jlib:replace_from_to_attrs(jid:to_binary(From),</font>
        |                                                          jid:to_binary(To),
        |                                                          NewAttrs),
<font color=red>     0..|                      FixedPacket = Packet#xmlel{attrs = Attrs2},</font>
<font color=red>     0..|                      ejabberd_hooks:run(user_receive_packet,</font>
        |                                         StateData#state.server,
        |                                         [StateData#state.jid, From, To, FixedPacket]),
        |  
<font color=red>     0..|                      send_and_maybe_buffer_stanza({From, To, FixedPacket}, NewState, StateName);</font>
        |                  {false, _NewAttrs, NewState} -&gt;
<font color=red>     0..|                      fsm_next_state(StateName, NewState)</font>
        |              end
        |      end;
        |  handle_info({'DOWN', Monitor, _Type, _Object, _Info}, _StateName, StateData)
        |    when Monitor == StateData#state.socket_monitor -&gt;
<font color=red>     0..|      maybe_enter_resume_session(StateData#state.stream_mgmt_id, StateData);</font>
        |  handle_info(system_shutdown, StateName, StateData) -&gt;
<font color=red>     0..|      case StateName of</font>
        |          wait_for_stream -&gt;
<font color=red>     0..|              send_header(StateData, ?MYNAME, &lt;&lt;"1.0"&gt;&gt;, &lt;&lt;"en"&gt;&gt;),</font>
<font color=red>     0..|              send_element(StateData, ?SERR_SYSTEM_SHUTDOWN),</font>
<font color=red>     0..|              send_trailer(StateData),</font>
<font color=red>     0..|              ok;</font>
        |          _ -&gt;
<font color=red>     0..|              send_element(StateData, ?SERR_SYSTEM_SHUTDOWN),</font>
<font color=red>     0..|              send_trailer(StateData),</font>
<font color=red>     0..|              ok</font>
        |      end,
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  handle_info({force_update_presence, LUser}, StateName,
        |              #state{user = LUser, server = LServer} = StateData) -&gt;
<font color=red>     0..|      NewStateData =</font>
        |      case StateData#state.pres_last of
        |          #xmlel{name = &lt;&lt;"presence"&gt;&gt;} -&gt;
<font color=red>     0..|              PresenceEl = ejabberd_hooks:run_fold(</font>
        |                             c2s_update_presence,
        |                             LServer,
        |                             StateData#state.pres_last,
        |                             [LUser, LServer]),
<font color=red>     0..|              StateData2 = StateData#state{pres_last = PresenceEl},</font>
<font color=red>     0..|              presence_update(StateData2#state.jid,</font>
        |                              PresenceEl,
        |                              StateData2),
<font color=red>     0..|              StateData2;</font>
        |          _ -&gt;
<font color=red>     0..|              StateData</font>
        |      end,
<font color=red>     0..|      {next_state, StateName, NewStateData};</font>
        |  handle_info(resume_timeout, resume_session, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  handle_info(check_buffer_full, StateName, StateData) -&gt;
<font color=red>     0..|      case is_buffer_full(StateData#state.stream_mgmt_buffer_size,</font>
        |                          StateData#state.stream_mgmt_buffer_max) of
        |          true -&gt;
<font color=red>     0..|              Err = ?RESOURCE_CONSTRAINT_ERR((StateData#state.lang),</font>
        |                                             &lt;&lt;"too many unacked stanzas"&gt;&gt;),
<font color=red>     0..|              send_element(StateData, Err),</font>
<font color=red>     0..|              send_trailer(StateData),</font>
<font color=red>     0..|              {stop, normal, StateData};</font>
        |          false -&gt;
<font color=red>     0..|              fsm_next_state(StateName,</font>
        |                             StateData#state{stream_mgmt_constraint_check_tref = undefined})
        |      end;
        |  handle_info(Info, StateName, StateData) -&gt;
<font color=red>     0..|      ?ERROR_MSG("Unexpected info: ~p", [Info]),</font>
<font color=red>     0..|      fsm_next_state(StateName, StateData).</font>
        |  
        |  -spec legacy_packet_to_broadcast({xmlel, any(), any(), list()}) -&gt; {broadcast, broadcast_type()}.
        |  legacy_packet_to_broadcast({xmlel, _, _, [Child]}) -&gt;
<font color=red>     0..|      {broadcast, Child};</font>
        |  legacy_packet_to_broadcast(InvalidBroadcast) -&gt;
<font color=red>     0..|      ?WARNING_MSG("invalid_broadcast=~p", [InvalidBroadcast]),</font>
<font color=red>     0..|      {broadcast, unknown}.</font>
        |  
        |  handle_routed(&lt;&lt;"presence"&gt;&gt;, From, To, Packet, StateData) -&gt;
<font color=red>     0..|      handle_routed_presence(From, To, Packet, StateData);</font>
        |  handle_routed(&lt;&lt;"iq"&gt;&gt;, From, To, Packet, StateData) -&gt;
<font color=red>     0..|      handle_routed_iq(From, To, Packet, StateData);</font>
        |  handle_routed(&lt;&lt;"message"&gt;&gt;, From, To, Packet, StateData) -&gt;
<font color=red>     0..|      case privacy_check_packet(StateData, From, To, Packet, in) of</font>
        |          allow -&gt;
<font color=red>     0..|              {true, Packet#xmlel.attrs, StateData};</font>
        |          deny -&gt;
<font color=red>     0..|              {false, Packet#xmlel.attrs, StateData}</font>
        |      end;
        |  handle_routed(_, _From, _To, Packet, StateData) -&gt;
<font color=red>     0..|      {true, Packet#xmlel.attrs, StateData}.</font>
        |  
        |  handle_routed_iq(From, To, Packet = #xmlel{attrs = Attrs}, StateData) -&gt;
<font color=red>     0..|      case jlib:iq_query_info(Packet) of</font>
        |          %% TODO: Support for mod_last / XEP-0012. Can we move it to the respective module?
        |          %%   Thanks to add_iq_handler(ejabberd_sm, ...)?
        |          #iq{xmlns = ?NS_LAST} -&gt;
<font color=red>     0..|              HasFromSub = ( is_subscribed_to_my_presence(From, StateData)</font>
<font color=red>     0..|                             andalso is_privacy_allow(StateData, To, From,</font>
        |                                                      #xmlel{name = &lt;&lt;"presence"&gt;&gt;}, out) ),
<font color=red>     0..|              case HasFromSub of</font>
        |                  true -&gt;
<font color=red>     0..|                      case privacy_check_packet(StateData, From, To, Packet, in) of</font>
        |                          allow -&gt;
<font color=red>     0..|                              {true, Attrs, StateData};</font>
        |                          deny -&gt;
<font color=red>     0..|                              {false, Attrs, StateData}</font>
        |                      end;
        |                  _ -&gt;
<font color=red>     0..|                      Err = jlib:make_error_reply(Packet, ?ERR_FORBIDDEN),</font>
<font color=red>     0..|                      ejabberd_router:route(To, From, Err),</font>
<font color=red>     0..|                      {false, Attrs, StateData}</font>
        |              end;
        |          IQ when (is_record(IQ, iq)) or (IQ == reply) -&gt;
<font color=red>     0..|              case privacy_check_packet(StateData, From, To, Packet, in) of</font>
        |                  allow -&gt;
<font color=red>     0..|                      {true, Attrs, StateData};</font>
        |                  deny when is_record(IQ, iq) -&gt;
<font color=red>     0..|                      Err = jlib:make_error_reply(Packet, ?ERR_SERVICE_UNAVAILABLE),</font>
<font color=red>     0..|                      ejabberd_router:route(To, From, Err),</font>
<font color=red>     0..|                      {false, Attrs, StateData};</font>
        |                  deny when IQ == reply -&gt;
<font color=red>     0..|                      {false, Attrs, StateData}</font>
        |              end;
        |          IQ when (IQ == invalid) or (IQ == not_iq) -&gt;
<font color=red>     0..|              {false, Attrs, StateData}</font>
        |      end.
        |  
        |  -spec handle_routed_broadcast(Broadcast :: broadcast_type(), StateData :: state()) -&gt;
        |      broadcast_result().
        |  handle_routed_broadcast({item, IJID, ISubscription}, StateData) -&gt;
<font color=red>     0..|      {new_state, roster_change(IJID, ISubscription, StateData)};</font>
        |  handle_routed_broadcast({exit, Reason}, _StateData) -&gt;
<font color=red>     0..|      {exit, Reason};</font>
        |  handle_routed_broadcast({privacy_list, PrivList, PrivListName}, StateData) -&gt;
<font color=red>     0..|      case ejabberd_hooks:run_fold(privacy_updated_list, StateData#state.server,</font>
        |                                   false, [StateData#state.privacy_list, PrivList]) of
        |          false -&gt;
<font color=red>     0..|              {new_state, StateData};</font>
        |          NewPL -&gt;
<font color=red>     0..|              PrivPushIQ = privacy_list_push_iq(PrivListName),</font>
<font color=red>     0..|              F = jid:to_bare(StateData#state.jid),</font>
<font color=red>     0..|              T = StateData#state.jid,</font>
<font color=red>     0..|              PrivPushEl = jlib:replace_from_to(F, T, jlib:iq_to_xml(PrivPushIQ)),</font>
<font color=red>     0..|              {send_new, F, T, PrivPushEl, StateData#state{privacy_list = NewPL}}</font>
        |      end;
        |  handle_routed_broadcast({blocking, What}, StateData) -&gt;
<font color=red>     0..|      route_blocking(What, StateData),</font>
<font color=red>     0..|      {new_state, StateData};</font>
        |  handle_routed_broadcast(_, StateData) -&gt;
<font color=red>     0..|      {new_state, StateData}.</font>
        |  
        |  -spec handle_broadcast_result(broadcast_result(), StateName :: atom(), StateData :: state()) -&gt; any().
        |  handle_broadcast_result({exit, ErrorMessage}, _StateName, StateData) -&gt;
<font color=red>     0..|      Lang = StateData#state.lang,</font>
<font color=red>     0..|      send_element(StateData, ?SERRT_CONFLICT(Lang, ErrorMessage)),</font>
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  handle_broadcast_result({send_new, From, To, Stanza, NewState}, StateName, _StateData) -&gt;
<font color=red>     0..|      send_and_maybe_buffer_stanza({From, To, Stanza}, NewState, StateName);</font>
        |  handle_broadcast_result({new_state, NewState}, StateName, _StateData) -&gt;
<font color=red>     0..|      fsm_next_state(StateName, NewState).</font>
        |  
        |  privacy_list_push_iq(PrivListName) -&gt;
<font color=red>     0..|      #iq{type = set, xmlns = ?NS_PRIVACY,</font>
        |          id = list_to_binary("push" ++ randoms:get_string()),
        |          sub_el = [#xmlel{name = &lt;&lt;"query"&gt;&gt;,
        |                           attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_PRIVACY}],
        |                           children = [#xmlel{name = &lt;&lt;"list"&gt;&gt;,
        |                                              attrs = [{&lt;&lt;"name"&gt;&gt;, PrivListName}]}]}]}.
        |  
        |  -spec handle_routed_presence(From :: ejabberd:jid(), To :: ejabberd:jid(), Packet :: jlib:xmlel(),
        |                              StateData :: state()) -&gt; routing_result().
        |  handle_routed_presence(From, To, Packet = #xmlel{attrs = Attrs}, StateData) -&gt;
<font color=red>     0..|      State = ejabberd_hooks:run_fold(c2s_presence_in, StateData#state.server,</font>
        |                                      StateData, [{From, To, Packet}]),
<font color=red>     0..|      case xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs) of</font>
        |          &lt;&lt;"probe"&gt;&gt; -&gt;
<font color=red>     0..|              {LFrom, LBFrom} = lowcase_and_bare(From),</font>
<font color=red>     0..|              NewState = case am_i_available_to(LFrom, LBFrom, State) of</font>
<font color=red>     0..|                             true -&gt; State;</font>
<font color=red>     0..|                             false -&gt; make_available_to(LFrom, LBFrom, State)</font>
        |                         end,
<font color=red>     0..|              process_presence_probe(From, To, NewState),</font>
<font color=red>     0..|              {false, Attrs, NewState};</font>
        |          &lt;&lt;"error"&gt;&gt; -&gt;
<font color=red>     0..|              NewA = ?SETS:del_element(jid:to_lower(From), State#state.pres_a),</font>
<font color=red>     0..|              {true, Attrs, State#state{pres_a = NewA}};</font>
        |          &lt;&lt;"invisible"&gt;&gt; -&gt;
<font color=red>     0..|              Attrs1 = lists:keydelete(&lt;&lt;"type"&gt;&gt;, 1, Attrs),</font>
<font color=red>     0..|              {true, [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"unavailable"&gt;&gt;} | Attrs1], State};</font>
        |          &lt;&lt;"subscribe"&gt;&gt; -&gt;
<font color=red>     0..|              SRes = is_privacy_allow(State, From, To, Packet, in),</font>
<font color=red>     0..|              {SRes, Attrs, State};</font>
        |          &lt;&lt;"subscribed"&gt;&gt; -&gt;
<font color=red>     0..|              SRes = is_privacy_allow(State, From, To, Packet, in),</font>
<font color=red>     0..|              {SRes, Attrs, State};</font>
        |          &lt;&lt;"unsubscribe"&gt;&gt; -&gt;
<font color=red>     0..|              SRes = is_privacy_allow(State, From, To, Packet, in),</font>
<font color=red>     0..|              {SRes, Attrs, State};</font>
        |          &lt;&lt;"unsubscribed"&gt;&gt; -&gt;
<font color=red>     0..|              SRes = is_privacy_allow(State, From, To, Packet, in),</font>
<font color=red>     0..|              {SRes, Attrs, State};</font>
        |          _ -&gt;
<font color=red>     0..|              case privacy_check_packet(State, From, To, Packet, in) of</font>
        |                  allow -&gt;
<font color=red>     0..|                      {LFrom, LBFrom} = lowcase_and_bare(From),</font>
<font color=red>     0..|                      case am_i_available_to(LFrom, LBFrom, State) of</font>
<font color=red>     0..|                          true -&gt; {true, Attrs, State};</font>
<font color=red>     0..|                          false -&gt; {true, Attrs, make_available_to(LFrom, LBFrom, State)}</font>
        |                      end;
        |                  deny -&gt;
<font color=red>     0..|                      {false, Attrs, State}</font>
        |              end
        |      end.
        |  
        |  am_i_available_to(LFrom, LBFrom, State) -&gt;
<font color=red>     0..|      ?SETS:is_element(LFrom, State#state.pres_a)</font>
<font color=red>     0..|      orelse (LFrom /= LBFrom)</font>
<font color=red>     0..|      andalso ?SETS:is_element(LBFrom, State#state.pres_a).</font>
        |  
        |  make_available_to(LFrom, LBFrom, State) -&gt;
<font color=red>     0..|      case ?SETS:is_element(LFrom, State#state.pres_f) of</font>
        |          true -&gt;
<font color=red>     0..|              A = ?SETS:add_element(LFrom, State#state.pres_a),</font>
<font color=red>     0..|              State#state{pres_a = A};</font>
        |          false -&gt;
<font color=red>     0..|              case ?SETS:is_element(LBFrom, State#state.pres_f) of</font>
        |                  true -&gt;
<font color=red>     0..|                      A = ?SETS:add_element(LBFrom, State#state.pres_a),</font>
<font color=red>     0..|                      State#state{pres_a = A};</font>
        |                  false -&gt;
<font color=red>     0..|                      State</font>
        |              end
        |      end.
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: print_state/1
        |  %% Purpose: Prepare the state to be printed on error log
        |  %% Returns: State to print
        |  %%----------------------------------------------------------------------
        |  -spec print_state(state()) -&gt; state().
        |  print_state(State = #state{pres_t = T, pres_f = F, pres_a = A, pres_i = I}) -&gt;
<font color=red>     0..|      State#state{pres_t = {pres_t, ?SETS:size(T)},</font>
        |                  pres_f = {pres_f, ?SETS:size(F)},
        |                  pres_a = {pres_a, ?SETS:size(A)},
        |                  pres_i = {pres_i, ?SETS:size(I)}
        |                 }.
        |  
        |  %%----------------------------------------------------------------------
        |  %% Func: terminate/3
        |  %% Purpose: Shutdown the fsm
        |  %% Returns: any
        |  %%----------------------------------------------------------------------
        |  -spec terminate(Reason :: any(), statename(), state()) -&gt; ok.
        |  terminate(_Reason, StateName, StateData) -&gt;
<font color=red>     0..|      case  should_close_session(StateName) of</font>
        |          %% if we are in an state wich have a session established
        |          true-&gt;
<font color=red>     0..|              case StateData#state.authenticated of</font>
        |                  replaced -&gt;
<font color=red>     0..|                      ?INFO_MSG("(~w) Replaced session for ~s",</font>
        |                                [StateData#state.socket,
        |                                 jid:to_binary(StateData#state.jid)]),
<font color=red>     0..|                      From = StateData#state.jid,</font>
<font color=red>     0..|                      Packet = #xmlel{name = &lt;&lt;"presence"&gt;&gt;,</font>
        |                                      attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"unavailable"&gt;&gt;}],
        |                                      children = [#xmlel{name = &lt;&lt;"status"&gt;&gt;,
        |                                                         children = [#xmlcdata{content = &lt;&lt;"Replaced by new connection"&gt;&gt;}]}]},
<font color=red>     0..|                      ejabberd_sm:close_session_unset_presence(</font>
        |                        StateData#state.sid,
        |                        StateData#state.user,
        |                        StateData#state.server,
        |                        StateData#state.resource,
        |                        &lt;&lt;"Replaced by new connection"&gt;&gt;,
        |                        replaced),
<font color=red>     0..|                      presence_broadcast(</font>
        |                        StateData, From, StateData#state.pres_a, Packet),
<font color=red>     0..|                      presence_broadcast(</font>
        |                        StateData, From, StateData#state.pres_i, Packet);
        |                  resumed -&gt;
<font color=red>     0..|                      ?INFO_MSG("(~w) Stream ~p resumed for ~s",</font>
        |                                [StateData#state.socket,
        |                                 StateData#state.stream_mgmt_id,
        |                                 jid:to_binary(StateData#state.jid)]);
        |                  _ -&gt;
<font color=red>     0..|                      ?INFO_MSG("(~w) Close session for ~s",</font>
        |                                [StateData#state.socket,
        |                                 jid:to_binary(StateData#state.jid)]),
        |  
<font color=red>     0..|                      EmptySet = ?SETS:new(),</font>
<font color=red>     0..|                      case StateData of</font>
        |                          #state{pres_last = undefined,
        |                                 pres_a = EmptySet,
        |                                 pres_i = EmptySet,
        |                                 pres_invis = false} -&gt;
<font color=red>     0..|                              ejabberd_sm:close_session(StateData#state.sid,</font>
        |                                                        StateData#state.user,
        |                                                        StateData#state.server,
        |                                                        StateData#state.resource,
        |                                                        normal);
        |                          _ -&gt;
<font color=red>     0..|                              From = StateData#state.jid,</font>
<font color=red>     0..|                              Packet = #xmlel{name = &lt;&lt;"presence"&gt;&gt;,</font>
        |                                              attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"unavailable"&gt;&gt;}]},
<font color=red>     0..|                              ejabberd_sm:close_session_unset_presence(</font>
        |                                StateData#state.sid,
        |                                StateData#state.user,
        |                                StateData#state.server,
        |                                StateData#state.resource,
        |                                &lt;&lt;""&gt;&gt;,
        |                                normal),
<font color=red>     0..|                              presence_broadcast(</font>
        |                                StateData, From, StateData#state.pres_a, Packet),
<font color=red>     0..|                              presence_broadcast(</font>
        |                                StateData, From, StateData#state.pres_i, Packet)
        |                      end
        |              end,
<font color=red>     0..|              if</font>
        |                  StateData#state.authenticated =/= resumed -&gt;
<font color=red>     0..|                      ?DEBUG("rerouting unacked messages", []),</font>
<font color=red>     0..|                      flush_stream_mgmt_buffer(StateData),</font>
<font color=red>     0..|                      bounce_messages();</font>
        |                  true -&gt;
<font color=red>     0..|                      ok</font>
        |              end;
        |          false -&gt;
<font color=red>     0..|              ok</font>
        |      end,
<font color=red>     0..|      (StateData#state.sockmod):close(StateData#state.socket),</font>
<font color=red>     0..|      ok.</font>
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% Internal functions
        |  %%%----------------------------------------------------------------------
<font color=red>     0..|  should_close_session(resume_session) -&gt; true;</font>
<font color=red>     0..|  should_close_session(session_established) -&gt; true;</font>
<font color=red>     0..|  should_close_session(_) -&gt; false.</font>
        |  
        |  -spec change_shaper(state(), ejabberd:jid()) -&gt; any().
        |  change_shaper(StateData, JID) -&gt;
<font color=red>     0..|      Shaper = acl:match_rule(StateData#state.server,</font>
        |                              StateData#state.shaper, JID),
<font color=red>     0..|      (StateData#state.sockmod):change_shaper(StateData#state.socket, Shaper).</font>
        |  
        |  
        |  -spec send_text(state(), Text :: binary()) -&gt; any().
        |  send_text(StateData, Text) -&gt;
<font color=red>     0..|      ?DEBUG("Send XML on stream = ~p", [Text]),</font>
<font color=red>     0..|      Size = size(Text),</font>
<font color=red>     0..|      mongoose_metrics:update([data, xmpp, sent, xml_stanza_size], Size),</font>
<font color=red>     0..|      (StateData#state.sockmod):send(StateData#state.socket, Text).</font>
        |  
        |  -spec maybe_send_element_safe(state(), El :: jlib:xmlel()) -&gt; any().
        |  maybe_send_element_safe(#state{stream_mgmt = false} = State, El) -&gt;
<font color=red>     0..|      send_element(State, El);</font>
        |  maybe_send_element_safe(State, El) -&gt;
<font color=red>     0..|      case catch send_element(State, El) of</font>
<font color=red>     0..|          ok -&gt; ok;</font>
<font color=red>     0..|          _ -&gt; error</font>
        |      end.
        |  
        |  send_element(#state{server = Server, sockmod = SockMod} = StateData, El)
        |    when StateData#state.xml_socket -&gt;
<font color=red>     0..|      ejabberd_hooks:run(xmpp_send_element,</font>
        |                         Server, [Server, El]),
<font color=red>     0..|      SockMod:send_xml(StateData#state.socket,</font>
        |                       {xmlstreamelement, El});
        |  send_element(#state{server = Server} = StateData, El) -&gt;
<font color=red>     0..|      ejabberd_hooks:run(xmpp_send_element,</font>
        |                         Server, [Server, El]),
<font color=red>     0..|      send_text(StateData, exml:to_binary(El)).</font>
        |  
        |  
        |  -spec send_header(State :: state(),
        |                    Server :: ejabberd:server(),
        |                    Version :: binary(),
        |                    Lang :: ejabberd:lang()) -&gt; any().
        |  send_header(StateData, Server, Version, Lang)
        |    when StateData#state.xml_socket -&gt;
<font color=red>     0..|      VersionAttr = case Version of</font>
<font color=red>     0..|                        &lt;&lt;&gt;&gt; -&gt; [];</font>
<font color=red>     0..|                        _ -&gt; [{&lt;&lt;"version"&gt;&gt;, Version}]</font>
        |                    end,
<font color=red>     0..|      LangAttr = case Lang of</font>
<font color=red>     0..|                     &lt;&lt;&gt;&gt; -&gt; [];</font>
<font color=red>     0..|                     _ -&gt; [{&lt;&lt;"xml:lang"&gt;&gt;, Lang}]</font>
        |                 end,
<font color=red>     0..|      Header = {xmlstreamstart,</font>
        |                &lt;&lt;"stream:stream"&gt;&gt;,
        |                VersionAttr ++
        |                LangAttr ++
        |                [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_CLIENT},
        |                 {&lt;&lt;"xmlns:stream"&gt;&gt;, &lt;&lt;"http://etherx.jabber.org/streams"&gt;&gt;},
        |                 {&lt;&lt;"id"&gt;&gt;, StateData#state.streamid},
        |                 {&lt;&lt;"from"&gt;&gt;, Server}]},
<font color=red>     0..|      (StateData#state.sockmod):send_xml(StateData#state.socket, Header);</font>
        |  send_header(StateData, Server, Version, Lang) -&gt;
<font color=red>     0..|      VersionStr = case Version of</font>
<font color=red>     0..|                      &lt;&lt;&gt;&gt; -&gt; [];</font>
<font color=red>     0..|                       _ -&gt; [" version='", Version, "'"]</font>
        |                   end,
<font color=red>     0..|      LangStr = case Lang of</font>
<font color=red>     0..|                    &lt;&lt;&gt;&gt; -&gt; [];</font>
<font color=red>     0..|                    _ -&gt; [" xml:lang='", Lang, "'"]</font>
        |                end,
<font color=red>     0..|      Header = list_to_binary(io_lib:format(?STREAM_HEADER,</font>
        |                                            [StateData#state.streamid,
        |                                             Server,
        |                                             VersionStr,
        |                                             LangStr])),
<font color=red>     0..|      send_text(StateData, Header).</font>
        |  
        |  -spec maybe_send_trailer_safe(State :: state()) -&gt; any().
        |  maybe_send_trailer_safe(#state{stream_mgmt = false} = State) -&gt;
<font color=red>     0..|      send_trailer(State);</font>
        |  maybe_send_trailer_safe(StateData) -&gt;
<font color=red>     0..|      catch send_trailer(StateData).</font>
        |  
        |  send_trailer(StateData) when StateData#state.xml_socket -&gt;
<font color=red>     0..|      (StateData#state.sockmod):send_xml(StateData#state.socket,</font>
        |                                         {xmlstreamend, &lt;&lt;"stream:stream"&gt;&gt;});
        |  send_trailer(StateData) -&gt;
<font color=red>     0..|      send_text(StateData, ?STREAM_TRAILER).</font>
        |  
        |  
        |  send_and_maybe_buffer_stanza({_, _, Stanza} = Packet, State, StateName)-&gt;
<font color=red>     0..|      SendResult = maybe_send_element_safe(State, Stanza),</font>
<font color=red>     0..|      BufferedStateData = buffer_out_stanza(Packet, State),</font>
<font color=red>     0..|      case SendResult of</font>
        |          ok -&gt;
<font color=red>     0..|              case catch maybe_send_ack_request(BufferedStateData) of</font>
        |                  R when is_boolean(R) -&gt;
<font color=red>     0..|                      fsm_next_state(StateName, BufferedStateData);</font>
        |                  _ -&gt;
<font color=red>     0..|                      ?DEBUG("Send ack request error: ~p, try enter resume session", [SendResult]),</font>
<font color=red>     0..|                      maybe_enter_resume_session(BufferedStateData#state.stream_mgmt_id, BufferedStateData)</font>
        |              end;
        |          _ -&gt;
<font color=red>     0..|              ?DEBUG("Send element error: ~p, try enter resume session", [SendResult]),</font>
<font color=red>     0..|              maybe_enter_resume_session(BufferedStateData#state.stream_mgmt_id, BufferedStateData)</font>
        |      end.
        |  
        |  -spec new_id() -&gt; binary().
        |  new_id() -&gt;
<font color=red>     0..|      iolist_to_binary(randoms:get_string()).</font>
        |  
        |  
        |  -spec is_auth_packet(El :: jlib:xmlel()) -&gt; boolean().
        |  is_auth_packet(El) -&gt;
<font color=red>     0..|      case jlib:iq_query_info(El) of</font>
        |          #iq{id = ID, type = Type, xmlns = ?NS_AUTH, sub_el = SubEl} -&gt;
<font color=red>     0..|              #xmlel{children = Els} = SubEl,</font>
<font color=red>     0..|              {auth, ID, Type,</font>
        |               get_auth_tags(Els, &lt;&lt;&gt;&gt;, &lt;&lt;&gt;&gt;, &lt;&lt;&gt;&gt;, &lt;&lt;&gt;&gt;)};
        |          _ -&gt;
<font color=red>     0..|              false</font>
        |      end.
        |  
        |  
        |  -spec get_auth_tags(Els :: [jlib:xmlel()], _, _, _, _) -&gt; {_, _, _, _}.
        |  get_auth_tags([#xmlel{name = Name, children = Els}| L], U, P, D, R) -&gt;
<font color=red>     0..|      CData = xml:get_cdata(Els),</font>
<font color=red>     0..|      case Name of</font>
        |          &lt;&lt;"username"&gt;&gt; -&gt;
<font color=red>     0..|              get_auth_tags(L, CData, P, D, R);</font>
        |          &lt;&lt;"password"&gt;&gt; -&gt;
<font color=red>     0..|              get_auth_tags(L, U, CData, D, R);</font>
        |          &lt;&lt;"digest"&gt;&gt; -&gt;
<font color=red>     0..|              get_auth_tags(L, U, P, CData, R);</font>
        |          &lt;&lt;"resource"&gt;&gt; -&gt;
<font color=red>     0..|              get_auth_tags(L, U, P, D, CData);</font>
        |          _ -&gt;
<font color=red>     0..|              get_auth_tags(L, U, P, D, R)</font>
        |      end;
        |  get_auth_tags([_ | L], U, P, D, R) -&gt;
<font color=red>     0..|      get_auth_tags(L, U, P, D, R);</font>
        |  get_auth_tags([], U, P, D, R) -&gt;
<font color=red>     0..|      {U, P, D, R}.</font>
        |  
        |  
        |  %% Copied from ejabberd_socket.erl
        |  -record(socket_state, {sockmod, socket, receiver}).
        |  
        |  -spec get_conn_type(state()) -&gt; conntype().
        |  get_conn_type(StateData) -&gt;
<font color=red>     0..|      case (StateData#state.sockmod):get_sockmod(StateData#state.socket) of</font>
<font color=red>     0..|          gen_tcp -&gt; c2s;</font>
<font color=red>     0..|          ejabberd_tls -&gt; c2s_tls;</font>
        |          ejabberd_zlib -&gt;
<font color=red>     0..|              case ejabberd_zlib:get_sockmod((StateData#state.socket)#socket_state.socket) of</font>
<font color=red>     0..|                  gen_tcp -&gt; c2s_compressed;</font>
<font color=red>     0..|                  ejabberd_tls -&gt; c2s_compressed_tls</font>
        |              end;
<font color=red>     0..|          ejabberd_http_poll -&gt; http_poll;</font>
<font color=red>     0..|          ejabberd_http_bind -&gt; http_bind;</font>
<font color=red>     0..|          _ -&gt; unknown</font>
        |      end.
        |  
        |  
        |  -spec process_presence_probe(From :: ejabberd:simple_jid() | ejabberd:jid(),
        |                               To :: ejabberd:jid(),
        |                               State :: state()) -&gt; 'ok'.
        |  process_presence_probe(From, To, StateData) -&gt;
<font color=red>     0..|      LFrom = jid:to_lower(From),</font>
<font color=red>     0..|      LBareFrom = setelement(3, LFrom, &lt;&lt;&gt;&gt;),</font>
<font color=red>     0..|      case StateData#state.pres_last of</font>
        |          undefined -&gt;
<font color=red>     0..|              ok;</font>
        |          _ -&gt;
<font color=red>     0..|              case {should_retransmit_last_presence(LFrom, LBareFrom, StateData),</font>
        |                    specifically_visible_to(LFrom, StateData)} of
        |                  {true, _} -&gt;
<font color=red>     0..|                      Timestamp = StateData#state.pres_timestamp,</font>
<font color=red>     0..|                      Packet = xml:append_subtags(</font>
        |                                 StateData#state.pres_last,
        |                                 %% To is the one sending the presence (the target of the probe)
        |                                 [jlib:timestamp_to_xml(Timestamp, utc, To, &lt;&lt;&gt;&gt;)]),
<font color=red>     0..|                      case privacy_check_packet(StateData, To, From, Packet, out) of</font>
        |                          deny -&gt;
<font color=red>     0..|                              ok;</font>
        |                          allow -&gt;
<font color=red>     0..|                              Pid = element(2, StateData#state.sid),</font>
<font color=red>     0..|                              ejabberd_hooks:run(presence_probe_hook,</font>
        |                                                 StateData#state.server,
        |                                                 [From, To, Pid]),
        |                              %% Don't route a presence probe to oneself
<font color=red>     0..|                              case jid:are_equal(From, To) of</font>
        |                                  false -&gt;
<font color=red>     0..|                                      ejabberd_router:route(To, From, Packet);</font>
        |                                  true -&gt;
<font color=red>     0..|                                      ok</font>
        |                              end
        |                      end;
        |                  {false, true} -&gt;
<font color=red>     0..|                      ejabberd_router:route(To, From, #xmlel{name = &lt;&lt;"presence"&gt;&gt;});</font>
        |                  _ -&gt;
<font color=red>     0..|                      ok</font>
        |              end
        |      end.
        |  
        |  should_retransmit_last_presence(LFrom, LBareFrom,
        |                                  #state{pres_invis = Invisible} = S) -&gt;
<font color=red>     0..|      not Invisible</font>
<font color=red>     0..|      andalso is_subscribed_to_my_presence(LFrom, LBareFrom, S)</font>
<font color=red>     0..|      andalso not invisible_to(LFrom, LBareFrom, S).</font>
        |  
        |  is_subscribed_to_my_presence(JID, S) -&gt;
<font color=red>     0..|      {Lowcase, Bare} = lowcase_and_bare(JID),</font>
<font color=red>     0..|      is_subscribed_to_my_presence(Lowcase, Bare, S).</font>
        |  
        |  is_subscribed_to_my_presence(LFrom, LBareFrom, S) -&gt;
<font color=red>     0..|      ?SETS:is_element(LFrom, S#state.pres_f)</font>
<font color=red>     0..|      orelse (LFrom /= LBareFrom)</font>
<font color=red>     0..|      andalso ?SETS:is_element(LBareFrom, S#state.pres_f).</font>
        |  
        |  am_i_subscribed_to_presence(LJID, LBareJID, S) -&gt;
<font color=red>     0..|      ?SETS:is_element(LJID, S#state.pres_t)</font>
<font color=red>     0..|      orelse (LJID /= LBareJID)</font>
<font color=red>     0..|      andalso ?SETS:is_element(LBareJID, S#state.pres_t).</font>
        |  
        |  lowcase_and_bare(JID) -&gt;
<font color=red>     0..|      LJID = jid:to_lower(JID),</font>
<font color=red>     0..|      { LJID, jid:to_bare(LJID)}.</font>
        |  
        |  invisible_to(LFrom, LBareFrom, S) -&gt;
<font color=red>     0..|      ?SETS:is_element(LFrom, S#state.pres_i)</font>
<font color=red>     0..|      orelse (LFrom /= LBareFrom)</font>
<font color=red>     0..|      andalso ?SETS:is_element(LBareFrom, S#state.pres_i).</font>
        |  
        |  %% @doc Is generally invisible, but visible to a particular resource?
        |  specifically_visible_to(LFrom, #state{pres_invis = Invisible} = S) -&gt;
<font color=red>     0..|      Invisible</font>
<font color=red>     0..|      andalso ?SETS:is_element(LFrom, S#state.pres_f)</font>
<font color=red>     0..|      andalso ?SETS:is_element(LFrom, S#state.pres_a).</font>
        |  
        |  %% @doc User updates his presence (non-directed presence packet)
        |  -spec presence_update(From :: 'undefined' | ejabberd:jid(),
        |                        Pkt :: jlib:xmlel(),
        |                        State :: state()) -&gt; state().
        |  presence_update(From, Packet, StateData) -&gt;
<font color=red>     0..|      #xmlel{attrs = Attrs} = Packet,</font>
<font color=red>     0..|      case xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs) of</font>
        |          &lt;&lt;"unavailable"&gt;&gt; -&gt;
<font color=red>     0..|              Status = case xml:get_subtag(Packet, &lt;&lt;"status"&gt;&gt;) of</font>
        |                           false -&gt;
<font color=red>     0..|                               &lt;&lt;&gt;&gt;;</font>
        |                           StatusTag -&gt;
<font color=red>     0..|                               xml:get_tag_cdata(StatusTag)</font>
        |                       end,
<font color=red>     0..|              Info = [{ip, StateData#state.ip}, {conn, StateData#state.conn},</font>
        |                      {auth_module, StateData#state.auth_module}],
<font color=red>     0..|              ejabberd_sm:unset_presence(StateData#state.sid,</font>
        |                                         StateData#state.user,
        |                                         StateData#state.server,
        |                                         StateData#state.resource,
        |                                         Status,
        |                                         Info),
<font color=red>     0..|              presence_broadcast(StateData, From, StateData#state.pres_a, Packet),</font>
<font color=red>     0..|              presence_broadcast(StateData, From, StateData#state.pres_i, Packet),</font>
<font color=red>     0..|              StateData#state{pres_last = undefined,</font>
        |                              pres_timestamp = undefined,
        |                              pres_a = ?SETS:new(),
        |                              pres_i = ?SETS:new(),
        |                              pres_invis = false};
        |          &lt;&lt;"invisible"&gt;&gt; -&gt;
<font color=red>     0..|              NewPriority = get_priority_from_presence(Packet),</font>
<font color=red>     0..|              update_priority(NewPriority, Packet, StateData),</font>
<font color=red>     0..|              NewState =</font>
        |              if
        |                  not StateData#state.pres_invis -&gt;
<font color=red>     0..|                      presence_broadcast(StateData, From,</font>
        |                                         StateData#state.pres_a,
        |                                         Packet),
<font color=red>     0..|                      presence_broadcast(StateData, From,</font>
        |                                         StateData#state.pres_i,
        |                                         Packet),
<font color=red>     0..|                      S1 = StateData#state{pres_last = undefined,</font>
        |                                           pres_timestamp = undefined,
        |                                           pres_a = ?SETS:new(),
        |                                           pres_i = ?SETS:new(),
        |                                           pres_invis = true},
<font color=red>     0..|                      presence_broadcast_first(From, S1, Packet);</font>
        |                  true -&gt;
<font color=red>     0..|                      StateData</font>
        |              end,
<font color=red>     0..|              NewState;</font>
        |          &lt;&lt;"error"&gt;&gt; -&gt;
<font color=red>     0..|              StateData;</font>
        |          &lt;&lt;"probe"&gt;&gt; -&gt;
<font color=red>     0..|              StateData;</font>
        |          &lt;&lt;"subscribe"&gt;&gt; -&gt;
<font color=red>     0..|              StateData;</font>
        |          &lt;&lt;"subscribed"&gt;&gt; -&gt;
<font color=red>     0..|              StateData;</font>
        |          &lt;&lt;"unsubscribe"&gt;&gt; -&gt;
<font color=red>     0..|              StateData;</font>
        |          &lt;&lt;"unsubscribed"&gt;&gt; -&gt;
<font color=red>     0..|              StateData;</font>
        |          _ -&gt;
<font color=red>     0..|              OldPriority = case StateData#state.pres_last of</font>
        |                                undefined -&gt;
<font color=red>     0..|                                    0;</font>
        |                                OldPresence -&gt;
<font color=red>     0..|                                    get_priority_from_presence(OldPresence)</font>
        |                            end,
<font color=red>     0..|              NewPriority = get_priority_from_presence(Packet),</font>
<font color=red>     0..|              Timestamp = calendar:now_to_universal_time(os:timestamp()),</font>
<font color=red>     0..|              update_priority(NewPriority, Packet, StateData),</font>
<font color=red>     0..|              FromUnavail = (StateData#state.pres_last == undefined) or</font>
        |              StateData#state.pres_invis,
<font color=red>     0..|              ?DEBUG("from unavail = ~p~n", [FromUnavail]),</font>
        |  
<font color=red>     0..|              NewStateData = StateData#state{pres_last = Packet,</font>
        |                                             pres_invis = false,
        |                                             pres_timestamp = Timestamp},
<font color=red>     0..|              if</font>
        |                  FromUnavail -&gt;
<font color=red>     0..|                      ejabberd_hooks:run(user_available_hook,</font>
        |                                         NewStateData#state.server,
        |                                         [NewStateData#state.jid]),
<font color=red>     0..|                      NewStateData1 = if NewPriority &gt;= 0 -&gt;</font>
<font color=red>     0..|                                             {_, _, Pending} = ejabberd_hooks:run_fold(</font>
        |                                                                 roster_get_subscription_lists,
        |                                                                 NewStateData#state.server,
        |                                                                 {[], [], []},
        |                                                                 [StateData#state.user, NewStateData#state.server]),
<font color=red>     0..|                                             resend_offline_messages(NewStateData),</font>
<font color=red>     0..|                                             resend_subscription_requests(NewStateData#state{pending_invitations = Pending});</font>
        |                                         true -&gt;
<font color=red>     0..|                                             NewStateData</font>
        |                                      end,
<font color=red>     0..|                      presence_broadcast_first(From, NewStateData1, Packet);</font>
        |                  true -&gt;
<font color=red>     0..|                      presence_broadcast_to_trusted(NewStateData,</font>
        |                                                    From,
        |                                                    NewStateData#state.pres_f,
        |                                                    NewStateData#state.pres_a,
        |                                                    Packet),
<font color=red>     0..|                      if OldPriority &lt; 0, NewPriority &gt;= 0 -&gt;</font>
<font color=red>     0..|                             resend_offline_messages(NewStateData);</font>
        |                         true -&gt;
<font color=red>     0..|                             ok</font>
        |                      end,
<font color=red>     0..|                      NewStateData</font>
        |              end
        |      end.
        |  
        |  
        |  %% @doc User sends a directed presence packet
        |  -spec presence_track(From :: ejabberd:jid(),
        |                       To :: ejabberd:jid(),
        |                       Pkt :: jlib:xmlel(),
        |                       State :: state()) -&gt; state().
        |  presence_track(From, To, Packet, StateData) -&gt;
<font color=red>     0..|      #xmlel{attrs = Attrs} = Packet,</font>
<font color=red>     0..|      LTo = jid:to_lower(To),</font>
<font color=red>     0..|      User = StateData#state.user,</font>
<font color=red>     0..|      Server = StateData#state.server,</font>
<font color=red>     0..|      case xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs) of</font>
        |          &lt;&lt;"unavailable"&gt;&gt; -&gt;
<font color=red>     0..|              check_privacy_route(From, StateData, From, To, Packet),</font>
<font color=red>     0..|              I = ?SETS:del_element(LTo, StateData#state.pres_i),</font>
<font color=red>     0..|              A = ?SETS:del_element(LTo, StateData#state.pres_a),</font>
<font color=red>     0..|              StateData#state{pres_i = I,</font>
        |                              pres_a = A};
        |          &lt;&lt;"invisible"&gt;&gt; -&gt;
<font color=red>     0..|              check_privacy_route(From, StateData, From, To, Packet),</font>
<font color=red>     0..|              I = ?SETS:add_element(LTo, StateData#state.pres_i),</font>
<font color=red>     0..|              A = ?SETS:del_element(LTo, StateData#state.pres_a),</font>
<font color=red>     0..|              StateData#state{pres_i = I,</font>
        |                              pres_a = A};
        |          &lt;&lt;"subscribe"&gt;&gt; -&gt;
<font color=red>     0..|              ejabberd_hooks:run(roster_out_subscription,</font>
        |                                 Server,
        |                                 [User, Server, To, subscribe]),
<font color=red>     0..|              check_privacy_route(From, StateData, jid:to_bare(From),</font>
        |                                  To, Packet),
<font color=red>     0..|              StateData;</font>
        |          &lt;&lt;"subscribed"&gt;&gt; -&gt;
<font color=red>     0..|              ejabberd_hooks:run(roster_out_subscription,</font>
        |                                 Server,
        |                                 [User, Server, To, subscribed]),
<font color=red>     0..|              check_privacy_route(From, StateData, jid:to_bare(From),</font>
        |                                  To, Packet),
<font color=red>     0..|              StateData;</font>
        |          &lt;&lt;"unsubscribe"&gt;&gt; -&gt;
<font color=red>     0..|              ejabberd_hooks:run(roster_out_subscription,</font>
        |                                 Server,
        |                                 [User, Server, To, unsubscribe]),
<font color=red>     0..|              check_privacy_route(From, StateData, jid:to_bare(From),</font>
        |                                  To, Packet),
<font color=red>     0..|              StateData;</font>
        |          &lt;&lt;"unsubscribed"&gt;&gt; -&gt;
<font color=red>     0..|              ejabberd_hooks:run(roster_out_subscription,</font>
        |                                 Server,
        |                                 [User, Server, To, unsubscribed]),
<font color=red>     0..|              check_privacy_route(From, StateData, jid:to_bare(From),</font>
        |                                  To, Packet),
<font color=red>     0..|              StateData;</font>
        |          &lt;&lt;"error"&gt;&gt; -&gt;
<font color=red>     0..|              check_privacy_route(From, StateData, From, To, Packet),</font>
<font color=red>     0..|              StateData;</font>
        |          &lt;&lt;"probe"&gt;&gt; -&gt;
<font color=red>     0..|              check_privacy_route(From, StateData, From, To, Packet),</font>
<font color=red>     0..|              StateData;</font>
        |          _ -&gt;
<font color=red>     0..|              check_privacy_route(From, StateData, From, To, Packet),</font>
<font color=red>     0..|              I = ?SETS:del_element(LTo, StateData#state.pres_i),</font>
<font color=red>     0..|              A = ?SETS:add_element(LTo, StateData#state.pres_a),</font>
<font color=red>     0..|              StateData#state{pres_i = I,</font>
        |                              pres_a = A}
        |      end.
        |  
        |  
        |  -spec check_privacy_route(From :: 'undefined' | ejabberd:jid(),
        |                            StateData :: state(),
        |                            FromRoute :: ejabberd:jid(),
        |                            To :: ejabberd:jid(),
        |                            Packet :: jlib:xmlel()) -&gt; 'ok'.
        |  check_privacy_route(From, StateData, FromRoute, To, Packet) -&gt;
<font color=red>     0..|      case privacy_check_packet(StateData, From, To, Packet, out) of</font>
        |          deny -&gt;
<font color=red>     0..|              Lang = StateData#state.lang,</font>
<font color=red>     0..|              ErrText = &lt;&lt;"Your active privacy list has denied the routing of this stanza."&gt;&gt;,</font>
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERRT_NOT_ACCEPTABLE(Lang, ErrText)),</font>
<font color=red>     0..|              ejabberd_router:route(To, From, Err),</font>
<font color=red>     0..|              ok;</font>
        |          allow -&gt;
<font color=red>     0..|              ejabberd_router:route(FromRoute, To, Packet)</font>
        |      end.
        |  
        |  
        |  -spec privacy_check_packet(StateData :: state(),
        |                             From :: ejabberd:jid(),
        |                             To :: ejabberd:jid(),
        |                             Packet :: jlib:xmlel(),
        |                             Dir :: 'in' | 'out') -&gt; any().
        |  privacy_check_packet(StateData, From, To, Packet, Dir) -&gt;
<font color=red>     0..|      ejabberd_hooks:run_fold(</font>
        |        privacy_check_packet, StateData#state.server,
        |        allow,
        |        [StateData#state.user,
        |         StateData#state.server,
        |         StateData#state.privacy_list,
        |         {From, To, Packet},
        |         Dir]).
        |  
        |  
        |  %% @doc Check if privacy rules allow this delivery
        |  -spec is_privacy_allow(StateData :: state(),
        |                         From :: ejabberd:jid(),
        |                         To :: ejabberd:jid(),
        |                         Packet :: jlib:xmlel(),
        |                         Dir :: 'in' | 'out') -&gt; boolean().
        |  is_privacy_allow(StateData, From, To, Packet, Dir) -&gt;
<font color=red>     0..|      allow == privacy_check_packet(StateData, From, To, Packet, Dir).</font>
        |  
        |  
        |  -spec presence_broadcast(State :: state(),
        |                           From :: 'undefined' | ejabberd:jid(),
        |                           JIDSet :: jid_set(),
        |                           Packet :: jlib:xmlel()) -&gt; 'ok'.
        |  presence_broadcast(StateData, From, JIDSet, Packet) -&gt;
<font color=red>     0..|      lists:foreach(fun(JID) -&gt;</font>
<font color=red>     0..|                            FJID = jid:make(JID),</font>
<font color=red>     0..|                            case privacy_check_packet(StateData, From, FJID, Packet, out) of</font>
        |                                deny -&gt;
<font color=red>     0..|                                    ok;</font>
        |                                allow -&gt;
<font color=red>     0..|                                    ejabberd_router:route(From, FJID, Packet)</font>
        |                            end
        |                    end, ?SETS:to_list(JIDSet)).
        |  
        |  
        |  -spec presence_broadcast_to_trusted(State :: state(),
        |                                      From :: 'undefined' | ejabberd:jid(),
        |                                      T :: jid_set(),
        |                                      A :: jid_set(),
        |                                      Packet :: jlib:xmlel()) -&gt; 'ok'.
        |  presence_broadcast_to_trusted(StateData, From, T, A, Packet) -&gt;
<font color=red>     0..|      lists:foreach(</font>
        |        fun(JID) -&gt;
<font color=red>     0..|                case ?SETS:is_element(JID, T) of</font>
        |                    true -&gt;
<font color=red>     0..|                        FJID = jid:make(JID),</font>
<font color=red>     0..|                        case privacy_check_packet(StateData, From, FJID, Packet, out) of</font>
        |                            deny -&gt;
<font color=red>     0..|                                ok;</font>
        |                            allow -&gt;
<font color=red>     0..|                                ejabberd_router:route(From, FJID, Packet)</font>
        |                        end;
        |                    _ -&gt;
<font color=red>     0..|                        ok</font>
        |                end
        |        end, ?SETS:to_list(A)).
        |  
        |  
        |  -spec presence_broadcast_first(From :: 'undefined' | ejabberd:jid(),
        |                                 State :: state(),
        |                                 Packet :: jlib:xmlel()) -&gt; state().
        |  presence_broadcast_first(From, StateData, Packet) -&gt;
<font color=red>     0..|      ?SETS:fold(fun(JID, X) -&gt;</font>
<font color=red>     0..|                         ejabberd_router:route(</font>
        |                           From,
        |                           jid:make(JID),
        |                           #xmlel{name = &lt;&lt;"presence"&gt;&gt;,
        |                                  attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"probe"&gt;&gt;}]}),
<font color=red>     0..|                         X</font>
        |                 end,
        |                 [],
        |                 StateData#state.pres_t),
<font color=red>     0..|      if</font>
        |          StateData#state.pres_invis -&gt;
<font color=red>     0..|              StateData;</font>
        |          true -&gt;
<font color=red>     0..|              As = ?SETS:fold(</font>
        |                      fun(JID, A) -&gt;
<font color=red>     0..|                              FJID = jid:make(JID),</font>
<font color=red>     0..|                              case privacy_check_packet(StateData, From, FJID, Packet, out) of</font>
        |                                  deny -&gt;
<font color=red>     0..|                                      ok;</font>
        |                                  allow -&gt;
<font color=red>     0..|                                      ejabberd_router:route(From, FJID, Packet)</font>
        |                              end,
<font color=red>     0..|                              ?SETS:add_element(JID, A)</font>
        |                      end,
        |                      StateData#state.pres_a,
        |                      StateData#state.pres_f),
<font color=red>     0..|              StateData#state{pres_a = As}</font>
        |      end.
        |  
        |  -spec roster_change(IJID :: ejabberd:simple_jid() | ejabberd:jid(),
        |                      ISubscription :: from | to | both | none,
        |                      State :: state()) -&gt; state().
        |  roster_change(IJID, ISubscription, StateData) -&gt;
<font color=red>     0..|      LIJID = jid:to_lower(IJID),</font>
<font color=red>     0..|      IsFrom = (ISubscription == both) or (ISubscription == from),</font>
<font color=red>     0..|      IsTo   = (ISubscription == both) or (ISubscription == to),</font>
<font color=red>     0..|      OldIsFrom = ?SETS:is_element(LIJID, StateData#state.pres_f),</font>
<font color=red>     0..|      FSet = if</font>
        |                 IsFrom -&gt;
<font color=red>     0..|                     ?SETS:add_element(LIJID, StateData#state.pres_f);</font>
        |                 true -&gt;
<font color=red>     0..|                     ?SETS:del_element(LIJID, StateData#state.pres_f)</font>
        |             end,
<font color=red>     0..|      TSet = if</font>
        |                 IsTo -&gt;
<font color=red>     0..|                     ?SETS:add_element(LIJID, StateData#state.pres_t);</font>
        |                 true -&gt;
<font color=red>     0..|                     ?SETS:del_element(LIJID, StateData#state.pres_t)</font>
        |             end,
<font color=red>     0..|      case StateData#state.pres_last of</font>
        |          undefined -&gt;
<font color=red>     0..|              StateData#state{pres_f = FSet, pres_t = TSet};</font>
        |          P -&gt;
<font color=red>     0..|              ?DEBUG("roster changed for ~p~n", [StateData#state.user]),</font>
<font color=red>     0..|              From = StateData#state.jid,</font>
<font color=red>     0..|              To = jid:make(IJID),</font>
<font color=red>     0..|              Cond1 = ( (not StateData#state.pres_invis) and IsFrom</font>
        |                        and (not OldIsFrom) ),
<font color=red>     0..|              Cond2 = ( (not IsFrom) and OldIsFrom</font>
        |                        and (?SETS:is_element(LIJID, StateData#state.pres_a) or
        |                             ?SETS:is_element(LIJID, StateData#state.pres_i)) ),
<font color=red>     0..|              if</font>
        |                  Cond1 -&gt;
<font color=red>     0..|                      ?DEBUG("C1: ~p~n", [LIJID]),</font>
<font color=red>     0..|                      case privacy_check_packet(StateData, From, To, P, out) of</font>
        |                          deny -&gt;
<font color=red>     0..|                              ok;</font>
        |                          allow -&gt;
<font color=red>     0..|                              ejabberd_router:route(From, To, P)</font>
        |                      end,
<font color=red>     0..|                      A = ?SETS:add_element(LIJID,</font>
        |                                            StateData#state.pres_a),
<font color=red>     0..|                      StateData#state{pres_a = A,</font>
        |                                      pres_f = FSet,
        |                                      pres_t = TSet};
        |                  Cond2 -&gt;
<font color=red>     0..|                      ?DEBUG("C2: ~p~n", [LIJID]),</font>
<font color=red>     0..|                      PU = #xmlel{name = &lt;&lt;"presence"&gt;&gt;,</font>
        |                                  attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"unavailable"&gt;&gt;}]},
<font color=red>     0..|                      case privacy_check_packet(StateData, From, To, PU, out) of</font>
        |                          deny -&gt;
<font color=red>     0..|                              ok;</font>
        |                          allow -&gt;
<font color=red>     0..|                              ejabberd_router:route(From, To, PU)</font>
        |                      end,
<font color=red>     0..|                      I = ?SETS:del_element(LIJID,</font>
        |                                         StateData#state.pres_i),
<font color=red>     0..|                      A = ?SETS:del_element(LIJID,</font>
        |                                         StateData#state.pres_a),
<font color=red>     0..|                      StateData#state{pres_i = I,</font>
        |                                      pres_a = A,
        |                                      pres_f = FSet,
        |                                      pres_t = TSet};
        |                  true -&gt;
<font color=red>     0..|                      StateData#state{pres_f = FSet, pres_t = TSet}</font>
        |              end
        |      end.
        |  
        |  
        |  -spec update_priority(Priority :: integer(),
        |                        Packet :: jlib:xmlel(),
        |                        State :: state()) -&gt; 'ok'.
        |  update_priority(Priority, Packet, StateData) -&gt;
<font color=red>     0..|      Info = [{ip, StateData#state.ip}, {conn, StateData#state.conn},</font>
        |              {auth_module, StateData#state.auth_module}],
<font color=red>     0..|      ejabberd_sm:set_presence(StateData#state.sid,</font>
        |                               StateData#state.user,
        |                               StateData#state.server,
        |                               StateData#state.resource,
        |                               Priority,
        |                               Packet,
        |                               Info).
        |  
        |  
        |  -spec get_priority_from_presence(Packet :: jlib:xmlel()) -&gt; integer().
        |  get_priority_from_presence(undefined) -&gt;
<font color=red>     0..|      0;</font>
        |  get_priority_from_presence(PresencePacket) -&gt;
<font color=red>     0..|      case xml:get_subtag(PresencePacket, &lt;&lt;"priority"&gt;&gt;) of</font>
        |          false -&gt;
<font color=red>     0..|              0;</font>
        |          SubEl -&gt;
<font color=red>     0..|              case catch list_to_integer(binary_to_list(xml:get_tag_cdata(SubEl))) of</font>
        |                  P when is_integer(P) -&gt;
<font color=red>     0..|                      P;</font>
        |                  _ -&gt;
<font color=red>     0..|                      0</font>
        |              end
        |      end.
        |  
        |  
        |  -spec process_privacy_iq(From :: ejabberd:jid(),
        |                           To :: ejabberd:jid(),
        |                           IQ :: ejabberd:iq(),
        |                           State :: state()) -&gt; state().
        |  process_privacy_iq(From, To,
        |                     #iq{type = Type, sub_el = SubEl} = IQ,
        |                     StateData) -&gt;
<font color=red>     0..|      {Res, NewStateData} =</font>
        |      case Type of
        |          get -&gt;
<font color=red>     0..|              R = ejabberd_hooks:run_fold(</font>
        |                    privacy_iq_get, StateData#state.server,
        |                    {error, ?ERR_FEATURE_NOT_IMPLEMENTED},
        |                    [From, To, IQ, StateData#state.privacy_list]),
<font color=red>     0..|              {R, StateData};</font>
        |          set -&gt;
<font color=red>     0..|              case ejabberd_hooks:run_fold(</font>
        |                     privacy_iq_set, StateData#state.server,
        |                     {error, ?ERR_FEATURE_NOT_IMPLEMENTED},
        |                     [From, To, IQ]) of
        |                  {result, R, NewPrivList} -&gt;
<font color=red>     0..|                      {{result, R},</font>
        |                       StateData#state{privacy_list = NewPrivList}};
<font color=red>     0..|                  R -&gt; {R, StateData}</font>
        |              end
        |      end,
<font color=red>     0..|      IQRes = case Res of</font>
        |                  {result, Result} -&gt;
<font color=red>     0..|                      IQ#iq{type = result, sub_el = Result};</font>
        |                  {error, Error} -&gt;
<font color=red>     0..|                      IQ#iq{type = error, sub_el = [SubEl, Error]}</font>
        |              end,
<font color=red>     0..|      ejabberd_router:route(To, From, jlib:iq_to_xml(IQRes)),</font>
<font color=red>     0..|      NewStateData.</font>
        |  
        |  
        |  -spec resend_offline_messages(state()) -&gt; ok.
        |  resend_offline_messages(StateData) -&gt;
<font color=red>     0..|      ?DEBUG("resend offline messages~n",[]),</font>
<font color=red>     0..|      case ejabberd_hooks:run_fold(</font>
        |             resend_offline_messages_hook, StateData#state.server,
        |             [],
        |             [StateData#state.user, StateData#state.server]) of
        |          Rs when is_list(Rs) -&gt;
<font color=red>     0..|              lists:foreach(</font>
        |                fun({route,
        |                     From, To, #xmlel{} = Packet}) -&gt;
<font color=red>     0..|                        Pass = case privacy_check_packet(StateData, From, To, Packet, in) of</font>
        |                                   allow -&gt;
<font color=red>     0..|                                       true;</font>
        |                                   deny -&gt;
<font color=red>     0..|                                       false</font>
        |                               end,
<font color=red>     0..|                        if</font>
        |                            Pass -&gt;
<font color=red>     0..|                                ejabberd_router:route(From, To, Packet);</font>
        |                            true -&gt;
<font color=red>     0..|                                ok</font>
        |                        end
        |                end, Rs)
        |      end.
        |  
        |  
        |  -spec resend_subscription_requests(state()) -&gt; state().
        |  resend_subscription_requests(#state{pending_invitations = Pending} = StateData) -&gt;
<font color=red>     0..|      NewState = lists:foldl(fun(XMLPacket, #state{} = State) -&gt;</font>
<font color=red>     0..|                                     send_element(State, XMLPacket),</font>
<font color=red>     0..|                                     {value, From} =  xml:get_tag_attr(&lt;&lt;"from"&gt;&gt;, XMLPacket),</font>
<font color=red>     0..|                                     {value, To} = xml:get_tag_attr(&lt;&lt;"to"&gt;&gt;, XMLPacket),</font>
<font color=red>     0..|                                     BufferedStateData = buffer_out_stanza({From, To, XMLPacket}, State),</font>
<font color=red>     0..|                                     maybe_send_ack_request(BufferedStateData),</font>
<font color=red>     0..|                                     BufferedStateData</font>
        |                             end, StateData, Pending),
<font color=red>     0..|      NewState#state{pending_invitations = []}.</font>
        |  
        |  
        |  get_showtag(undefined) -&gt;
<font color=red>     0..|      &lt;&lt;"unavailable"&gt;&gt;;</font>
        |  get_showtag(Presence) -&gt;
<font color=red>     0..|      case xml:get_path_s(Presence, [{elem, &lt;&lt;"show"&gt;&gt;}, cdata]) of</font>
<font color=red>     0..|          &lt;&lt;&gt;&gt; -&gt; &lt;&lt;"available"&gt;&gt;;</font>
<font color=red>     0..|          ShowTag -&gt; ShowTag</font>
        |      end.
        |  
        |  
        |  get_statustag(undefined) -&gt;
<font color=red>     0..|      &lt;&lt;&gt;&gt;;</font>
        |  get_statustag(Presence) -&gt;
<font color=red>     0..|      case xml:get_path_s(Presence, [{elem, &lt;&lt;"status"&gt;&gt;}, cdata]) of</font>
<font color=red>     0..|          ShowTag -&gt; ShowTag</font>
        |      end.
        |  
        |  
        |  -spec process_unauthenticated_stanza(State :: state(),
        |                                       El :: jlib:xmlel()) -&gt; any().
        |  process_unauthenticated_stanza(StateData, El) -&gt;
<font color=red>     0..|      NewEl = case xml:get_tag_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, El) of</font>
        |                  &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|                      case StateData#state.lang of</font>
<font color=red>     0..|                          &lt;&lt;&gt;&gt; -&gt; El;</font>
        |                          Lang -&gt;
<font color=red>     0..|                              xml:replace_tag_attr(&lt;&lt;"xml:lang"&gt;&gt;, Lang, El)</font>
        |                      end;
        |                  _ -&gt;
<font color=red>     0..|                      El</font>
        |              end,
<font color=red>     0..|      case jlib:iq_query_info(NewEl) of</font>
        |          #iq{} = IQ -&gt;
<font color=red>     0..|              Res = ejabberd_hooks:run_fold(c2s_unauthenticated_iq,</font>
        |                                            StateData#state.server,
        |                                            empty,
        |                                            [StateData#state.server, IQ,
        |                                             StateData#state.ip]),
<font color=red>     0..|              case Res of</font>
        |                  empty -&gt;
        |                      % The only reasonable IQ's here are auth and register IQ's
        |                      % They contain secrets, so don't include subelements to response
<font color=red>     0..|                      ResIQ = IQ#iq{type = error,</font>
        |                                    sub_el = [?ERR_SERVICE_UNAVAILABLE]},
<font color=red>     0..|                      Res1 = jlib:replace_from_to(</font>
        |                               jid:make(&lt;&lt;&gt;&gt;, StateData#state.server, &lt;&lt;&gt;&gt;),
        |                               jid:make(&lt;&lt;&gt;&gt;, &lt;&lt;&gt;&gt;, &lt;&lt;&gt;&gt;),
        |                               jlib:iq_to_xml(ResIQ)),
<font color=red>     0..|                      send_element(StateData, jlib:remove_attr(&lt;&lt;"to"&gt;&gt;, Res1));</font>
        |                  _ -&gt;
<font color=red>     0..|                      send_element(StateData, Res)</font>
        |              end;
        |          _ -&gt;
        |              % Drop any stanza, which isn't IQ stanza
<font color=red>     0..|              ok</font>
        |      end.
        |  
        |  
        |  -spec peerip(SockMod :: ejabberd:sockmod(), inet:socket())
        |  -&gt; undefined | {inet:ip_address(), inet:port_number()}.
        |  peerip(SockMod, Socket) -&gt;
<font color=red>     0..|      IP = case SockMod of</font>
<font color=red>     0..|               gen_tcp -&gt; inet:peername(Socket);</font>
<font color=red>     0..|               _ -&gt; SockMod:peername(Socket)</font>
        |           end,
<font color=red>     0..|      case IP of</font>
<font color=red>     0..|          {ok, IPOK} -&gt; IPOK;</font>
<font color=red>     0..|          _ -&gt; undefined</font>
        |      end.
        |  
        |  
        |  %% @doc fsm_next_state_pack: Pack the StateData structure to improve sharing.
        |  fsm_next_state_pack(StateName, StateData) -&gt;
<font color=red>     0..|      fsm_next_state_gc(StateName, pack(StateData)).</font>
        |  
        |  
        |  %% @doc fsm_next_state_gc: Garbage collect the process heap to make use of
        |  %% the newly packed StateData structure.
        |  fsm_next_state_gc(StateName, PackedStateData) -&gt;
<font color=red>     0..|      erlang:garbage_collect(),</font>
<font color=red>     0..|      fsm_next_state(StateName, PackedStateData).</font>
        |  
        |  
        |  %% @doc fsm_next_state: Generate the next_state FSM tuple with different
        |  %% timeout, depending on the future state
        |  fsm_next_state(session_established, StateData) -&gt;
<font color=red>     0..|      {next_state, session_established, StateData, ?C2S_HIBERNATE_TIMEOUT};</font>
        |  fsm_next_state(StateName, StateData) -&gt;
<font color=red>     0..|      {next_state, StateName, StateData, ?C2S_OPEN_TIMEOUT}.</font>
        |  
        |  
        |  %% @doc fsm_reply: Generate the reply FSM tuple with different timeout,
        |  %% depending on the future state
        |  fsm_reply(Reply, session_established, StateData) -&gt;
<font color=red>     0..|      {reply, Reply, session_established, StateData, ?C2S_HIBERNATE_TIMEOUT};</font>
        |  fsm_reply(Reply, StateName, StateData) -&gt;
<font color=red>     0..|      {reply, Reply, StateName, StateData, ?C2S_OPEN_TIMEOUT}.</font>
        |  
        |  
        |  %% @doc Used by c2s blacklist plugins
        |  -spec is_ip_blacklisted('undefined' | {inet:ip_address(), inet:port_number()}
        |                         ) -&gt; boolean().
        |  is_ip_blacklisted(undefined) -&gt;
<font color=red>     0..|      false;</font>
        |  is_ip_blacklisted({IP,_Port}) -&gt;
<font color=red>     0..|      ejabberd_hooks:run_fold(check_bl_c2s, false, [IP]).</font>
        |  
        |  
        |  %% @doc Check from attributes.
        |  -spec check_from(El, FromJID) -&gt; Result when
        |        El :: jlib:xmlel(), FromJID :: ejabberd:jid(),
        |        Result :: 'invalid-from'  | jlib:xmlel().
        |  check_from(El, FromJID) -&gt;
<font color=red>     0..|      case xml:get_tag_attr(&lt;&lt;"from"&gt;&gt;, El) of</font>
        |          false -&gt;
<font color=red>     0..|              El;</font>
        |          {value, SJID} -&gt;
<font color=red>     0..|              JID = jid:from_binary(SJID),</font>
<font color=red>     0..|              case JID of</font>
        |                  error -&gt;
<font color=red>     0..|                      'invalid-from';</font>
        |                  #jid{} -&gt;
<font color=red>     0..|                      if</font>
        |                          (JID#jid.luser == FromJID#jid.luser) and
        |                          (JID#jid.lserver == FromJID#jid.lserver) and
        |                          (JID#jid.lresource == FromJID#jid.lresource) -&gt;
<font color=red>     0..|                              El;</font>
        |                          (JID#jid.luser == FromJID#jid.luser) and
        |                          (JID#jid.lserver == FromJID#jid.lserver) and
        |                          (JID#jid.lresource == &lt;&lt;&gt;&gt;) -&gt;
<font color=red>     0..|                              El;</font>
        |                          true -&gt;
<font color=red>     0..|                              'invalid-from'</font>
        |                      end
        |              end
        |      end.
        |  
        |  
        |  fsm_limit_opts(Opts) -&gt;
<font color=red>     0..|      case lists:keyfind(max_fsm_queue, 1, Opts) of</font>
        |          {_, N} when is_integer(N) -&gt;
<font color=red>     0..|              [{max_queue, N}];</font>
        |          _ -&gt;
<font color=red>     0..|              case ejabberd_config:get_local_option(max_fsm_queue) of</font>
        |                  N when is_integer(N) -&gt;
<font color=red>     0..|                      [{max_queue, N}];</font>
        |                  _ -&gt;
<font color=red>     0..|                      []</font>
        |              end
        |      end.
        |  
        |  
        |  -spec bounce_messages() -&gt; 'ok'.
        |  bounce_messages() -&gt;
<font color=red>     0..|      receive</font>
        |          {route, From, To, El} -&gt;
<font color=red>     0..|              ejabberd_router:route(From, To, El),</font>
<font color=red>     0..|              bounce_messages()</font>
        |      after 0 -&gt;
<font color=red>     0..|                ok</font>
        |      end.
        |  
        |  %% Return the messages in reverse order than they were received in!
        |  flush_messages() -&gt;
<font color=red>     0..|      flush_messages(0, []).</font>
        |  
        |  flush_messages(N, Acc) -&gt;
<font color=red>     0..|      receive</font>
        |          {route, _, _, _} = Msg -&gt;
<font color=red>     0..|              flush_messages(N+1, [Msg | Acc])</font>
        |      after 0 -&gt;
<font color=red>     0..|                {N, Acc}</font>
        |      end.
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% XEP-0191
        |  %%%----------------------------------------------------------------------
        |  
        |  -spec route_blocking(What :: blocking_type(), State :: state()) -&gt; 'ok'.
        |  route_blocking(What, StateData) -&gt;
<font color=red>     0..|      SubEl =</font>
        |      case What of
        |          {block, JIDs} -&gt;
<font color=red>     0..|              #xmlel{name = &lt;&lt;"block"&gt;&gt;,</font>
        |                     attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_BLOCKING}],
        |                     children = lists:map(
        |                                  fun(JID) -&gt;
<font color=red>     0..|                                          #xmlel{name = &lt;&lt;"item"&gt;&gt;,</font>
        |                                                 attrs = [{&lt;&lt;"jid"&gt;&gt;, jid:to_binary(JID)}]}
        |                                  end, JIDs)};
        |          {unblock, JIDs} -&gt;
<font color=red>     0..|              #xmlel{name = &lt;&lt;"unblock"&gt;&gt;,</font>
        |                     attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_BLOCKING}],
        |                     children = lists:map(
        |                                  fun(JID) -&gt;
<font color=red>     0..|                                          #xmlel{name = &lt;&lt;"item"&gt;&gt;,</font>
        |                                                 attrs = [{&lt;&lt;"jid"&gt;&gt;, jid:to_binary(JID)}]}
        |                                  end, JIDs)};
        |          unblock_all -&gt;
<font color=red>     0..|              #xmlel{name = &lt;&lt;"unblock"&gt;&gt;,</font>
        |                     attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_BLOCKING}]}
        |      end,
<font color=red>     0..|      PrivPushIQ = #iq{type = set, xmlns = ?NS_BLOCKING,</font>
        |                       id = &lt;&lt;"push"&gt;&gt;,
        |                       sub_el = [SubEl]},
<font color=red>     0..|      F = jid:to_bare(StateData#state.jid),</font>
<font color=red>     0..|      T = StateData#state.jid,</font>
<font color=red>     0..|      PrivPushEl = jlib:replace_from_to(F, T, jlib:iq_to_xml(PrivPushIQ)),</font>
<font color=red>     0..|      ejabberd_router:route(F, T, PrivPushEl),</font>
        |      %% No need to replace active privacy list here,
        |      %% blocking pushes are always accompanied by
        |      %% Privacy List pushes
<font color=red>     0..|      ok.</font>
        |  
        |  
        |  -type pack_tree() :: gb_trees:tree(binary() | ejabberd:simple_jid(),
        |                                     binary() | ejabberd:simple_jid()).
        |  
        |  %% @doc Try to reduce the heap footprint of the four presence sets
        |  %% by ensuring that we re-use strings and Jids wherever possible.
        |  -spec pack(S :: state()) -&gt; state().
        |  pack(S = #state{pres_a=A,
        |                  pres_i=I,
        |                  pres_f=F,
        |                  pres_t=T}) -&gt;
<font color=red>     0..|      {NewA, Pack1} = pack_jid_set(A, gb_trees:empty()),</font>
<font color=red>     0..|      {NewI, Pack2} = pack_jid_set(I, Pack1),</font>
<font color=red>     0..|      {NewF, Pack3} = pack_jid_set(F, Pack2),</font>
<font color=red>     0..|      {NewT, _Pack4} = pack_jid_set(T, Pack3),</font>
        |      %% Throw away Pack4 so that if we delete references to
        |      %% Strings or Jids in any of the sets there will be
        |      %% no live references for the GC to find.
<font color=red>     0..|      S#state{pres_a=NewA,</font>
        |              pres_i=NewI,
        |              pres_f=NewF,
        |              pres_t=NewT}.
        |  
        |  
        |  -spec pack_jid_set(Set :: jid_set(),
        |                     Pack :: pack_tree()) -&gt; {jid_set(), pack_tree()}.
        |  pack_jid_set(Set, Pack) -&gt;
<font color=red>     0..|      Jids = ?SETS:to_list(Set),</font>
<font color=red>     0..|      {PackedJids, NewPack} = pack_jids(Jids, Pack, []),</font>
<font color=red>     0..|      {?SETS:from_list(PackedJids), NewPack}.</font>
        |  
        |  
        |  -spec pack_jids([{_,_,_}], Pack :: pack_tree(), Acc :: [ejabberd:simple_jid()]) -&gt;
        |      {[ejabberd:simple_jid()],pack_tree()}.
<font color=red>     0..|  pack_jids([], Pack, Acc) -&gt; {Acc, Pack};</font>
        |  pack_jids([{U,S,R}=Jid | Jids], Pack, Acc) -&gt;
<font color=red>     0..|      case gb_trees:lookup(Jid, Pack) of</font>
        |          {value, PackedJid} -&gt;
<font color=red>     0..|              pack_jids(Jids, Pack, [PackedJid | Acc]);</font>
        |          none -&gt;
<font color=red>     0..|              {NewU, Pack1} = pack_string(U, Pack),</font>
<font color=red>     0..|              {NewS, Pack2} = pack_string(S, Pack1),</font>
<font color=red>     0..|              {NewR, Pack3} = pack_string(R, Pack2),</font>
<font color=red>     0..|              NewJid = {NewU, NewS, NewR},</font>
<font color=red>     0..|              NewPack = gb_trees:insert(NewJid, NewJid, Pack3),</font>
<font color=red>     0..|              pack_jids(Jids, NewPack, [NewJid | Acc])</font>
        |      end.
        |  
        |  
        |  -spec pack_string(String :: binary(), Pack :: pack_tree()) -&gt; {binary(), pack_tree()}.
        |  pack_string(String, Pack) -&gt;
<font color=red>     0..|      case gb_trees:lookup(String, Pack) of</font>
        |          {value, PackedString} -&gt;
<font color=red>     0..|              {PackedString, Pack};</font>
        |          none -&gt;
<font color=red>     0..|              {String, gb_trees:insert(String, String, Pack)}</font>
        |      end.
        |  
        |  %%%----------------------------------------------------------------------
        |  %%% XEP-0198: Stream Management
        |  %%%----------------------------------------------------------------------
        |  
        |  maybe_enable_stream_mgmt(NextState, El, StateData) -&gt;
<font color=red>     0..|      case {xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, El),</font>
        |            StateData#state.stream_mgmt,
        |            xml:get_tag_attr_s(&lt;&lt;"resume"&gt;&gt;, El)}
        |      of
        |          {?NS_STREAM_MGNT_3, false, Resume} -&gt;
        |              %% turn on
<font color=red>     0..|              {NewSD, EnabledEl} = case lists:member(Resume, [&lt;&lt;"true"&gt;&gt;, &lt;&lt;"1"&gt;&gt;]) of</font>
        |                                       false -&gt;
<font color=red>     0..|                                           {StateData, stream_mgmt_enabled()};</font>
        |                                       true -&gt;
<font color=red>     0..|                                           enable_stream_resumption(StateData)</font>
        |                                   end,
<font color=red>     0..|              send_element(NewSD, EnabledEl),</font>
<font color=red>     0..|              BufferMax = get_buffer_max(),</font>
<font color=red>     0..|              AckFreq = get_ack_freq(),</font>
<font color=red>     0..|              ResumeTimeout = get_resume_timeout(),</font>
<font color=red>     0..|              fsm_next_state(NextState,</font>
        |                             NewSD#state{stream_mgmt = true,
        |                                         stream_mgmt_buffer_max = BufferMax,
        |                                         stream_mgmt_ack_freq = AckFreq,
        |                                         stream_mgmt_resume_timeout = ResumeTimeout});
        |          {?NS_STREAM_MGNT_3, _, _} -&gt;
        |              %% already on, ignore
<font color=red>     0..|              fsm_next_state(NextState, StateData);</font>
        |          {_, _, _} -&gt;
        |              %% invalid namespace
<font color=red>     0..|              send_element(StateData, ?INVALID_NS_ERR),</font>
<font color=red>     0..|              send_trailer(StateData),</font>
<font color=red>     0..|              {stop, normal, StateData}</font>
        |      end.
        |  
        |  enable_stream_resumption(SD) -&gt;
<font color=red>     0..|      SMID = make_smid(),</font>
<font color=red>     0..|      SID = case SD#state.sid of</font>
<font color=red>     0..|                undefined -&gt; {now(), self()};</font>
<font color=red>     0..|                RSID -&gt; RSID</font>
        |            end,
<font color=red>     0..|      ok = mod_stream_management:register_smid(SMID, SID),</font>
<font color=red>     0..|      {SD#state{stream_mgmt_id = SMID, sid = SID},</font>
        |       stream_mgmt_enabled([{&lt;&lt;"id"&gt;&gt;, SMID}, {&lt;&lt;"resume"&gt;&gt;, &lt;&lt;"true"&gt;&gt;}])}.
        |  
        |  make_smid() -&gt;
<font color=red>     0..|      base64:encode(crypto:rand_bytes(21)).</font>
        |  
        |  maybe_unexpected_sm_request(NextState, El, StateData) -&gt;
<font color=red>     0..|      case xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, El) of</font>
        |          ?NS_STREAM_MGNT_3 -&gt;
<font color=red>     0..|              send_element(StateData, stream_mgmt_failed(&lt;&lt;"unexpected-request"&gt;&gt;)),</font>
<font color=red>     0..|              fsm_next_state(NextState, StateData);</font>
        |          _ -&gt;
<font color=red>     0..|              send_element(StateData, ?INVALID_NS_ERR),</font>
<font color=red>     0..|              send_trailer(StateData),</font>
<font color=red>     0..|              {stop, normal, StateData}</font>
        |      end.
        |  
        |  stream_mgmt_handle_ack(NextState, El, #state{} = SD) -&gt;
<font color=red>     0..|      try</font>
<font color=red>     0..|          {ns, ?NS_STREAM_MGNT_3} = {ns, xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, El)},</font>
<font color=red>     0..|          Handled = binary_to_integer(xml:get_tag_attr_s(&lt;&lt;"h"&gt;&gt;, El)),</font>
<font color=red>     0..|          NSD = #state{} = do_handle_ack(Handled,</font>
        |                                         SD#state.stream_mgmt_out_acked,
        |                                         SD#state.stream_mgmt_buffer,
        |                                         SD#state.stream_mgmt_buffer_size,
        |                                         SD),
<font color=red>     0..|          fsm_next_state(NextState, NSD)</font>
        |      catch
        |          error:{badmatch, {ns, _}} -&gt;
<font color=red>     0..|              maybe_send_element_safe(SD, ?INVALID_NS_ERR),</font>
<font color=red>     0..|              maybe_send_trailer_safe(SD),</font>
<font color=red>     0..|              {stop, normal, SD};</font>
        |          throw:{policy_violation, Reason} -&gt;
<font color=red>     0..|              maybe_send_element_safe(SD, ?POLICY_VIOLATION_ERR(SD#state.lang,</font>
        |                                                                Reason)),
<font color=red>     0..|              maybe_send_trailer_safe(SD),</font>
<font color=red>     0..|              {stop, normal, SD}</font>
        |      end.
        |  
        |  do_handle_ack(Handled, OldAcked, Buffer, BufferSize, SD) -&gt;
<font color=red>     0..|      ToDrop = calc_to_drop(Handled, OldAcked),</font>
<font color=red>     0..|      ToDrop &gt; BufferSize andalso throw({policy_violation,</font>
        |                                         &lt;&lt;"h attribute too big"&gt;&gt;}),
<font color=red>     0..|      {Dropped, NewBuffer} = drop_last(ToDrop, Buffer),</font>
<font color=red>     0..|      NewSize = BufferSize - Dropped,</font>
<font color=red>     0..|      SD#state{stream_mgmt_out_acked = Handled,</font>
        |               stream_mgmt_buffer = NewBuffer,
        |               stream_mgmt_buffer_size = NewSize}.
        |  
        |  calc_to_drop(Handled, OldAcked) when Handled &gt;= OldAcked -&gt;
<font color=red>     0..|      Handled - OldAcked;</font>
        |  calc_to_drop(Handled, OldAcked) -&gt;
<font color=red>     0..|      Handled + ?STREAM_MGMT_H_MAX - OldAcked + 1.</font>
        |  
        |  maybe_send_sm_ack(?NS_STREAM_MGNT_3, false, _NIncoming,
        |                    NextState, StateData) -&gt;
<font color=red>     0..|      ?WARNING_MSG("received &lt;r/&gt; but stream management is off!", []),</font>
<font color=red>     0..|      fsm_next_state(NextState, StateData);</font>
        |  maybe_send_sm_ack(?NS_STREAM_MGNT_3, true, NIncoming,
        |                    NextState, StateData) -&gt;
<font color=red>     0..|      send_element(StateData, stream_mgmt_ack(NIncoming)),</font>
<font color=red>     0..|      fsm_next_state(NextState, StateData);</font>
        |  maybe_send_sm_ack(_, _, _, _NextState, StateData) -&gt;
<font color=red>     0..|      send_element(StateData, ?INVALID_NS_ERR),</font>
<font color=red>     0..|      send_trailer(StateData),</font>
<font color=red>     0..|      {stop, normal, StateData}.</font>
        |  
        |  maybe_increment_sm_incoming(false, StateData) -&gt;
<font color=red>     0..|      StateData;</font>
        |  maybe_increment_sm_incoming(true, StateData) -&gt;
<font color=red>     0..|      Incoming = StateData#state.stream_mgmt_in,</font>
<font color=red>     0..|      StateData#state{stream_mgmt_in = increment_sm_incoming(Incoming)}.</font>
        |  
        |  increment_sm_incoming(Incoming) -&gt;
<font color=red>     0..|      increment_sm_counter(Incoming, 1).</font>
        |  
        |  increment_sm_counter(Incoming, Increment)
        |    when Incoming + Increment &gt;= ?STREAM_MGMT_H_MAX -&gt;
<font color=red>     0..|      Increment - 1;</font>
        |  increment_sm_counter(Incoming, Increment) -&gt;
<font color=red>     0..|      Incoming + Increment.</font>
        |  
        |  stream_mgmt_enabled() -&gt;
<font color=red>     0..|      stream_mgmt_enabled([]).</font>
        |  
        |  stream_mgmt_enabled(ExtraAttrs) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"enabled"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STREAM_MGNT_3}] ++ ExtraAttrs}.
        |  
        |  stream_mgmt_failed(Reason) -&gt;
<font color=red>     0..|      ReasonEl = #xmlel{name = Reason,</font>
        |                        attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STANZAS}]},
<font color=red>     0..|      #xmlel{name = &lt;&lt;"failed"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STREAM_MGNT_3}],
        |             children = [ReasonEl]}.
        |  
        |  stream_mgmt_ack(NIncoming) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"a"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STREAM_MGNT_3},
        |                      {&lt;&lt;"h"&gt;&gt;, integer_to_binary(NIncoming)}]}.
        |  
        |  buffer_out_stanza(_Packet, #state{stream_mgmt = false} = S) -&gt;
<font color=red>     0..|      S;</font>
        |  buffer_out_stanza(_Packet, #state{stream_mgmt_buffer_max = no_buffer} = S) -&gt;
<font color=red>     0..|      S;</font>
        |  buffer_out_stanza(Packet, #state{stream_mgmt_buffer = Buffer,
        |                                   stream_mgmt_buffer_size = BufferSize,
        |                                   stream_mgmt_buffer_max = BufferMax} = S) -&gt;
<font color=red>     0..|      NewSize = BufferSize + 1,</font>
<font color=red>     0..|      Timestamp = os:timestamp(),</font>
<font color=red>     0..|      NPacket = maybe_add_timestamp(Packet, Timestamp),</font>
        |  
<font color=red>     0..|      NS = case is_buffer_full(NewSize, BufferMax) of</font>
        |               true -&gt;
<font color=red>     0..|                   defer_resource_constraint_check(S);</font>
        |               _ -&gt;
<font color=red>     0..|                   S</font>
        |           end,
<font color=red>     0..|      NS#state{stream_mgmt_buffer_size = NewSize,</font>
        |               stream_mgmt_buffer = [NPacket | Buffer]}.
        |  
        |  is_buffer_full(_BufferSize, infinity) -&gt;
<font color=red>     0..|      false;</font>
        |  is_buffer_full(BufferSize, BufferMax) when BufferSize =&lt; BufferMax -&gt;
<font color=red>     0..|      false;</font>
        |  is_buffer_full(_, _) -&gt;
<font color=red>     0..|      true.</font>
        |  
        |  %% @doc Drop last N elements from List.
        |  %% It's not an error if N &gt; length(List).
        |  %% The actual number of dropped elements and an empty list is returned.
        |  %% @end
        |  -spec drop_last(N, List1) -&gt; {Dropped, List2} when
        |        N :: non_neg_integer(),
        |        List1 :: list(),
        |        Dropped :: non_neg_integer(),
        |        List2 :: list().
        |  drop_last(N, List) -&gt;
<font color=red>     0..|      {ToDrop, List2} = lists:foldr(fun(E, {0, Acc}) -&gt;</font>
<font color=red>     0..|                                            {0, [E | Acc]};</font>
        |                                       (_, {ToDrop, Acc}) -&gt;
<font color=red>     0..|                                            {ToDrop-1, Acc}</font>
        |                                    end, {N, []}, List),
<font color=red>     0..|      {N - ToDrop, List2}.</font>
        |  
        |  -spec get_buffer_max() -&gt; pos_integer() | infinity.
        |  get_buffer_max() -&gt;
<font color=red>     0..|      mod_stream_management:get_buffer_max(?STREAM_MGMT_CACHE_MAX).</font>
        |  
        |  -spec get_ack_freq() -&gt; pos_integer().
        |  get_ack_freq() -&gt;
<font color=red>     0..|      mod_stream_management:get_ack_freq(?STREAM_MGMT_ACK_FREQ).</font>
        |  
        |  -spec get_resume_timeout() -&gt; pos_integer().
        |  get_resume_timeout() -&gt;
<font color=red>     0..|      mod_stream_management:get_resume_timeout(?STREAM_MGMT_RESUME_TIMEOUT).</font>
        |  
        |  maybe_send_ack_request(#state{stream_mgmt = false}) -&gt;
<font color=red>     0..|      false;</font>
        |  maybe_send_ack_request(#state{stream_mgmt_ack_freq = never}) -&gt;
<font color=red>     0..|      false;</font>
        |  maybe_send_ack_request(#state{stream_mgmt_out_acked = Out,
        |                                stream_mgmt_buffer_size = BufferSize,
        |                                stream_mgmt_ack_freq = AckFreq} = State)
        |    when (Out + BufferSize) rem AckFreq == 0 -&gt;
<font color=red>     0..|      send_element(State, stream_mgmt_request()),</font>
<font color=red>     0..|      true;</font>
        |  maybe_send_ack_request(_) -&gt;
<font color=red>     0..|      false.</font>
        |  
        |  stream_mgmt_request() -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"r"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STREAM_MGNT_3}]}.
        |  
        |  flush_stream_mgmt_buffer(#state{stream_mgmt = false}) -&gt;
<font color=red>     0..|      false;</font>
        |  flush_stream_mgmt_buffer(#state{stream_mgmt_buffer = Buffer}) -&gt;
        |      %% TODO add delayed on it?
<font color=red>     0..|      [ejabberd_router:route(From, To, Packet)</font>
<font color=red>     0..|       || {From, To, Packet} &lt;- lists:reverse(Buffer)].</font>
        |  
        |  maybe_enter_resume_session(undefined, StateData) -&gt;
<font color=red>     0..|      {stop, normal, StateData};</font>
        |  maybe_enter_resume_session(_SMID, #state{} = SD) -&gt;
<font color=red>     0..|      NSD = case SD#state.stream_mgmt_resume_tref of</font>
        |                undefined -&gt;
<font color=red>     0..|                    Seconds = timer:seconds(SD#state.stream_mgmt_resume_timeout),</font>
<font color=red>     0..|                    TRef = erlang:send_after(Seconds, self(), resume_timeout),</font>
<font color=red>     0..|                    SD#state{stream_mgmt_resume_tref = TRef};</font>
        |                _TRef -&gt;
<font color=red>     0..|                    SD</font>
        |            end,
<font color=red>     0..|      {next_state, resume_session, NSD, hibernate}.</font>
        |  
        |  maybe_resume_session(NextState, El, StateData) -&gt;
<font color=red>     0..|      case {xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, El),</font>
        |            xml:get_tag_attr_s(&lt;&lt;"previd"&gt;&gt;, El)} of
        |          {?NS_STREAM_MGNT_3, SMID} -&gt;
<font color=red>     0..|              MaybeSID = mod_stream_management:get_sid(SMID),</font>
<font color=red>     0..|              do_resume_session(SMID, El, MaybeSID, StateData);</font>
        |          {InvalidNS, _} -&gt;
<font color=red>     0..|              ?INFO_MSG("ignoring &lt;resume/&gt; element "</font>
        |                        "with invalid namespace ~s~n", [InvalidNS]),
<font color=red>     0..|              fsm_next_state(NextState, StateData)</font>
        |      end.
        |  
        |  do_resume_session(SMID, El, [{_, Pid}], StateData) -&gt;
<font color=red>     0..|      try</font>
<font color=red>     0..|          {ok, OldState} = ?GEN_FSM:sync_send_event(Pid, resume),</font>
<font color=red>     0..|          SID = {now(), self()},</font>
<font color=red>     0..|          Conn = get_conn_type(StateData),</font>
<font color=red>     0..|          MergedState = merge_state(OldState,</font>
        |                                    StateData#state{sid = SID, conn = Conn}),
<font color=red>     0..|          Priority = get_priority_from_presence(MergedState#state.pres_last),</font>
<font color=red>     0..|          Info = [{ip, MergedState#state.ip},</font>
        |                  {conn, MergedState#state.conn},
        |                  {auth_module, MergedState#state.auth_module}],
<font color=red>     0..|          ejabberd_sm:open_session(SID,</font>
        |                                   MergedState#state.user,
        |                                   MergedState#state.server,
        |                                   MergedState#state.resource,
        |                                   Priority, Info),
<font color=red>     0..|          ok = mod_stream_management:register_smid(SMID, SID),</font>
<font color=red>     0..|          case stream_mgmt_handle_ack(session_established, El, MergedState) of</font>
        |              {stop, _, _} = Stop -&gt;
<font color=red>     0..|                  Stop;</font>
        |              {next_state, session_established, NSD, _} -&gt;
<font color=red>     0..|                  try</font>
<font color=red>     0..|                      Resumed = stream_mgmt_resumed(NSD#state.stream_mgmt_id,</font>
        |                                                    NSD#state.stream_mgmt_in),
<font color=red>     0..|                      send_element(NSD, Resumed),</font>
<font color=red>     0..|                      [send_element(NSD, Packet)</font>
<font color=red>     0..|                       || {_, _,Packet} &lt;- lists:reverse(NSD#state.stream_mgmt_buffer)],</font>
<font color=red>     0..|                      fsm_next_state(session_established, NSD)</font>
        |                  catch
        |                      %% errors from send_element
        |                      _:_ -&gt;
<font color=red>     0..|                          ?INFO_MSG("resumption error while resending old stanzas entering resume state again smid: ~p~n",[SMID]),</font>
<font color=red>     0..|                          maybe_enter_resume_session(SMID, NSD)</font>
        |                  end
        |          end
        |      catch
        |          _:_ -&gt;
<font color=red>     0..|              ?WARNING_MSG("resumption error (invalid response from ~p)~n",</font>
        |                           [Pid]),
<font color=red>     0..|              send_element(StateData, stream_mgmt_failed(&lt;&lt;"item-not-found"&gt;&gt;)),</font>
<font color=red>     0..|              fsm_next_state(wait_for_bind_or_resume, StateData)</font>
        |      end;
        |  
        |  do_resume_session(SMID, _El, [], StateData) -&gt;
<font color=red>     0..|      ?WARNING_MSG("no previous session with stream id ~p~n", [SMID]),</font>
<font color=red>     0..|      send_element(StateData, stream_mgmt_failed(&lt;&lt;"item-not-found"&gt;&gt;)),</font>
<font color=red>     0..|      fsm_next_state(wait_for_bind_or_resume, StateData).</font>
        |  
        |  merge_state(OldSD, SD) -&gt;
<font color=red>     0..|      Preserve = [#state.jid,</font>
        |                  #state.user,
        |                  #state.server,
        |                  #state.resource,
        |                  #state.pres_t,
        |                  #state.pres_f,
        |                  #state.pres_a,
        |                  #state.pres_i,
        |                  #state.pres_last,
        |                  #state.pres_pri,
        |                  #state.pres_timestamp,
        |                  #state.pres_invis,
        |                  #state.privacy_list,
        |                  #state.aux_fields,
        |                  #state.stream_mgmt,
        |                  #state.stream_mgmt_in,
        |                  #state.stream_mgmt_id,
        |                  #state.stream_mgmt_out_acked,
        |                  #state.stream_mgmt_buffer,
        |                  #state.stream_mgmt_buffer_size,
        |                  #state.stream_mgmt_buffer_max,
        |                  #state.stream_mgmt_ack_freq],
<font color=red>     0..|      Copy = fun(Index, {Stale, Acc}) -&gt;</font>
<font color=red>     0..|                     {Stale, setelement(Index, Acc, element(Index, Stale))}</font>
        |             end,
<font color=red>     0..|      element(2, lists:foldl(Copy, {OldSD, SD}, Preserve)).</font>
        |  
        |  stream_mgmt_resumed(SMID, Handled) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"resumed"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STREAM_MGNT_3},
        |                      {&lt;&lt;"previd"&gt;&gt;, SMID},
        |                      {&lt;&lt;"h"&gt;&gt;, integer_to_binary(Handled)}]}.
        |  
        |  handover_session(SD) -&gt;
        |      %% Assert Stream Management is on; otherwise this should not be called.
<font color=red>     0..|      true = SD#state.stream_mgmt,</font>
<font color=red>     0..|      ejabberd_sm:close_session(SD#state.sid,</font>
        |                                SD#state.user,
        |                                SD#state.server,
        |                                SD#state.resource,
        |                                resumed),
<font color=red>     0..|      {N, Messages} = flush_messages(),</font>
<font color=red>     0..|      NewSize = N + SD#state.stream_mgmt_buffer_size,</font>
<font color=red>     0..|      NewBuffer = Messages ++ SD#state.stream_mgmt_buffer,</font>
<font color=red>     0..|      NSD = SD#state{authenticated = resumed,</font>
        |                     stream_mgmt_buffer_size = NewSize,
        |                     stream_mgmt_buffer = NewBuffer},
<font color=red>     0..|      {stop, normal, {ok, NSD}, NSD}.</font>
        |  
        |  maybe_add_timestamp({F, T, #xmlel{name= &lt;&lt;"message"&gt;&gt;}=Packet}=PacketTuple, Timestamp) -&gt;
<font color=red>     0..|      Type = xml:get_tag_attr_s(&lt;&lt;"type"&gt;&gt;, Packet),</font>
<font color=red>     0..|      case Type of</font>
        |          &lt;&lt;"error"&gt;&gt; -&gt;
<font color=red>     0..|              PacketTuple;</font>
        |          &lt;&lt;"headline"&gt;&gt; -&gt;
<font color=red>     0..|              PacketTuple;</font>
        |          _ -&gt;
<font color=red>     0..|              {F, T, add_timestamp(Timestamp,&lt;&lt;"localhost"&gt;&gt;, Packet)}</font>
        |      end;
        |  maybe_add_timestamp(Packet, _Timestamp) -&gt;
<font color=red>     0..|      Packet.</font>
        |  
        |  add_timestamp({_,_,Micro} = TimeStamp, Server, Packet) -&gt;
<font color=red>     0..|      {D,{H,M,S}} = calendar:now_to_universal_time(TimeStamp),</font>
<font color=red>     0..|      Time = {D,{H,M,S, Micro}},</font>
<font color=red>     0..|      case xml:get_subtag(Packet, &lt;&lt;"delay"&gt;&gt;) of</font>
        |          false -&gt;
<font color=red>     0..|              TimeStampXML = timestamp_xml(Server, Time),</font>
<font color=red>     0..|              xml:append_subtags(Packet, [TimeStampXML]);</font>
        |          _ -&gt;
<font color=red>     0..|              Packet</font>
        |      end.
        |  
        |  timestamp_xml(Server, Time) -&gt;
<font color=red>     0..|      FromJID = jid:make(&lt;&lt;&gt;&gt;, Server, &lt;&lt;&gt;&gt;),</font>
<font color=red>     0..|      jlib:timestamp_to_xml(Time, utc, FromJID, &lt;&lt;"SM Storage"&gt;&gt;).</font>
        |  
        |  defer_resource_constraint_check(#state{stream_mgmt_constraint_check_tref = undefined} = State)-&gt;
<font color=red>     0..|      Seconds = timer:seconds(?CONSTRAINT_CHECK_TIMEOUT),</font>
<font color=red>     0..|      TRef = erlang:send_after(Seconds, self(), check_buffer_full),</font>
<font color=red>     0..|      State#state{stream_mgmt_constraint_check_tref = TRef};</font>
        |  defer_resource_constraint_check(State)-&gt;
<font color=red>     0..|      State.</font>
        |  
        |  sasl_success_stanza(ServerOut) -&gt;
<font color=red>     0..|      C = case ServerOut of</font>
<font color=red>     0..|              undefined -&gt; [];</font>
<font color=red>     0..|              _ -&gt; [#xmlcdata{content = jlib:encode_base64(ServerOut)}]</font>
        |          end,
<font color=red>     0..|      #xmlel{name = &lt;&lt;"success"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_SASL}],
        |             children = C}.
        |  
        |  sasl_failure_stanza(Error) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"failure"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_SASL}],
        |             children = [#xmlel{name = Error}]}.
        |  
        |  sasl_challenge_stanza(Challenge) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"challenge"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_SASL}],
        |             children = Challenge}.
        |  
        |  handle_sasl_success(State, Props) -&gt;
<font color=red>     0..|      handle_sasl_success(State, Props, undefined).</font>
        |  handle_sasl_success(State, Props, ServerOut) -&gt;
<font color=red>     0..|      (State#state.sockmod):reset_stream(State#state.socket),</font>
<font color=red>     0..|      send_element(State, sasl_success_stanza(ServerOut)),</font>
<font color=red>     0..|      U = proplists:get_value(username, Props, &lt;&lt;&gt;&gt;),</font>
<font color=red>     0..|      AuthModule = proplists:get_value(auth_module, Props, &lt;&lt;&gt;&gt;),</font>
<font color=red>     0..|      ?INFO_MSG("(~w) Accepted authentication for ~s by ~p",</font>
        |                [State#state.socket, U, AuthModule]),
<font color=red>     0..|      NewState = State#state{</font>
        |                   streamid = new_id(),
        |                   authenticated = true,
        |                   auth_module = AuthModule,
        |                   user = U},
<font color=red>     0..|      {wait_for_stream, NewState}.</font>
        |  
        |  handle_sasl_step(#state{server = Server, socket= Sock} = State, StepRes) -&gt;
<font color=red>     0..|      case StepRes of</font>
        |          {ok, Props} -&gt;
<font color=red>     0..|              handle_sasl_success(State, Props);</font>
        |          {ok, Props, ServerOut} -&gt;
<font color=red>     0..|              handle_sasl_success(State, Props, ServerOut);</font>
        |          {continue, ServerOut, NewSASLState} -&gt;
<font color=red>     0..|              Challenge  = [#xmlcdata{content = jlib:encode_base64(ServerOut)}],</font>
<font color=red>     0..|              send_element(State, sasl_challenge_stanza(Challenge)),</font>
<font color=red>     0..|              {wait_for_sasl_response, State#state{sasl_state = NewSASLState}};</font>
        |          {error, Error, Username} -&gt;
<font color=red>     0..|              IP = peerip(State#state.sockmod, Sock),</font>
<font color=red>     0..|              ?INFO_MSG("(~w) Failed authentication for ~s@~s from IP ~s (~w)",</font>
        |                        [Sock, Username, Server, jlib:ip_to_list(IP), IP]),
<font color=red>     0..|              ejabberd_hooks:run(auth_failed, Server, [Username, Server]),</font>
<font color=red>     0..|              send_element(State, sasl_failure_stanza(Error)),</font>
<font color=red>     0..|              {wait_for_feature_request, State};</font>
        |          {error, Error} -&gt;
<font color=red>     0..|              ejabberd_hooks:run(auth_failed, Server, [unknown, Server]),</font>
<font color=red>     0..|              send_element(State, sasl_failure_stanza(Error)),</font>
<font color=red>     0..|              {wait_for_feature_request, State}</font>
        |      end.
        |  
        |  user_allowed(JID, #state{server = Server, access = Access}) -&gt;
<font color=red>     0..|      case acl:match_rule(Server, Access, JID)  of</font>
        |          allow -&gt;
<font color=red>     0..|              open_session_allowed_hook(Server, JID);</font>
        |          deny -&gt;
<font color=red>     0..|              false</font>
        |      end.
        |  
        |  open_session_allowed_hook(Server, JID) -&gt;
<font color=red>     0..|      allow == ejabberd_hooks:run_fold(session_opening_allowed_for_user,</font>
        |                                       Server,
        |                                       allow, [JID]).
</pre>
</body>
</html>
