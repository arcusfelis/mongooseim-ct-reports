<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<title>/home/travis/build/esl/MongooseIM/apps/ejabberd/logs/ct_run.test@testing-gce-dfbddb12-93f9-4cdf-943f-b4c634aece59.c.eco-emissary-99515.internal.2016-01-26_09.54.34/apps.ejabberd.revproxy_SUITE.logs/run.2016-01-26_09.54.42/jlib.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/esl/MongooseIM/apps/ejabberd/ebin/../src/jlib.erl by COVER 2016-01-26 at 09:55:23

****************************************************************************

        |  %%%----------------------------------------------------------------------
        |  %%% File    : jlib.erl
        |  %%% Author  : Alexey Shchepin &lt;alexey@process-one.net&gt;
        |  %%% Purpose : General XMPP library.
        |  %%% Created : 23 Nov 2002 by Alexey Shchepin &lt;alexey@process-one.net&gt;
        |  %%%
        |  %%%
        |  %%% ejabberd, Copyright (C) 2002-2011   ProcessOne
        |  %%%
        |  %%% This program is free software; you can redistribute it and/or
        |  %%% modify it under the terms of the GNU General Public License as
        |  %%% published by the Free Software Foundation; either version 2 of the
        |  %%% License, or (at your option) any later version.
        |  %%%
        |  %%% This program is distributed in the hope that it will be useful,
        |  %%% but WITHOUT ANY WARRANTY; without even the implied warranty of
        |  %%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        |  %%% General Public License for more details.
        |  %%%
        |  %%% You should have received a copy of the GNU General Public License
        |  %%% along with this program; if not, write to the Free Software
        |  %%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
        |  %%% 02111-1307 USA
        |  %%%
        |  %%%----------------------------------------------------------------------
        |  
        |  -module(jlib).
        |  -author('alexey@process-one.net').
        |  -xep([{xep, 59}, {version, "1.0"}]).
        |  -xep([{xep, 68}, {version, "1.2"}]).
        |  -xep([{xep, 86}, {version, "1.0"}]).
        |  -export([make_result_iq_reply/1,
        |           make_error_reply/2,
        |           make_invitation/3,
        |           make_config_change_message/1,
        |           make_voice_approval_form/3,
        |           replace_from_to_attrs/3,
        |           replace_from_to/3,
        |           remove_attr/2,
        |           make_jid/3,
        |           make_jid/1,
        |           are_equal_jids/2,
        |           binary_to_jid/1,
        |           jid_to_binary/1,
        |           is_nodename/1,
        |           nodeprep/1,
        |           nameprep/1,
        |           resourceprep/1,
        |           jid_to_lower/1,
        |           jid_tolower/1,
        |           jid_remove_resource/1,
        |           jid_replace_resource/2,
        |           iq_query_info/1,
        |           iq_query_or_response_info/1,
        |           iq_to_xml/1,
        |           parse_xdata_submit/1,
        |           timestamp_to_xml/4,
        |           timestamp_to_mam_xml/4,
        |           timestamp_to_iso/2,
        |           now_to_utc_binary/1,
        |           now_to_utc_string/1,
        |           datetime_binary_to_timestamp/1,
        |           decode_base64/1,
        |           encode_base64/1,
        |           ip_to_list/1,
        |           rsm_encode/1,
        |           rsm_decode/1,
        |           stanza_error/3,
        |           stanza_errort/5,
        |           stream_error/1,
        |           stream_errort/3,
        |           remove_delay_tags/1]).
        |  
        |  -include_lib("exml/include/exml.hrl").
        |  -include_lib("exml/include/exml_stream.hrl"). % only used to define stream types
        |  -include("jlib.hrl").
        |  -include("ejabberd.hrl").
        |  
        |  -type xmlel()           :: #xmlel{}.
        |  %% Stream types defined in exml/include/exml_stream.hrl
        |  -type xmlstreamstart()  :: #xmlstreamstart{}.
        |  -type xmlstreamend()    :: #xmlstreamend{}.
        |  -type xmlstreamel() :: xmlel() | xmlstreamstart() | xmlstreamend().
        |  
        |  -type rsm_in()    :: #rsm_in{}.
        |  -type rsm_out()   :: #rsm_out{}.
        |  -type xmlcdata()  :: #xmlcdata{}.
        |  
        |  -type binary_pair() :: {binary(), binary()}.
        |  
        |  -export_type([xmlel/0, xmlstreamstart/0, xmlstreamend/0, xmlstreamel/0,
        |                binary_pair/0,
        |                rsm_in/0, rsm_out/0,
        |                xmlcdata/0
        |               ]).
        |  
        |  %% Datetime format where all or some elements may be 'false' or integer()
        |  -type maybe_datetime() :: {
        |                          { 'false' | non_neg_integer(),
        |                            'false' | non_neg_integer(),
        |                            'false' | non_neg_integer() },
        |                        integer(),
        |                        'false' | integer(),
        |                        'false' | integer()
        |                        }.
        |  %% Timezone format where all or some elements may be 'false' or integer()
        |  -type maybe_tz() :: {'false' | non_neg_integer(),'false' | non_neg_integer()}.
        |  
        |  %% Time format where all or some elements may be 'false' or integer()
        |  -type maybe_time() :: {'false' | non_neg_integer(),
        |                         'false' | non_neg_integer(),
        |                         'false' | non_neg_integer()}.
        |  
        |  
        |  -spec make_result_iq_reply(xmlel()) -&gt; xmlel().
        |  make_result_iq_reply(XE = #xmlel{attrs = Attrs}) -&gt;
<font color=red>     0..|      NewAttrs = make_result_iq_reply_attrs(Attrs),</font>
<font color=red>     0..|      XE#xmlel{attrs = NewAttrs}.</font>
        |  
        |  
        |  -spec make_result_iq_reply_attrs([binary_pair()]) -&gt; [binary_pair(),...].
        |  make_result_iq_reply_attrs(Attrs) -&gt;
<font color=red>     0..|      To = xml:get_attr(&lt;&lt;"to"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      From = xml:get_attr(&lt;&lt;"from"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      Attrs1 = lists:keydelete(&lt;&lt;"to"&gt;&gt;, 1, Attrs),</font>
<font color=red>     0..|      Attrs2 = lists:keydelete(&lt;&lt;"from"&gt;&gt;, 1, Attrs1),</font>
<font color=red>     0..|      Attrs3 = case To of</font>
        |                   {value, ToVal} -&gt;
<font color=red>     0..|                       [{&lt;&lt;"from"&gt;&gt;, ToVal} | Attrs2];</font>
        |                   _ -&gt;
<font color=red>     0..|                       Attrs2</font>
        |               end,
<font color=red>     0..|      Attrs4 = case From of</font>
        |                   {value, FromVal} -&gt;
<font color=red>     0..|                       [{&lt;&lt;"to"&gt;&gt;, FromVal} | Attrs3];</font>
        |                   _ -&gt;
<font color=red>     0..|                       Attrs3</font>
        |               end,
<font color=red>     0..|      Attrs5 = lists:keydelete(&lt;&lt;"type"&gt;&gt;, 1, Attrs4),</font>
<font color=red>     0..|      [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"result"&gt;&gt;} | Attrs5].</font>
        |  
        |  
        |  -spec make_error_reply(xmlel(), xmlcdata() | xmlel()) -&gt; xmlel().
        |  make_error_reply(#xmlel{name = Name, attrs = Attrs,
        |                          children = SubTags}, Error) -&gt;
<font color=red>     0..|      NewAttrs = make_error_reply_attrs(Attrs),</font>
<font color=red>     0..|      #xmlel{name = Name, attrs = NewAttrs, children = SubTags ++ [Error]}.</font>
        |  
        |  
        |  -spec make_error_reply_attrs([binary_pair()]) -&gt; [binary_pair(),...].
        |  make_error_reply_attrs(Attrs) -&gt;
<font color=red>     0..|      To = xml:get_attr(&lt;&lt;"to"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      From = xml:get_attr(&lt;&lt;"from"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      Attrs1 = lists:keydelete(&lt;&lt;"to"&gt;&gt;, 1, Attrs),</font>
<font color=red>     0..|      Attrs2 = lists:keydelete(&lt;&lt;"from"&gt;&gt;, 1, Attrs1),</font>
<font color=red>     0..|      Attrs3 = case To of</font>
        |                   {value, ToVal} -&gt;
<font color=red>     0..|                       [{&lt;&lt;"from"&gt;&gt;, ToVal} | Attrs2];</font>
        |                   _ -&gt;
<font color=red>     0..|                       Attrs2</font>
        |               end,
<font color=red>     0..|      Attrs4 = case From of</font>
        |                   {value, FromVal} -&gt;
<font color=red>     0..|                       [{&lt;&lt;"to"&gt;&gt;, FromVal} | Attrs3];</font>
        |                   _ -&gt;
<font color=red>     0..|                       Attrs3</font>
        |               end,
<font color=red>     0..|      Attrs5 = lists:keydelete(&lt;&lt;"type"&gt;&gt;, 1, Attrs4),</font>
<font color=red>     0..|      Attrs6 = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"error"&gt;&gt;} | Attrs5],</font>
<font color=red>     0..|      Attrs6.</font>
        |  
        |  
        |  -spec make_config_change_message(binary()) -&gt; xmlel().
        |  make_config_change_message(Status) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"message"&gt;&gt;, attrs = [{&lt;&lt;"type"&gt;&gt;, &lt;&lt;"groupchat"&gt;&gt;}],</font>
        |             children = [#xmlel{name = &lt;&lt;"x"&gt;&gt;,
        |                                attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_USER}],
        |                                children = [#xmlel{name = &lt;&lt;"status"&gt;&gt;,
        |                                                   attrs = [{&lt;&lt;"code"&gt;&gt;, Status}]}]}]}.
        |  
        |  
        |  -spec make_invitation(From :: ejabberd:jid(), Password :: binary(),
        |                        Reason :: binary()) -&gt; xmlel().
        |  make_invitation(From, Password, Reason) -&gt;
<font color=red>     0..|      Elements = [#xmlel{name = &lt;&lt;"invite"&gt;&gt;,</font>
        |                         attrs = [{&lt;&lt;"from"&gt;&gt;, jid:to_binary(From)}]}],
<font color=red>     0..|      Elements2 = case Password of</font>
<font color=red>     0..|          &lt;&lt;&gt;&gt; -&gt; Elements;</font>
<font color=red>     0..|          _ -&gt; [#xmlel{name = &lt;&lt;"password"&gt;&gt;,</font>
        |                       children = [#xmlcdata{content = Password}]} | Elements]
        |                  end,
<font color=red>     0..|      Elements3 = case Reason of</font>
<font color=red>     0..|          &lt;&lt;&gt;&gt; -&gt; Elements2;</font>
<font color=red>     0..|          _ -&gt; [#xmlel{name = &lt;&lt;"reason"&gt;&gt;,</font>
        |                       children = [#xmlcdata{content = Reason}]} | Elements2]
        |                  end,
        |  
<font color=red>     0..|      #xmlel{name = &lt;&lt;"message"&gt;&gt;,</font>
        |             children = [#xmlel{name = &lt;&lt;"x"&gt;&gt;,
        |                                attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_MUC_USER}],
        |                                children = Elements3}]}.
        |  
        |  
        |  -spec form_field({binary(), binary(), binary()}
        |                 | {binary(), binary(), binary(), binary()}) -&gt; xmlel().
        |  form_field({Var, Type, Value, Label}) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"field"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"var"&gt;&gt;, Var}, {&lt;&lt;"type"&gt;&gt;, Type}, {&lt;&lt;"label"&gt;&gt;, Label}],
        |             children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                children = [#xmlcdata{content = Value}]}]};
        |  form_field({Var, Type, Value}) -&gt;
<font color=red>     0..|      #xmlel{name = &lt;&lt;"field"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"var"&gt;&gt;, Var}, {&lt;&lt;"type"&gt;&gt;, Type}],
        |             children = [#xmlel{name = &lt;&lt;"value"&gt;&gt;,
        |                                children = [#xmlcdata{content = Value}]}]}.
        |  
        |  
        |  -spec make_voice_approval_form(From :: ejabberd:simple_jid() | ejabberd:jid(),
        |                                 Nick :: binary(), Role :: binary()) -&gt; xmlel().
        |  make_voice_approval_form(From, Nick, Role) -&gt;
<font color=red>     0..|    Fields = [{&lt;&lt;"FORM_TYPE"&gt;&gt;, &lt;&lt;"hidden"&gt;&gt;, ?NS_MUC_REQUEST},</font>
        |      {&lt;&lt;"muc#role"&gt;&gt;, &lt;&lt;"text-single"&gt;&gt;, Role, &lt;&lt;"Request role"&gt;&gt;},
        |      {&lt;&lt;"muc#jid"&gt;&gt;, &lt;&lt;"jid-single"&gt;&gt;, jid:to_binary(From), &lt;&lt;"User ID"&gt;&gt;},
        |      {&lt;&lt;"muc#roomnick"&gt;&gt;, &lt;&lt;"text-single"&gt;&gt;, Nick, &lt;&lt;"Room Nickname"&gt;&gt;},
        |      {&lt;&lt;"muc#request_allow"&gt;&gt;, &lt;&lt;"boolean"&gt;&gt;, &lt;&lt;"false"&gt;&gt;, &lt;&lt;"Grant voice to this person?"&gt;&gt;}
        |    ],
<font color=red>     0..|    #xmlel{name = &lt;&lt;"message"&gt;&gt;,</font>
        |          children = [
        |            #xmlel{name = &lt;&lt;"x"&gt;&gt;,
        |            attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_XDATA}, {&lt;&lt;"type"&gt;&gt;, &lt;&lt;"form"&gt;&gt;}],
        |            children = [#xmlel{name = &lt;&lt;"title"&gt;&gt;,
        |            children = [#xmlcdata{content = &lt;&lt;"Voice request"&gt;&gt;}]},
        |              #xmlel{name = &lt;&lt;"instructions"&gt;&gt;,
        |              children = [#xmlcdata{content = &lt;&lt;"To approve this request",
        |              " for voice, select the &amp;quot;Grant voice to this person?&amp;quot; checkbox",
        |              " and click OK. To skip this request, click the cancel button."&gt;&gt;}]} |
<font color=red>     0..|              [form_field(El) || El &lt;- Fields]</font>
        |            ]}
        |          ]}.
        |  
        |  
        |  -spec replace_from_to_attrs(From :: binary(), To :: binary(), [binary_pair()]) -&gt; [binary_pair()].
        |  replace_from_to_attrs(From, To, Attrs) -&gt;
<font color=red>     0..|      Attrs1 = lists:keydelete(&lt;&lt;"to"&gt;&gt;, 1, Attrs),</font>
<font color=red>     0..|      Attrs2 = lists:keydelete(&lt;&lt;"from"&gt;&gt;, 1, Attrs1),</font>
<font color=red>     0..|      Attrs3 = [{&lt;&lt;"to"&gt;&gt;, To} | Attrs2],</font>
<font color=red>     0..|      Attrs4 = [{&lt;&lt;"from"&gt;&gt;, From} | Attrs3],</font>
<font color=red>     0..|      Attrs4.</font>
        |  
        |  
        |  -spec replace_from_to(From :: ejabberd:simple_jid() | ejabberd:jid(),
        |                        To :: ejabberd:simple_jid() | ejabberd:jid(),
        |                        XE :: xmlel()) -&gt; xmlel().
        |  replace_from_to(From, To, XE = #xmlel{attrs = Attrs}) -&gt;
<font color=red>     0..|      NewAttrs = replace_from_to_attrs(jid:to_binary(From),</font>
        |                                       jid:to_binary(To),
        |                                       Attrs),
<font color=red>     0..|      XE#xmlel{attrs = NewAttrs}.</font>
        |  
        |  
        |  -spec remove_attr(binary(), xmlel()) -&gt; xmlel().
        |  remove_attr(Attr, XE = #xmlel{attrs = Attrs}) -&gt;
<font color=red>     0..|      NewAttrs = lists:keydelete(Attr, 1, Attrs),</font>
<font color=red>     0..|      XE#xmlel{attrs = NewAttrs}.</font>
        |  
        |  
        |  -spec make_jid(User     :: ejabberd:user(),
        |                 Server   :: ejabberd:server(),
        |                 Resource :: ejabberd:resource()) -&gt; ejabberd:jid() | error.
        |  make_jid(User, Server, Resource) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:make(User, Server, Resource).</font>
        |  
        |  -spec make_jid(ejabberd:simple_jid()) -&gt; ejabberd:jid() | error.
        |  make_jid({User, Server, Resource}) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      make_jid(User, Server, Resource).</font>
        |  
        |  -spec are_equal_jids(ejabberd:jid(), ejabberd:jid()) -&gt; boolean().
        |  are_equal_jids(JID1, JID2) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:are_equal(JID1, JID2).</font>
        |  
        |  
        |  -spec binary_to_jid(binary()) -&gt; 'error' | ejabberd:jid().
        |  binary_to_jid(J) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:from_binary(J).</font>
        |  
        |  
        |  -spec jid_to_binary(ejabberd:simple_jid() | ejabberd:jid()) -&gt; binary().
        |  jid_to_binary(JID) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:to_binary(JID).</font>
        |  
        |  -spec is_nodename(&lt;&lt;&gt;&gt; | binary()) -&gt; boolean().
        |  is_nodename(J) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:is_nodename(J).</font>
        |  
        |  -spec nodeprep(ejabberd:user()) -&gt; 'error' | ejabberd:lserver().
        |  nodeprep(S) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:nodeprep(S).</font>
        |  
        |  
        |  -spec nameprep(ejabberd:server()) -&gt; 'error' | ejabberd:luser().
        |  nameprep(S) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:nameprep(S).</font>
        |  
        |  -spec resourceprep(ejabberd:resource()) -&gt;
        |      'error' | ejabberd:lresource().
        |  resourceprep(S) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:resourceprep(S).</font>
        |  
        |  
        |  %% @doc You are a bad person if you use this function.
        |  -spec jid_tolower(JID :: ejabberd:simple_jid() | ejabberd:jid()
        |                   ) -&gt; error | ejabberd:simple_jid().
        |  jid_tolower(Any) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:to_lower(Any).</font>
        |  
        |  -spec jid_to_lower(JID :: ejabberd:simple_jid() | ejabberd:jid()
        |                   ) -&gt; error | ejabberd:simple_jid().
        |  jid_to_lower(JID) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:to_lower(JID).</font>
        |  
        |  -spec jid_remove_resource(ejabberd:simple_jid() | ejabberd:jid()) -&gt;
        |                            ejabberd:simple_jid() | ejabberd:jid().
        |  jid_remove_resource(JID) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:to_bare(JID).</font>
        |  
        |  
        |  -spec jid_replace_resource(ejabberd:jid(), ejabberd:resource()) -&gt;
        |                                                    'error' | ejabberd:jid().
        |  jid_replace_resource(JID, Resource) -&gt;
<font color=red>     0..|      ?WARNING_MSG("This function has been deprecated in MongooseIM 1.6.1 and will be removed in 1.7.0", []),</font>
<font color=red>     0..|      jid:replace_resource(JID, Resource).</font>
        |  
        |  
        |  -spec iq_query_info(xmlel()) -&gt; 'invalid' | 'not_iq' | 'reply' | ejabberd:iq().
        |  iq_query_info(El) -&gt;
<font color=red>     0..|      iq_info_internal(El, request).</font>
        |  
        |  
        |  -spec iq_query_or_response_info(xmlel()) -&gt;
        |                                  'invalid' | 'not_iq' | 'reply' | ejabberd:iq().
        |  iq_query_or_response_info(El) -&gt;
<font color=red>     0..|      iq_info_internal(El, any).</font>
        |  
        |  
        |  -spec iq_info_internal(xmlel(), Filter :: 'any' | 'request') -&gt;
        |                                  'invalid' | 'not_iq' | 'reply' | ejabberd:iq().
        |  iq_info_internal(#xmlel{name = Name, attrs = Attrs,
        |                          children = Els}, Filter) when Name == &lt;&lt;"iq"&gt;&gt; -&gt;
        |      %% Filter is either request or any.  If it is request, any replies
        |      %% are converted to the atom reply.
<font color=red>     0..|      ID = xml:get_attr_s(&lt;&lt;"id"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      Type = xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      Lang = xml:get_attr_s(&lt;&lt;"xml:lang"&gt;&gt;, Attrs),</font>
<font color=red>     0..|      {Type1, Class} = case Type of</font>
<font color=red>     0..|                           &lt;&lt;"set"&gt;&gt; -&gt; {set, request};</font>
<font color=red>     0..|                           &lt;&lt;"get"&gt;&gt; -&gt; {get, request};</font>
<font color=red>     0..|                           &lt;&lt;"result"&gt;&gt; -&gt; {result, reply};</font>
<font color=red>     0..|                           &lt;&lt;"error"&gt;&gt; -&gt; {error, reply};</font>
<font color=red>     0..|                           _ -&gt; {invalid, invalid}</font>
        |                       end,
<font color=red>     0..|      if</font>
        |          Type1 == invalid -&gt;
<font color=red>     0..|              invalid;</font>
        |          Class == request; Filter == any -&gt;
        |              %% The iq record is a bit strange.  The sub_el field is an
        |              %% XML tuple for requests, but a list of XML tuples for
        |              %% responses.
<font color=red>     0..|              FilteredEls = xml:remove_cdata(Els),</font>
<font color=red>     0..|              {XMLNS, SubEl} =</font>
        |                  case {Class, FilteredEls} of
        |                      {request, [#xmlel{attrs = Attrs2}]} -&gt;
<font color=red>     0..|                          {xml:get_attr_s(&lt;&lt;"xmlns"&gt;&gt;, Attrs2),</font>
        |                           hd(FilteredEls)};
        |                      {reply, _} -&gt;
        |                          %% Find the namespace of the first non-error
        |                          %% element, if there is one.
<font color=red>     0..|                          NonErrorEls = [El ||</font>
        |                                            #xmlel{name = SubName} = El
<font color=red>     0..|                                                &lt;- FilteredEls,</font>
<font color=red>     0..|                                            SubName /= &lt;&lt;"error"&gt;&gt;],</font>
<font color=red>     0..|                          {case NonErrorEls of</font>
        |                               [NonErrorEl] -&gt;
<font color=red>     0..|                                   xml:get_tag_attr_s(&lt;&lt;"xmlns"&gt;&gt;, NonErrorEl);</font>
        |                               _ -&gt;
<font color=red>     0..|                                   &lt;&lt;&gt;&gt;</font>
        |                           end,
        |                           FilteredEls};
        |                      _ -&gt;
<font color=red>     0..|                          {&lt;&lt;&gt;&gt;, []}</font>
        |                  end,
<font color=red>     0..|              if XMLNS == &lt;&lt;&gt;&gt;, Class == request -&gt;</font>
<font color=red>     0..|                      invalid;</font>
        |                 true -&gt;
<font color=red>     0..|                      #iq{id = ID,</font>
        |                          type = Type1,
        |                          xmlns = XMLNS,
        |                          lang = Lang,
        |                          sub_el = SubEl}
        |              end;
        |          Class == reply, Filter /= any -&gt;
<font color=red>     0..|              reply</font>
        |      end;
        |  iq_info_internal(_, _) -&gt;
<font color=red>     0..|      not_iq.</font>
        |  
        |  -spec iq_type_to_binary(set|get|result|error) -&gt; invalid | binary().
<font color=red>     0..|  iq_type_to_binary(set) -&gt; &lt;&lt;"set"&gt;&gt;;</font>
<font color=red>     0..|  iq_type_to_binary(get) -&gt; &lt;&lt;"get"&gt;&gt;;</font>
<font color=red>     0..|  iq_type_to_binary(result) -&gt; &lt;&lt;"result"&gt;&gt;;</font>
<font color=red>     0..|  iq_type_to_binary(error) -&gt; &lt;&lt;"error"&gt;&gt;;</font>
<font color=red>     0..|  iq_type_to_binary(_) -&gt; invalid.</font>
        |  
        |  
        |  -spec iq_to_xml(ejabberd:iq()) -&gt; xmlel().
        |  iq_to_xml(#iq{id = ID, type = Type, sub_el = SubEl}) -&gt;
<font color=red>     0..|      if</font>
        |          ID /= "" -&gt;
<font color=red>     0..|              #xmlel{name = &lt;&lt;"iq"&gt;&gt;,</font>
        |                     attrs = [{&lt;&lt;"id"&gt;&gt;, ID}, {&lt;&lt;"type"&gt;&gt;, iq_type_to_binary(Type)}],
        |                     children = sub_el_to_els(SubEl)};
        |          true -&gt;
<font color=red>     0..|              #xmlel{name = &lt;&lt;"iq"&gt;&gt;,</font>
        |                     attrs = [{&lt;&lt;"type"&gt;&gt;, iq_type_to_binary(Type)}],
        |                     children = sub_el_to_els(SubEl)}
        |      end.
        |  
        |  
        |  %% @doc Convert `#iq.sub_el' back to `#xmlel.children'.
        |  %% @end
        |  -spec sub_el_to_els([xmlel()] | xmlel()) -&gt; [xmlel()].
        |  %% for requests.
<font color=red>     0..|  sub_el_to_els(#xmlel{}=E) -&gt; [E];</font>
        |  %% for replies.
<font color=red>     0..|  sub_el_to_els(Es) when is_list(Es) -&gt; Es.</font>
        |  
        |  
        |  -spec parse_xdata_submit(xmlel()) -&gt; 'invalid' | [{binary(), [binary()]}].
        |  parse_xdata_submit(El) -&gt;
<font color=red>     0..|      #xmlel{attrs = Attrs, children = Els} = El,</font>
<font color=red>     0..|      case xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs) of</font>
        |          &lt;&lt;"submit"&gt;&gt; -&gt;
<font color=red>     0..|              lists:reverse(parse_xdata_fields(Els, []));</font>
        |          _ -&gt;
<font color=red>     0..|              invalid</font>
        |      end.
        |  
        |  
        |  -spec parse_xdata_fields([xmlcdata() | xmlel()], [{binary(), [binary()]}]) -&gt;
        |      [{binary(), [binary()]}].
        |  parse_xdata_fields([], Res) -&gt;
<font color=red>     0..|      Res;</font>
        |  parse_xdata_fields([#xmlel{name = Name, attrs = Attrs,
        |                             children = SubEls} | Els], Res) -&gt;
<font color=red>     0..|      case Name of</font>
        |          &lt;&lt;"field"&gt;&gt; -&gt;
<font color=red>     0..|              case xml:get_attr_s(&lt;&lt;"var"&gt;&gt;, Attrs) of</font>
        |                  &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|                      parse_xdata_fields(Els, Res);</font>
        |                  Var -&gt;
<font color=red>     0..|                      Field =</font>
        |                          {Var, lists:reverse(parse_xdata_values(SubEls, []))},
<font color=red>     0..|                      parse_xdata_fields(Els, [Field | Res])</font>
        |              end;
        |          _ -&gt;
<font color=red>     0..|              parse_xdata_fields(Els, Res)</font>
        |      end;
        |  parse_xdata_fields([_ | Els], Res) -&gt;
<font color=red>     0..|      parse_xdata_fields(Els, Res).</font>
        |  
        |  
        |  -spec parse_xdata_values([xmlcdata() | xmlel()], [binary()]) -&gt; [binary()].
        |  parse_xdata_values([], Res) -&gt;
<font color=red>     0..|      Res;</font>
        |  parse_xdata_values([#xmlel{name = Name,
        |                             children = SubEls} | Els], Res) -&gt;
<font color=red>     0..|      case Name of</font>
        |          &lt;&lt;"value"&gt;&gt; -&gt;
<font color=red>     0..|              Val = xml:get_cdata(SubEls),</font>
<font color=red>     0..|              parse_xdata_values(Els, [Val | Res]);</font>
        |          _ -&gt;
<font color=red>     0..|              parse_xdata_values(Els, Res)</font>
        |      end;
        |  parse_xdata_values([_ | Els], Res) -&gt;
<font color=red>     0..|      parse_xdata_values(Els, Res).</font>
        |  
        |  
        |  -spec rsm_decode(xmlel() | iq()) -&gt; 'none' | #rsm_in{}.
        |  rsm_decode(#iq{sub_el=SubEl})-&gt;
<font color=red>     0..|      rsm_decode(SubEl);</font>
        |  rsm_decode(#xmlel{}=SubEl) -&gt;
<font color=red>     0..|      case xml:get_subtag(SubEl,&lt;&lt;"set"&gt;&gt;) of</font>
        |          false -&gt;
<font color=red>     0..|              none;</font>
        |          #xmlel{name = &lt;&lt;"set"&gt;&gt;, children = SubEls} -&gt;
<font color=red>     0..|              lists:foldl(fun rsm_parse_element/2, #rsm_in{}, SubEls)</font>
        |      end.
        |  
        |  
        |  -spec rsm_parse_element(xmlel(), rsm_in()) -&gt; rsm_in().
        |  rsm_parse_element(#xmlel{name = &lt;&lt;"max"&gt;&gt;, attrs = []}=Elem, RsmIn) -&gt;
<font color=red>     0..|      CountStr = xml:get_tag_cdata(Elem),</font>
<font color=red>     0..|      {Count, _} = string:to_integer(binary_to_list(CountStr)),</font>
<font color=red>     0..|      RsmIn#rsm_in{max=Count};</font>
        |  rsm_parse_element(#xmlel{name = &lt;&lt;"before"&gt;&gt;,
        |                           attrs = []}=Elem, RsmIn) -&gt;
<font color=red>     0..|      UID = xml:get_tag_cdata(Elem),</font>
<font color=red>     0..|      RsmIn#rsm_in{direction=before, id=UID};</font>
        |  rsm_parse_element(#xmlel{name = &lt;&lt;"after"&gt;&gt;, attrs = []}=Elem, RsmIn) -&gt;
<font color=red>     0..|      UID = xml:get_tag_cdata(Elem),</font>
<font color=red>     0..|      RsmIn#rsm_in{direction=aft, id=UID};</font>
        |  rsm_parse_element(#xmlel{name = &lt;&lt;"index"&gt;&gt;, attrs = []}=Elem, RsmIn) -&gt;
<font color=red>     0..|      IndexStr = xml:get_tag_cdata(Elem),</font>
<font color=red>     0..|      {Index, _} = string:to_integer(binary_to_list(IndexStr)),</font>
<font color=red>     0..|      RsmIn#rsm_in{index=Index};</font>
        |  rsm_parse_element(_, RsmIn)-&gt;
<font color=red>     0..|      RsmIn.</font>
        |  
        |  
        |  -spec rsm_encode('none' | rsm_out()) -&gt; [xmlel()].
        |  rsm_encode(none)-&gt;
<font color=red>     0..|      [];</font>
        |  rsm_encode(RsmOut)-&gt;
<font color=red>     0..|      [#xmlel{name = &lt;&lt;"set"&gt;&gt;, attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_RSM}],</font>
        |              children = lists:reverse(rsm_encode_out(RsmOut))}].
        |  
        |  
        |  -spec rsm_encode_out(rsm_out()) -&gt; [xmlel()].
        |  rsm_encode_out(#rsm_out{count=Count, index=Index, first=First, last=Last})-&gt;
<font color=red>     0..|      El = rsm_encode_first(First, Index, []),</font>
<font color=red>     0..|      El2 = rsm_encode_last(Last,El),</font>
<font color=red>     0..|      rsm_encode_count(Count, El2).</font>
        |  
        |  
        |  -spec rsm_encode_first(First :: undefined | binary(),
        |                         Index :: 'undefined' | integer(),
        |                         Arr::[xmlel()]) -&gt; [xmlel()].
        |  rsm_encode_first(undefined, undefined, Arr) -&gt;
<font color=red>     0..|      Arr;</font>
        |  rsm_encode_first(First, undefined, Arr) -&gt;
<font color=red>     0..|      [#xmlel{name = &lt;&lt;"first"&gt;&gt;, children = [#xmlcdata{content = First}]}|Arr];</font>
        |  rsm_encode_first(First, Index, Arr) -&gt;
<font color=red>     0..|      [#xmlel{name = &lt;&lt;"first"&gt;&gt;, attrs = [{&lt;&lt;"index"&gt;&gt;, i2b(Index)}],</font>
        |              children = [#xmlcdata{content = First}]}|Arr].
        |  
        |  
        |  -spec rsm_encode_last(Last :: 'undefined', Arr :: [xmlel()]) -&gt; [xmlel()].
<font color=red>     0..|  rsm_encode_last(undefined, Arr) -&gt; Arr;</font>
        |  rsm_encode_last(Last, Arr) -&gt;
<font color=red>     0..|      [#xmlel{name = &lt;&lt;"last"&gt;&gt;, children = [#xmlcdata{content = Last}]}|Arr].</font>
        |  
        |  
        |  -spec rsm_encode_count(Count :: 'undefined' | pos_integer(),
        |                         Arr :: [xmlel()]) -&gt; [xmlel()].
<font color=red>     0..|  rsm_encode_count(undefined, Arr)-&gt; Arr;</font>
        |  rsm_encode_count(Count, Arr)-&gt;
<font color=red>     0..|      [#xmlel{name = &lt;&lt;"count"&gt;&gt;, children = [#xmlcdata{content = i2b(Count)}]} | Arr].</font>
        |  
        |  -spec i2b(integer()) -&gt; binary().
<font color=red>     0..|  i2b(I) when is_integer(I) -&gt; list_to_binary(integer_to_list(I)).</font>
        |  
        |  -type tzoffset() :: {TZh :: integer(), TZm :: integer()}.
        |  -type tz() :: 'utc' | {Sign :: string() | binary(), tzoffset()} | tzoffset().
        |  -type datetime_micro() :: {calendar:date(), {calendar:hour(), calendar:minute(), calendar:second(),
        |                                               Micro :: non_neg_integer()}}.
        |  %% @doc Timezone = utc | {Sign::string(), {Hours, Minutes}} | {Hours, Minutes}
        |  %% Hours = integer()
        |  %% Minutes = integer()
        |  -spec timestamp_to_iso(calendar:datetime() | datetime_micro(), tz()) -&gt; {string(), io_lib:chars()}.
        |  timestamp_to_iso({{Year, Month, Day}, {Hour, Minute, Second, Micro}}, Timezone) -&gt;
<font color=red>     0..|      Timestamp_string =</font>
        |          lists:flatten(
        |            io_lib:format("~4..0w-~2..0w-~2..0wT~2..0w:~2..0w:~2..0w.~6..0w",
        |                          [Year, Month, Day, Hour, Minute, Second, Micro])),
<font color=red>     0..|      Timezone_string =</font>
        |          case Timezone of
<font color=red>     0..|              utc -&gt; "Z";</font>
        |              {Sign, {TZh, TZm}} -&gt;
<font color=red>     0..|                  io_lib:format("~s~2..0w:~2..0w", [Sign, TZh, TZm]);</font>
        |              {TZh, TZm} -&gt;
<font color=red>     0..|                  Sign = case TZh &gt;= 0 of</font>
<font color=red>     0..|                             true -&gt; "+";</font>
<font color=red>     0..|                             false -&gt; "-"</font>
        |                         end,
<font color=red>     0..|                  io_lib:format("~s~2..0w:~2..0w", [Sign, abs(TZh),TZm])</font>
        |          end,
<font color=red>     0..|      {Timestamp_string, Timezone_string};</font>
        |  timestamp_to_iso({{Year, Month, Day}, {Hour, Minute, Second}}, Timezone) -&gt;
<font color=red>     0..|      Timestamp_string =</font>
        |          lists:flatten(
        |            io_lib:format("~4..0w-~2..0w-~2..0wT~2..0w:~2..0w:~2..0w",
        |                          [Year, Month, Day, Hour, Minute, Second])),
<font color=red>     0..|      Timezone_string =</font>
        |          case Timezone of
<font color=red>     0..|              utc -&gt; "Z";</font>
        |              {Sign, {TZh, TZm}} -&gt;
<font color=red>     0..|                  io_lib:format("~s~2..0w:~2..0w", [Sign, TZh, TZm]);</font>
        |              {TZh, TZm} -&gt;
<font color=red>     0..|                  Sign = case TZh &gt;= 0 of</font>
<font color=red>     0..|                             true -&gt; "+";</font>
<font color=red>     0..|                             false -&gt; "-"</font>
        |                         end,
<font color=red>     0..|                  io_lib:format("~s~2..0w:~2..0w", [Sign, abs(TZh),TZm])</font>
        |          end,
<font color=red>     0..|      {Timestamp_string, Timezone_string}.</font>
        |  
        |  -spec timestamp_to_xml(DateTime :: calendar:datetime() | datetime_micro(),
        |                         Timezone :: tz(),
        |                         FromJID :: ejabberd:simple_jid() | ejabberd:jid(),
        |                         Desc :: iodata()) -&gt; xmlel().
        |  timestamp_to_xml(DateTime, Timezone, FromJID, Desc) -&gt;
<font color=red>     0..|      {T_string, Tz_string} = timestamp_to_iso(DateTime, Timezone),</font>
<font color=red>     0..|      Text = [#xmlcdata{content = Desc}],</font>
<font color=red>     0..|      From = jid:to_binary(FromJID),</font>
<font color=red>     0..|      #xmlel{name = &lt;&lt;"delay"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_DELAY},
        |                      {&lt;&lt;"from"&gt;&gt;, From},
        |                      {&lt;&lt;"stamp"&gt;&gt;, list_to_binary(T_string ++ Tz_string)}],
        |             children = Text}.
        |  
        |  
        |  -spec timestamp_to_mam_xml(DateTime :: calendar:datetime(),
        |                             Timezone :: tz(),
        |                             QueryId :: any(),
        |                             MessageUID :: binary()) -&gt; xmlel().
        |  timestamp_to_mam_xml(DateTime, Timezone, QueryID, MessageUID) -&gt;
<font color=red>     0..|      {T_string, Tz_string} = timestamp_to_iso(DateTime, Timezone),</font>
<font color=red>     0..|      #xmlel{name = &lt;&lt;"delay"&gt;&gt;,</font>
        |             attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_DELAY},
        |                      {&lt;&lt;"stamp"&gt;&gt;, list_to_binary(T_string ++ Tz_string)},
        |                      {&lt;&lt;"id"&gt;&gt;, MessageUID}] ++
<font color=red>     0..|                     [{&lt;&lt;"queryid"&gt;&gt;, QueryID} || QueryID =/= undefined, QueryID =/= &lt;&lt;&gt;&gt;]}.</font>
        |  
        |  -spec now_to_utc_string(erlang:timestamp()) -&gt; string().
        |  now_to_utc_string({MegaSecs, Secs, MicroSecs}) -&gt;
<font color=red>     0..|      {{Year, Month, Day}, {Hour, Minute, Second}} =</font>
        |          calendar:now_to_universal_time({MegaSecs, Secs, MicroSecs}),
<font color=red>     0..|      lists:flatten(</font>
        |        io_lib:format("~4..0w-~2..0w-~2..0wT~2..0w:~2..0w:~2..0w.~6..0wZ",
        |                      [Year, Month, Day, Hour, Minute, Second, MicroSecs])).
        |  now_to_utc_binary(Timestamp) -&gt;
<font color=red>     0..|      list_to_binary(now_to_utc_string(Timestamp)).</font>
        |  
        |  
        |  %% @doc yyyy-mm-ddThh:mm:ss[.sss]{Z|{+|-}hh:mm} -&gt; {MegaSecs, Secs, MicroSecs}
        |  -spec datetime_binary_to_timestamp(binary()) -&gt; undefined | erlang:timestamp().
        |  datetime_binary_to_timestamp(TimeBin) -&gt;
        |      %% Operations on short strings are actually faster than on binaries,
        |      %% even if we include time for binary_to_list/1
<font color=red>     0..|      case catch parse_datetime(binary_to_list(TimeBin)) of</font>
        |          {'EXIT', _Err} -&gt;
<font color=red>     0..|              undefined;</font>
        |          TimeStamp -&gt;
<font color=red>     0..|              TimeStamp</font>
        |      end.
        |  
        |  -spec parse_datetime(string()) -&gt; erlang:timestamp().
        |  parse_datetime(TimeStr) -&gt;
<font color=red>     0..|      [Date, Time] = string:tokens(TimeStr, "T"),</font>
<font color=red>     0..|      D = parse_date(Date),</font>
<font color=red>     0..|      {T, MS, TZH, TZM} = parse_time(Time),</font>
<font color=red>     0..|      S = calendar:datetime_to_gregorian_seconds({D, T}),</font>
<font color=red>     0..|      S1 = calendar:datetime_to_gregorian_seconds({{1970, 1, 1}, {0, 0, 0}}),</font>
<font color=red>     0..|      Seconds = (S - S1) - TZH * 60 * 60 - TZM * 60,</font>
<font color=red>     0..|      {Seconds div 1000000, Seconds rem 1000000, MS}.</font>
        |  
        |  %% @doc yyyy-mm-dd
        |  -spec parse_date(nonempty_string()) -&gt; 'false' | calendar:date().
        |  parse_date(Date) -&gt;
<font color=red>     0..|      [Y, M, D] = string:tokens(Date, "-"),</font>
<font color=red>     0..|      Date1 = {list_to_integer(Y), list_to_integer(M), list_to_integer(D)},</font>
<font color=red>     0..|      case calendar:valid_date(Date1) of</font>
        |          true -&gt;
<font color=red>     0..|              Date1;</font>
        |          _ -&gt;
<font color=red>     0..|              false</font>
        |      end.
        |  
        |  
        |  %% @doc hh:mm:ss[.sss]TZD
        |  -spec parse_time(nonempty_string()) -&gt; 'false' | maybe_datetime().
        |  parse_time(Time) -&gt;
<font color=red>     0..|      case string:str(Time, "Z") of</font>
        |          0 -&gt;
<font color=red>     0..|              parse_time_with_timezone(Time);</font>
        |          _ -&gt;
<font color=red>     0..|              [T | _] = string:tokens(Time, "Z"),</font>
<font color=red>     0..|              {TT, MS} = parse_time1(T),</font>
<font color=red>     0..|              {TT, MS, 0, 0}</font>
        |      end.
        |  
        |  
        |  -spec parse_time_with_timezone(nonempty_string()) -&gt; 'false' | maybe_datetime().
        |  parse_time_with_timezone(Time) -&gt;
<font color=red>     0..|      case string:str(Time, "+") of</font>
        |          0 -&gt;
<font color=red>     0..|              case string:str(Time, "-") of</font>
        |                  0 -&gt;
<font color=red>     0..|                      false;</font>
        |                  _ -&gt;
<font color=red>     0..|                      parse_time_with_timezone(Time, "-")</font>
        |              end;
        |          _ -&gt;
<font color=red>     0..|              parse_time_with_timezone(Time, "+")</font>
        |      end.
        |  
        |  
        |  -spec parse_time_with_timezone(nonempty_string(),
        |                                 Delim :: [43 | 45,...]) -&gt; maybe_datetime().
        |  parse_time_with_timezone(Time, Delim) -&gt;
<font color=red>     0..|      [T, TZ] = string:tokens(Time, Delim),</font>
<font color=red>     0..|      {TZH, TZM} = parse_timezone(TZ),</font>
<font color=red>     0..|      {TT, MS} = parse_time1(T),</font>
<font color=red>     0..|      case Delim of</font>
        |          "-" -&gt;
<font color=red>     0..|              {TT, MS, -TZH, -TZM};</font>
        |          "+" -&gt;
<font color=red>     0..|              {TT, MS, TZH, TZM}</font>
        |      end.
        |  
        |  
        |  -spec parse_timezone(nonempty_string()) -&gt; maybe_tz().
        |  parse_timezone(TZ) -&gt;
<font color=red>     0..|      [H, M] = string:tokens(TZ, ":"),</font>
<font color=red>     0..|      {[H1, M1], true} = check_list([{H, 12}, {M, 60}]),</font>
<font color=red>     0..|      {H1, M1}.</font>
        |  
        |  
        |  -spec parse_time1(nonempty_string()) -&gt; {maybe_time(), integer()}.
        |  parse_time1(Time) -&gt;
<font color=red>     0..|      [HMS | T] =  string:tokens(Time, "."),</font>
<font color=red>     0..|      MS = case T of</font>
        |               [] -&gt;
<font color=red>     0..|                   0;</font>
        |               [Val] -&gt;
<font color=red>     0..|                   list_to_integer(string:left(Val, 6, $0))</font>
        |           end,
<font color=red>     0..|      [H, M, S] = string:tokens(HMS, ":"),</font>
<font color=red>     0..|      {[H1, M1, S1], true} = check_list([{H, 24}, {M, 60}, {S, 60}]),</font>
<font color=red>     0..|      {{H1, M1, S1}, MS}.</font>
        |  
        |  
        |  -spec check_list([{nonempty_string(), 12 | 24 | 60},...]) -&gt;
        |                                    {['false' | non_neg_integer(),...],_}.
        |  check_list(List) -&gt;
<font color=red>     0..|      lists:mapfoldl(</font>
        |        fun({L, N}, B)-&gt;
<font color=red>     0..|                V = list_to_integer(L),</font>
<font color=red>     0..|                if</font>
        |                    (V &gt;= 0) and (V =&lt; N) -&gt;
<font color=red>     0..|                        {V, B};</font>
        |                    true -&gt;
<font color=red>     0..|                        {false, false}</font>
        |                end
        |        end, true, List).
        |  
        |  
        |  %%
        |  %% Base64 stuff (based on httpd_util.erl)
        |  %%
        |  
        |  %% TODO: optimize binary way
        |  -spec decode_base64(binary() | string()) -&gt; binary() | string().
        |  decode_base64(S) when erlang:is_binary(S)-&gt;
<font color=red>     0..|      list_to_binary(decode_base64(binary_to_list(S)));</font>
        |  decode_base64(S) -&gt;
<font color=red>     0..|      decode1_base64([C || C &lt;- S,</font>
<font color=red>     0..|                           C /= $\s,</font>
<font color=red>     0..|                           C /= $\t,</font>
<font color=red>     0..|                           C /= $\n,</font>
<font color=red>     0..|                           C /= $\r]).</font>
        |  
        |  
        |  -spec decode1_base64(string()) -&gt; string().
        |  decode1_base64([]) -&gt;
<font color=red>     0..|      [];</font>
        |  decode1_base64([Sextet1,Sextet2,$=,$=|Rest]) -&gt;
<font color=red>     0..|      Bits2x6=</font>
        |          (d(Sextet1) bsl 18) bor
        |          (d(Sextet2) bsl 12),
<font color=red>     0..|      Octet1=Bits2x6 bsr 16,</font>
<font color=red>     0..|      [Octet1|decode1_base64(Rest)];</font>
        |  decode1_base64([Sextet1,Sextet2,Sextet3,$=|Rest]) -&gt;
<font color=red>     0..|      Bits3x6=</font>
        |          (d(Sextet1) bsl 18) bor
        |          (d(Sextet2) bsl 12) bor
        |          (d(Sextet3) bsl 6),
<font color=red>     0..|      Octet1=Bits3x6 bsr 16,</font>
<font color=red>     0..|      Octet2=(Bits3x6 bsr 8) band 16#ff,</font>
<font color=red>     0..|      [Octet1,Octet2|decode1_base64(Rest)];</font>
        |  decode1_base64([Sextet1,Sextet2,Sextet3,Sextet4|Rest]) -&gt;
<font color=red>     0..|      Bits4x6=</font>
        |          (d(Sextet1) bsl 18) bor
        |          (d(Sextet2) bsl 12) bor
        |          (d(Sextet3) bsl 6) bor
        |          d(Sextet4),
<font color=red>     0..|      Octet1=Bits4x6 bsr 16,</font>
<font color=red>     0..|      Octet2=(Bits4x6 bsr 8) band 16#ff,</font>
<font color=red>     0..|      Octet3=Bits4x6 band 16#ff,</font>
<font color=red>     0..|      [Octet1,Octet2,Octet3|decode1_base64(Rest)];</font>
        |  decode1_base64(_CatchAll) -&gt;
<font color=red>     0..|      "".</font>
        |  
        |  
        |  -spec d(char()) -&gt; char().
        |  d(X) when X &gt;= $A, X =&lt;$Z -&gt;
<font color=red>     0..|      X-65;</font>
        |  d(X) when X &gt;= $a, X =&lt;$z -&gt;
<font color=red>     0..|      X-71;</font>
        |  d(X) when X &gt;= $0, X =&lt;$9 -&gt;
<font color=red>     0..|      X+4;</font>
<font color=red>     0..|  d($+) -&gt; 62;</font>
<font color=red>     0..|  d($/) -&gt; 63;</font>
<font color=red>     0..|  d(_) -&gt; 63.</font>
        |  
        |  
        |  %% TODO: optimize binary way
        |  -spec encode_base64(binary() | string()) -&gt; binary() | string().
        |  encode_base64(B) when is_binary(B) -&gt;
<font color=red>     0..|      list_to_binary(encode_base64(binary_to_list(B)));</font>
        |  encode_base64([]) -&gt;
<font color=red>     0..|      [];</font>
        |  encode_base64([A]) -&gt;
<font color=red>     0..|      [e(A bsr 2), e((A band 3) bsl 4), $=, $=];</font>
        |  encode_base64([A,B]) -&gt;
<font color=red>     0..|      [e(A bsr 2), e(((A band 3) bsl 4) bor (B bsr 4)), e((B band 15) bsl 2), $=];</font>
        |  encode_base64([A,B,C|Ls]) -&gt;
<font color=red>     0..|      encode_base64_do(A,B,C, Ls).</font>
        |  encode_base64_do(A,B,C, Rest) -&gt;
<font color=red>     0..|      BB = (A bsl 16) bor (B bsl 8) bor C,</font>
<font color=red>     0..|      [e(BB bsr 18), e((BB bsr 12) band 63),</font>
        |       e((BB bsr 6) band 63), e(BB band 63)|encode_base64(Rest)].
        |  
        |  
        |  -spec e(byte()) -&gt; char() | none().
<font color=red>     0..|  e(X) when X &gt;= 0, X &lt; 26 -&gt; X+65;</font>
<font color=red>     0..|  e(X) when X&gt;25, X&lt;52 -&gt;     X+71;</font>
<font color=red>     0..|  e(X) when X&gt;51, X&lt;62 -&gt;     X-4;</font>
<font color=red>     0..|  e(62) -&gt;                    $+;</font>
<font color=red>     0..|  e(63) -&gt;                    $/;</font>
<font color=red>     0..|  e(X) -&gt;                     exit({bad_encode_base64_token, X}).</font>
        |  
        |  
        |  %% @doc Convert Erlang inet IP to list
        |  -spec ip_to_list(inet:ip4_address() | {inet:ip_address(), inet:port_number()}
        |                  ) -&gt; string().
        |  ip_to_list({IP, _Port}) -&gt;
<font color=red>     0..|      ip_to_list(IP);</font>
        |  ip_to_list({_,_,_,_,_,_,_,_} = Ipv6Address) -&gt;
<font color=red>     0..|      inet_parse:ntoa(Ipv6Address);</font>
        |  %% This function clause could use inet_parse too:
        |  ip_to_list({A,B,C,D}) -&gt;
<font color=red>     0..|      lists:flatten(io_lib:format("~w.~w.~w.~w",[A,B,C,D]));</font>
        |  ip_to_list(IP) -&gt;
<font color=red>     0..|      lists:flatten(io_lib:format("~w", [IP])).</font>
        |  
        |  %% TODO: remove&lt;&lt;"code" attribute (currently it used for backward-compatibility)
        |  -spec stanza_error( Code :: binary()
        |                    , Type :: binary()
        |                    , Condition :: binary() | undefined) -&gt; #xmlel{}.
        |  stanza_error(Code, Type, Condition) -&gt;
<font color=red>     0..|    #xmlel{ name = &lt;&lt;"error"&gt;&gt;</font>
        |          , attrs = [{&lt;&lt;"code"&gt;&gt;, Code}, {&lt;&lt;"type"&gt;&gt;, Type}]
        |          , children = [ #xmlel{ name = Condition
        |                               , attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STANZAS}]
        |                               }]
        |          }.
        |  
        |  -spec stanza_errort( Code :: binary()
        |                     , Type :: binary()
        |                     , Condition :: binary()
        |                     , Lang :: ejabberd:lang()
        |                     , Text :: binary()) -&gt; #xmlel{}.
        |  stanza_errort(Code, Type, Condition, Lang, Text) -&gt;
<font color=red>     0..|    Txt = translate:translate(Lang, Text),</font>
<font color=red>     0..|    #xmlel{ name = &lt;&lt;"error"&gt;&gt;</font>
        |          , attrs = [{&lt;&lt;"code"&gt;&gt;, Code}, {&lt;&lt;"type"&gt;&gt;, Type}]
        |          , children = [ #xmlel{ name = Condition
        |                               , attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STANZAS}]
        |                               }
        |                       , #xmlel{ name = &lt;&lt;"text"&gt;&gt;
        |                               , attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STANZAS}]
        |                               , children = [#xmlcdata{ content = Txt }]
        |                               }]
        |          }.
        |  
        |  -spec stream_error(Condition :: binary()) -&gt; #xmlel{}.
        |  stream_error(Condition) -&gt;
<font color=red>     0..|    #xmlel{ name = &lt;&lt;"stream:error"&gt;&gt;</font>
        |          , children = [ #xmlel{ name = Condition
        |                               , attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STREAMS}]
        |                               }
        |                       ]
        |          }.
        |  
        |  -spec stream_errort( Condition :: binary()
        |                     , Lang :: ejabberd:lang()
        |                     , Text :: binary()) -&gt; #xmlel{}.
        |  stream_errort(Condition, Lang, Text) -&gt;
<font color=red>     0..|    Txt = translate:translate(Lang, Text),</font>
<font color=red>     0..|    #xmlel{ name = &lt;&lt;"stream:error"&gt;&gt;</font>
        |          , children = [ #xmlel{ name = Condition
        |                               , attrs = [{&lt;&lt;"xmlns"&gt;&gt;, ?NS_STREAMS}] }
        |                       , #xmlel{ name = &lt;&lt;"text"&gt;&gt;
        |                               , attrs = [ {&lt;&lt;"xml:lang"&gt;&gt;, Lang}
        |                                         , {&lt;&lt;"xmlns"&gt;&gt;, ?NS_STREAMS}]
        |                               , children = [ #xmlcdata{ content = Txt} ]}
        |                       ]
        |          }.
        |  
        |  remove_delay_tags(#xmlel{children = Els} = Packet) -&gt;
<font color=red>     0..|      NEl = lists:foldl(</font>
        |               fun(#xmlel{name= &lt;&lt;"delay"&gt;&gt;, attrs = Attrs} = R, El)-&gt;
<font color=red>     0..|  			      case xml:get_attr_s(&lt;&lt;"xmlns"&gt;&gt;, Attrs) of</font>
        |                                    ?NS_DELAY -&gt;
<font color=red>     0..|                                        El;</font>
        |                                    _ -&gt;
<font color=red>     0..|                                      El ++ [R]</font>
        |                                end;
        |                  (#xmlel{name= &lt;&lt;"x"&gt;&gt; , attrs = Attrs } = R, El) -&gt;
<font color=red>     0..|                                case xml:get_attr_s(&lt;&lt;"xmlns"&gt;&gt;, Attrs) of</font>
        |                                    ?NS_DELAY91 -&gt;
<font color=red>     0..|                                        El;</font>
        |                                    _ -&gt;
<font color=red>     0..|                                      El ++ [R]</font>
        |                                end;
        |                  (R, El) -&gt;
<font color=red>     0..|                                El ++ [R]</font>
        |                  end, [],Els),
<font color=red>     0..|      Packet#xmlel{children=NEl}.</font>
</pre>
</body>
</html>
