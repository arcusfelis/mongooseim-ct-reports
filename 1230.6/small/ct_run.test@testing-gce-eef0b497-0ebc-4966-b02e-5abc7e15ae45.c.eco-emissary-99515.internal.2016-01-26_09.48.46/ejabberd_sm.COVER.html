<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/travis/build/esl/MongooseIM/apps/ejabberd/logs/ct_run.test@testing-gce-eef0b497-0ebc-4966-b02e-5abc7e15ae45.c.eco-emissary-99515.internal.2016-01-26_09.48.46/ejabberd_sm.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/esl/MongooseIM/apps/ejabberd/ebin/../src/ejabberd_sm.erl by COVER 2016-01-26 at 09:49:31

****************************************************************************

        |  %%%----------------------------------------------------------------------
        |  %%% File    : ejabberd_sm.erl
        |  %%% Author  : Alexey Shchepin &lt;alexey@process-one.net&gt;
        |  %%% Purpose : Session manager
        |  %%% Created : 24 Nov 2002 by Alexey Shchepin &lt;alexey@process-one.net&gt;
        |  %%%
        |  %%%
        |  %%% ejabberd, Copyright (C) 2002-2011   ProcessOne
        |  %%%
        |  %%% This program is free software; you can redistribute it and/or
        |  %%% modify it under the terms of the GNU General Public License as
        |  %%% published by the Free Software Foundation; either version 2 of the
        |  %%% License, or (at your option) any later version.
        |  %%%
        |  %%% This program is distributed in the hope that it will be useful,
        |  %%% but WITHOUT ANY WARRANTY; without even the implied warranty of
        |  %%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        |  %%% General Public License for more details.
        |  %%%
        |  %%% You should have received a copy of the GNU General Public License
        |  %%% along with this program; if not, write to the Free Software
        |  %%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
        |  %%% 02111-1307 USA
        |  %%%
        |  %%%----------------------------------------------------------------------
        |  -module(ejabberd_sm).
        |  -author('alexey@process-one.net').
        |  
        |  -behaviour(gen_server).
        |  -behaviour(xmpp_router).
        |  
        |  %% API
        |  -export([start_link/0,
        |           route/3,
        |           open_session/5, open_session/6,
        |           close_session/5,
        |           check_in_subscription/6,
        |           bounce_offline_message/3,
        |           disconnect_removed_user/2,
        |           get_user_resources/2,
        |           set_presence/7,
        |           unset_presence/6,
        |           close_session_unset_presence/6,
        |           get_unique_sessions_number/0,
        |           get_total_sessions_number/0,
        |           get_node_sessions_number/0,
        |           get_vh_session_number/1,
        |           get_vh_session_list/1,
        |           get_full_session_list/0,
        |           register_iq_handler/4,
        |           register_iq_handler/5,
        |           unregister_iq_handler/2,
        |           force_update_presence/1,
        |           user_resources/2,
        |           get_session_pid/3,
        |           get_session/3,
        |           get_session_ip/3,
        |           get_user_present_resources/2
        |          ]).
        |  
        |  %% Hook handlers
        |  -export([node_cleanup/1]).
        |  
        |  %% gen_server callbacks
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2,
        |           terminate/2, code_change/3]).
        |  
        |  %% xmpp_router callback
        |  -export([do_route/3]).
        |  
        |  -include("ejabberd.hrl").
        |  -include("jlib.hrl").
        |  -include("ejabberd_commands.hrl").
        |  -include("mod_privacy.hrl").
        |  
        |  -record(state, {}).
        |  -type state() :: #state{}.
        |  
        |  -type sid() :: tuple().
        |  -type priority() :: integer() | undefined.
        |  
        |  -type session() :: #session{
        |                        sid      :: sid(),
        |                        usr      :: ejabberd:simple_jid(),
        |                        us       :: ejabberd:simple_bare_jid(),
        |                        priority :: priority(),
        |                        info     :: list()
        |                       }.
        |  
        |  %% Session representation as 4-tuple.
        |  -type ses_tuple() :: {USR :: ejabberd:simple_jid(),
        |                        Sid :: ejabberd_sm:sid(),
        |                        Prio :: priority(),
        |                        Info :: list()}.
        |  -type backend() :: ejabberd_sm_mnesia | ejabberd_sm_redis.
        |  -type close_reason() :: resumed | normal | replaced.
        |  
        |  -export_type([session/0,
        |                sid/0,
        |                ses_tuple/0,
        |                backend/0,
        |                close_reason/0
        |              ]).
        |  
        |  %% default value for the maximum number of user connections
        |  -define(MAX_USER_SESSIONS, 100).
        |  -define(SM_BACKEND, (ejabberd_sm_backend:backend())).
        |  -define(UNIQUE_COUNT_CACHE, [cache, unique_sessions_number]).
        |  
        |  %%====================================================================
        |  %% API
        |  %%====================================================================
        |  %%--------------------------------------------------------------------
        |  %% Function: start_link() -&gt; {ok,Pid} | ignore | {error,Error}
        |  %% Description: Starts the server
        |  %%--------------------------------------------------------------------
        |  -spec start_link() -&gt; 'ignore' | {'error',_} | {'ok',pid()}.
        |  start_link() -&gt;
<font color=red>     0..|      mongoose_metrics:ensure_metric(?UNIQUE_COUNT_CACHE, gauge),</font>
<font color=red>     0..|      gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).</font>
        |  
        |  
        |  -spec route(From, To, Packet) -&gt; ok when
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel() | ejabberd_c2s:broadcast().
        |  route(From, To, Packet) -&gt;
<font color=red>     0..|      xmpp_router:route(?MODULE, From, To, Packet).</font>
        |  
        |  -spec open_session(SID, User, Server, Resource, Info) -&gt; ok when
        |        SID :: 'undefined' | sid(),
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        Resource :: binary(),
        |        Info :: 'undefined' | [any()].
        |  open_session(SID, User, Server, Resource, Info) -&gt;
<font color=red>     0..|      open_session(SID, User, Server, Resource, undefined, Info).</font>
        |  
        |  -spec open_session(SID, User, Server, Resource, Priority, Info) -&gt; ok when
        |        SID :: 'undefined' | sid(),
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        Resource :: binary(),
        |        Priority :: integer() | undefined,
        |        Info :: 'undefined' | [any()].
        |  open_session(SID, User, Server, Resource, Priority, Info) -&gt;
<font color=red>     0..|      set_session(SID, User, Server, Resource, Priority, Info),</font>
<font color=red>     0..|      check_for_sessions_to_replace(User, Server, Resource),</font>
<font color=red>     0..|      JID = jid:make(User, Server, Resource),</font>
<font color=red>     0..|      ejabberd_hooks:run(sm_register_connection_hook, JID#jid.lserver,</font>
        |                         [SID, JID, Info]).
        |  
        |  -spec close_session(SID, User, Server, Resource, Reason) -&gt; ok when
        |      SID :: 'undefined' | sid(),
        |      User :: ejabberd:user(),
        |      Server :: ejabberd:server(),
        |      Resource :: ejabberd:resource(),
        |      Reason :: close_reason().
        |  close_session(SID, User, Server, Resource, Reason) -&gt;
<font color=red>     0..|      LUser = jid:nodeprep(User),</font>
<font color=red>     0..|      LServer = jid:nameprep(Server),</font>
<font color=red>     0..|      LResource = jid:resourceprep(Resource),</font>
<font color=red>     0..|      Info = case ?SM_BACKEND:get_sessions(LUser, LServer, LResource) of</font>
        |                 [Session] -&gt;
<font color=red>     0..|                     Session#session.info;</font>
        |                 _ -&gt;
<font color=red>     0..|                     []</font>
        |             end,
<font color=red>     0..|      ?SM_BACKEND:delete_session(SID, LUser, LServer, LResource),</font>
<font color=red>     0..|      JID = jid:make(User, Server, Resource),</font>
<font color=red>     0..|      ejabberd_hooks:run(sm_remove_connection_hook, JID#jid.lserver,</font>
        |                         [SID, JID, Info, Reason]).
        |  
        |  
        |  -spec check_in_subscription(Acc, User, Server, JID, Type, Reason) -&gt; any() | {stop, false} when
        |        Acc :: any(),
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        JID :: ejabberd:jid(),
        |        Type :: any(),
        |        Reason :: any().
        |  check_in_subscription(Acc, User, Server, _JID, _Type, _Reason) -&gt;
<font color=red>     0..|      case ejabberd_auth:is_user_exists(User, Server) of</font>
        |          true -&gt;
<font color=red>     0..|              Acc;</font>
        |          false -&gt;
<font color=red>     0..|              {stop, false}</font>
        |      end.
        |  
        |  
        |  -spec bounce_offline_message(From, To, Packet) -&gt; stop when
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel().
        |  bounce_offline_message(#jid{server = Server} = From, To, Packet) -&gt;
<font color=red>     0..|      ejabberd_hooks:run(xmpp_bounce_message,</font>
        |                         Server,
        |                         [Server, Packet]),
<font color=red>     0..|      Err = jlib:make_error_reply(Packet, ?ERR_SERVICE_UNAVAILABLE),</font>
<font color=red>     0..|      ejabberd_router:route(To, From, Err),</font>
<font color=red>     0..|      stop.</font>
        |  
        |  
        |  -spec disconnect_removed_user(User :: ejabberd:user(), Server :: ejabberd:server()) -&gt;
        |      'ok' | {'error','lager_not_running'}.
        |  disconnect_removed_user(User, Server) -&gt;
<font color=red>     0..|      ejabberd_sm:route(jid:make(&lt;&lt;&gt;&gt;, &lt;&lt;&gt;&gt;, &lt;&lt;&gt;&gt;),</font>
        |                        jid:make(User, Server, &lt;&lt;&gt;&gt;),
        |                        {broadcast, {exit, &lt;&lt;"User removed"&gt;&gt;}}).
        |  
        |  
        |  -spec get_user_resources(User :: ejabberd:user(), Server :: ejabberd:server()) -&gt; [binary()].
        |  get_user_resources(User, Server) -&gt;
<font color=red>     0..|      LUser = jid:nodeprep(User),</font>
<font color=red>     0..|      LServer = jid:nameprep(Server),</font>
<font color=red>     0..|      Ss = ?SM_BACKEND:get_sessions(LUser, LServer),</font>
<font color=red>     0..|      [element(3, S#session.usr) || S &lt;- clean_session_list(Ss)].</font>
        |  
        |  
        |  -spec get_session_ip(User, Server, Resource) -&gt; undefined | {inet:ip_address(), integer()} when
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        Resource :: ejabberd:resource().
        |  get_session_ip(User, Server, Resource) -&gt;
<font color=red>     0..|      LUser = jid:nodeprep(User),</font>
<font color=red>     0..|      LServer = jid:nameprep(Server),</font>
<font color=red>     0..|      LResource = jid:resourceprep(Resource),</font>
<font color=red>     0..|      case ?SM_BACKEND:get_sessions(LUser, LServer, LResource) of</font>
        |          [] -&gt;
<font color=red>     0..|              undefined;</font>
        |          Ss -&gt;
<font color=red>     0..|              Session = lists:max(Ss),</font>
<font color=red>     0..|              proplists:get_value(ip, Session#session.info)</font>
        |      end.
        |  
        |  
        |  -spec get_session(User, Server, Resource) -&gt; offline | ses_tuple() when
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        Resource :: ejabberd:resource().
        |  get_session(User, Server, Resource) -&gt;
<font color=red>     0..|      LUser = jid:nodeprep(User),</font>
<font color=red>     0..|      LServer = jid:nameprep(Server),</font>
<font color=red>     0..|      LResource = jid:resourceprep(Resource),</font>
<font color=red>     0..|      case ?SM_BACKEND:get_sessions(LUser, LServer, LResource) of</font>
        |          [] -&gt;
<font color=red>     0..|              offline;</font>
        |          Ss -&gt;
<font color=red>     0..|              Session = lists:max(Ss),</font>
<font color=red>     0..|              {Session#session.usr,</font>
        |               Session#session.sid,
        |               Session#session.priority,
        |               Session#session.info}
        |      end.
        |  
        |  
        |  -spec set_presence(SID, User, Server, Resource, Prio, Presence, Info) -&gt; ok when
        |        SID :: 'undefined' | sid(),
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        Resource :: ejabberd:resource(),
        |        Prio :: 'undefined' | integer(),
        |        Presence :: any(),
        |        Info :: 'undefined' | [any()].
        |  set_presence(SID, User, Server, Resource, Priority, Presence, Info) -&gt;
<font color=red>     0..|      set_session(SID, User, Server, Resource, Priority, Info),</font>
<font color=red>     0..|      ejabberd_hooks:run(set_presence_hook, jid:nameprep(Server),</font>
        |                         [User, Server, Resource, Presence]).
        |  
        |  
        |  -spec unset_presence(SID, User, Server, Resource, Status, Info) -&gt; ok when
        |        SID :: 'undefined' | sid(),
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        Resource :: ejabberd:resource(),
        |        Status :: any(),
        |        Info :: 'undefined' | [any()].
        |  unset_presence(SID, User, Server, Resource, Status, Info) -&gt;
<font color=red>     0..|      set_session(SID, User, Server, Resource, undefined, Info),</font>
<font color=red>     0..|      LServer = jid:nameprep(Server),</font>
<font color=red>     0..|      ejabberd_hooks:run(unset_presence_hook, LServer,</font>
        |                         [jid:nodeprep(User), LServer,
        |                          jid:resourceprep(Resource), Status]).
        |  
        |  
        |  -spec close_session_unset_presence(SID, User, Server, Resource, Status, Reason) -&gt; ok when
        |        SID :: 'undefined' | sid(),
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        Resource :: ejabberd:resource(),
        |        Status :: any(),
        |        Reason :: close_reason().
        |  close_session_unset_presence(SID, User, Server, Resource, Status, Reason) -&gt;
<font color=red>     0..|      close_session(SID, User, Server, Resource, Reason),</font>
<font color=red>     0..|      LServer = jid:nameprep(Server),</font>
<font color=red>     0..|      ejabberd_hooks:run(unset_presence_hook, LServer,</font>
        |                         [jid:nodeprep(User), LServer,
        |                          jid:resourceprep(Resource), Status]).
        |  
        |  
        |  -spec get_session_pid(User, Server, Resource) -&gt; none | pid() when
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        Resource :: ejabberd:resource().
        |  get_session_pid(User, Server, Resource) -&gt;
<font color=red>     0..|      LUser = jid:nodeprep(User),</font>
<font color=red>     0..|      LServer = jid:nameprep(Server),</font>
<font color=red>     0..|      LResource = jid:resourceprep(Resource),</font>
<font color=red>     0..|      case ?SM_BACKEND:get_sessions(LUser, LServer, LResource) of</font>
        |          [#session{sid = {_, Pid}}] -&gt;
<font color=red>     0..|              Pid;</font>
        |          _ -&gt;
<font color=red>     0..|              none</font>
        |      end.
        |  
        |  
        |  -spec get_unique_sessions_number() -&gt; integer().
        |  get_unique_sessions_number() -&gt;
<font color=red>     0..|      try</font>
<font color=red>     0..|          C = ?SM_BACKEND:unique_count(),</font>
<font color=red>     0..|          mongoose_metrics:update(?UNIQUE_COUNT_CACHE, C),</font>
<font color=red>     0..|          C</font>
        |      catch
        |          _:_ -&gt;
<font color=red>     0..|              get_cached_unique_count()</font>
        |      end.
        |  
        |  
        |  -spec get_total_sessions_number() -&gt; integer().
        |  get_total_sessions_number() -&gt;
<font color=red>     0..|      ?SM_BACKEND:total_count().</font>
        |  
        |  
        |  -spec get_vh_session_number(ejabberd:server()) -&gt; non_neg_integer().
        |  get_vh_session_number(Server) -&gt;
<font color=red>     0..|      length(?SM_BACKEND:get_sessions(Server)).</font>
        |  
        |  
        |  -spec get_vh_session_list(ejabberd:server()) -&gt; [ses_tuple()].
        |  get_vh_session_list(Server) -&gt;
<font color=red>     0..|      ?SM_BACKEND:get_sessions(Server).</font>
        |  
        |  
        |  -spec get_node_sessions_number() -&gt; non_neg_integer().
        |  get_node_sessions_number() -&gt;
<font color=red>     0..|      {value, {active, Active}} = lists:keysearch(active, 1, supervisor:count_children(ejabberd_c2s_sup)),</font>
<font color=red>     0..|      Active.</font>
        |  
        |  
        |  -spec get_full_session_list() -&gt; [session()].
        |  get_full_session_list() -&gt;
<font color=red>     0..|      ?SM_BACKEND:get_sessions().</font>
        |  
        |  
        |  register_iq_handler(Host, XMLNS, Module, Fun) -&gt;
<font color=red>     0..|      ejabberd_sm ! {register_iq_handler, Host, XMLNS, Module, Fun}.</font>
        |  
        |  
        |  register_iq_handler(Host, XMLNS, Module, Fun, Opts) -&gt;
<font color=red>     0..|      ejabberd_sm ! {register_iq_handler, Host, XMLNS, Module, Fun, Opts}.</font>
        |  
        |  
        |  unregister_iq_handler(Host, XMLNS) -&gt;
<font color=red>     0..|      ejabberd_sm ! {unregister_iq_handler, Host, XMLNS}.</font>
        |  
        |  %%====================================================================
        |  %% Hook handlers
        |  %%====================================================================
        |  
        |  node_cleanup(Node) -&gt;
<font color=red>     0..|      gen_server:call(?MODULE, {node_cleanup, Node}).</font>
        |  
        |  %%====================================================================
        |  %% gen_server callbacks
        |  %%====================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% Function: init(Args) -&gt; {ok, State} |
        |  %%                         {ok, State, Timeout} |
        |  %%                         ignore               |
        |  %%                         {stop, Reason}
        |  %% Description: Initiates the server
        |  %%--------------------------------------------------------------------
        |  -spec init(_) -&gt; {ok, state()}.
        |  init([]) -&gt;
<font color=red>     0..|      {Backend, Opts} = ejabberd_config:get_global_option(sm_backend),</font>
<font color=red>     0..|      {Mod, Code} = dynamic_compile:from_string(sm_backend(Backend)),</font>
<font color=red>     0..|      code:load_binary(Mod, "ejabberd_sm_backend.erl", Code),</font>
        |  
<font color=red>     0..|      ets:new(sm_iqtable, [named_table]),</font>
<font color=red>     0..|      ejabberd_hooks:add(node_cleanup, global, ?MODULE, node_cleanup, 50),</font>
<font color=red>     0..|      lists:foreach(</font>
        |        fun(Host) -&gt;
<font color=red>     0..|                ejabberd_hooks:add(roster_in_subscription, Host,</font>
        |                                   ejabberd_sm, check_in_subscription, 20),
<font color=red>     0..|                ejabberd_hooks:add(offline_message_hook, Host,</font>
        |                                   ejabberd_sm, bounce_offline_message, 100),
<font color=red>     0..|                ejabberd_hooks:add(remove_user, Host,</font>
        |                                   ejabberd_sm, disconnect_removed_user, 100)
        |        end, ?MYHOSTS),
<font color=red>     0..|      ejabberd_commands:register_commands(commands()),</font>
        |  
<font color=red>     0..|      ?SM_BACKEND:start(Opts),</font>
        |  
<font color=red>     0..|      {ok, #state{}}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% Function: %% handle_call(Request, From, State) -&gt; {reply, Reply, State} |
        |  %%                                      {reply, Reply, State, Timeout} |
        |  %%                                      {noreply, State} |
        |  %%                                      {noreply, State, Timeout} |
        |  %%                                      {stop, Reason, Reply, State} |
        |  %%                                      {stop, Reason, State}
        |  %% Description: Handling call messages
        |  %%--------------------------------------------------------------------
        |  handle_call({node_cleanup, Node}, _From, State) -&gt;
<font color=red>     0..|      BackendModule = ?SM_BACKEND,</font>
<font color=red>     0..|      {TimeDiff, _R} = timer:tc(fun BackendModule:cleanup/1, [Node]),</font>
<font color=red>     0..|      ?INFO_MSG("sessions cleanup after node=~p, took=~pms",</font>
        |                [Node, erlang:round(TimeDiff / 1000)]),
<font color=red>     0..|      {reply, ok, State};</font>
        |  handle_call(_Request, _From, State) -&gt;
<font color=red>     0..|      Reply = ok,</font>
<font color=red>     0..|      {reply, Reply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% Function: handle_cast(Msg, State) -&gt; {noreply, State} |
        |  %%                                      {noreply, State, Timeout} |
        |  %%                                      {stop, Reason, State}
        |  %% Description: Handling cast messages
        |  %%--------------------------------------------------------------------
        |  handle_cast(_Msg, State) -&gt;
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% Function: handle_info(Info, State) -&gt; {noreply, State} |
        |  %%                                       {noreply, State, Timeout} |
        |  %%                                       {stop, Reason, State}
        |  %% Description: Handling all non call/cast messages
        |  %%--------------------------------------------------------------------
        |  -spec handle_info(_,_) -&gt; {'noreply',_}.
        |  handle_info({route, From, To, Packet}, State) -&gt;
<font color=red>     0..|      xmpp_router:route(?MODULE,From,To,Packet),</font>
<font color=red>     0..|      {noreply, State};</font>
        |  handle_info({register_iq_handler, Host, XMLNS, Module, Function}, State) -&gt;
<font color=red>     0..|      ets:insert(sm_iqtable, {{XMLNS, Host}, Module, Function}),</font>
<font color=red>     0..|      {noreply, State};</font>
        |  handle_info({register_iq_handler, Host, XMLNS, Module, Function, Opts}, State) -&gt;
<font color=red>     0..|      ets:insert(sm_iqtable, {{XMLNS, Host}, Module, Function, Opts}),</font>
<font color=red>     0..|      {noreply, State};</font>
        |  handle_info({unregister_iq_handler, Host, XMLNS}, State) -&gt;
<font color=red>     0..|      case ets:lookup(sm_iqtable, {XMLNS, Host}) of</font>
        |          [{_, Module, Function, Opts}] -&gt;
<font color=red>     0..|              gen_iq_handler:stop_iq_handler(Module, Function, Opts);</font>
        |          _ -&gt;
<font color=red>     0..|              ok</font>
        |      end,
<font color=red>     0..|      ets:delete(sm_iqtable, {XMLNS, Host}),</font>
<font color=red>     0..|      {noreply, State};</font>
        |  handle_info(_Info, State) -&gt;
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% Function: terminate(Reason, State) -&gt; void()
        |  %% Description: This function is called by a gen_server when it is about to
        |  %% terminate. It should be the opposite of Module:init/1 and do any necessary
        |  %% cleaning up. When it returns, the gen_server terminates with Reason.
        |  %% The return value is ignored.
        |  %%--------------------------------------------------------------------
        |  -spec terminate(_,state()) -&gt; 'ok'.
        |  terminate(_Reason, _State) -&gt;
<font color=red>     0..|      ejabberd_commands:unregister_commands(commands()),</font>
<font color=red>     0..|      ok.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% Func: code_change(OldVsn, State, Extra) -&gt; {ok, NewState}
        |  %% Description: Convert process state when code is changed
        |  %%--------------------------------------------------------------------
        |  code_change(_OldVsn, State, _Extra) -&gt;
<font color=red>     0..|      {ok, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %%% Internal functions
        |  %%--------------------------------------------------------------------
        |  
        |  -spec set_session(SID, User, Server, Resource, Prio, Info) -&gt; ok | {error, any()} when
        |        SID :: sid() | 'undefined',
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        Resource :: ejabberd:resource(),
        |        Prio :: priority(),
        |        Info :: undefined | [any()].
        |  set_session(SID, User, Server, Resource, Priority, Info) -&gt;
<font color=red>     0..|      LUser = jid:nodeprep(User),</font>
<font color=red>     0..|      LServer = jid:nameprep(Server),</font>
<font color=red>     0..|      LResource = jid:resourceprep(Resource),</font>
<font color=red>     0..|      US = {LUser, LServer},</font>
<font color=red>     0..|      USR = {LUser, LServer, LResource},</font>
<font color=red>     0..|      Session = #session{sid = SID,</font>
        |                         usr = USR,
        |                         us = US,
        |                         priority = Priority,
        |                         info = Info},
<font color=red>     0..|      ?SM_BACKEND:create_session(LUser, LServer, LResource, Session).</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  -spec do_route(From, To, Packet) -&gt; any() when
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel() | ejabberd_c2s:broadcast().
        |  do_route(From, To, {broadcast, _} = Broadcast) -&gt;
<font color=red>     0..|      ?DEBUG("from=~p,to=~p,broadcast=~p", [From, To, Broadcast]),</font>
<font color=red>     0..|      #jid{ luser = LUser, lserver = LServer, lresource = LResource} = To,</font>
<font color=red>     0..|      case LResource of</font>
        |          &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|              CurrentPids = get_user_present_pids(LUser, LServer),</font>
<font color=red>     0..|              ejabberd_hooks:run(sm_broadcast, To#jid.lserver,</font>
        |                                 [From, To, Broadcast, length(CurrentPids)]),
<font color=red>     0..|              ?DEBUG("bc_to=~p~n", CurrentPids),</font>
<font color=red>     0..|              lists:foreach(fun({_, Pid}) -&gt; Pid ! Broadcast end, CurrentPids);</font>
        |          _ -&gt;
<font color=red>     0..|              case ?SM_BACKEND:get_sessions(LUser, LServer, LResource) of</font>
        |                  [] -&gt;
<font color=red>     0..|                      ok; % do nothing</font>
        |                  Ss -&gt;
<font color=red>     0..|                      Session = lists:max(Ss),</font>
<font color=red>     0..|                      Pid = element(2, Session#session.sid),</font>
<font color=red>     0..|                      ?DEBUG("sending to process ~p~n", [Pid]),</font>
<font color=red>     0..|                      Pid ! Broadcast</font>
        |              end
        |      end;
        |  do_route(From, To, Packet) -&gt;
<font color=red>     0..|      ?DEBUG("session manager~n\tfrom ~p~n\tto ~p~n\tpacket ~P~n",</font>
        |             [From, To, Packet, 8]),
<font color=red>     0..|      #jid{ luser = LUser, lserver = LServer, lresource = LResource} = To,</font>
<font color=red>     0..|      #xmlel{name = Name, attrs = Attrs} = Packet,</font>
<font color=red>     0..|      case LResource of</font>
        |          &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|              do_route_no_resource(Name, xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs),</font>
        |                                   From, To, Packet);
        |          _ -&gt;
<font color=red>     0..|              case ?SM_BACKEND:get_sessions(LUser, LServer, LResource) of</font>
        |                  [] -&gt;
<font color=red>     0..|                      do_route_offline(Name, xml:get_attr_s(&lt;&lt;"type"&gt;&gt;, Attrs),</font>
        |                                       From, To, Packet);
        |                  Ss -&gt;
<font color=red>     0..|                      Session = lists:max(Ss),</font>
<font color=red>     0..|                      Pid = element(2, Session#session.sid),</font>
<font color=red>     0..|                      ?DEBUG("sending to process ~p~n", [Pid]),</font>
<font color=red>     0..|                      Pid ! {route, From, To, Packet}</font>
        |              end
        |      end.
        |  
        |  -spec do_route_no_resource_presence_prv(From, To, Packet, Type, Reason) -&gt; boolean() when
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel(),
        |        Type :: 'subscribe' | 'subscribed' | 'unsubscribe' | 'unsubscribed',
        |        Reason :: any().
        |  do_route_no_resource_presence_prv(From,To,Packet,Type,Reason) -&gt;
<font color=red>     0..|      is_privacy_allow(From, To, Packet) andalso ejabberd_hooks:run_fold(</font>
        |          roster_in_subscription,
        |          To#jid.lserver,
        |          false,
        |          [To#jid.user, To#jid.server, From, Type, Reason]).
        |  
        |  
        |  -spec do_route_no_resource_presence(Type, From, To, Packet) -&gt; boolean() when
        |        Type :: binary(),
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel().
        |  do_route_no_resource_presence(&lt;&lt;"subscribe"&gt;&gt;, From, To, Packet) -&gt;
<font color=red>     0..|          Reason = xml:get_path_s(Packet, [{elem, &lt;&lt;"status"&gt;&gt;}, cdata]),</font>
<font color=red>     0..|          do_route_no_resource_presence_prv(From, To, Packet, subscribe, Reason);</font>
        |  do_route_no_resource_presence(&lt;&lt;"subscribed"&gt;&gt;, From, To, Packet) -&gt;
<font color=red>     0..|          do_route_no_resource_presence_prv(From, To, Packet, subscribed, &lt;&lt;&gt;&gt;);</font>
        |  do_route_no_resource_presence(&lt;&lt;"unsubscribe"&gt;&gt;, From, To, Packet) -&gt;
<font color=red>     0..|          do_route_no_resource_presence_prv(From, To, Packet, unsubscribe, &lt;&lt;&gt;&gt;);</font>
        |  do_route_no_resource_presence(&lt;&lt;"unsubscribed"&gt;&gt;, From, To, Packet) -&gt;
<font color=red>     0..|          do_route_no_resource_presence_prv(From, To, Packet, unsubscribed, &lt;&lt;&gt;&gt;);</font>
        |  do_route_no_resource_presence(_, _, _, _) -&gt;
<font color=red>     0..|          true.</font>
        |  
        |  
        |  -spec do_route_no_resource(Name, Type, From, To, Packet) -&gt; Result when
        |        Name :: undefined | binary(),
        |        Type :: any(),
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel(),
        |        Result ::ok | stop | todo | pid() | {error, lager_not_running} | {process_iq, _, _, _}.
        |  do_route_no_resource(&lt;&lt;"presence"&gt;&gt;, Type, From, To, Packet) -&gt;
<font color=red>     0..|          case do_route_no_resource_presence(Type, From, To, Packet) of</font>
        |              true -&gt;
<font color=red>     0..|              PResources = get_user_present_resources(To#jid.luser, To#jid.lserver),</font>
<font color=red>     0..|                      lists:foreach(</font>
        |                        fun({_, R}) -&gt;
<font color=red>     0..|        do_route(From, jid:replace_resource(To, R), Packet)</font>
        |                end, PResources);
        |              false -&gt;
<font color=red>     0..|                  ok</font>
        |          end;
        |  do_route_no_resource(&lt;&lt;"message"&gt;&gt;, _, From, To, Packet) -&gt;
<font color=red>     0..|          route_message(From, To, Packet);</font>
        |  do_route_no_resource(&lt;&lt;"iq"&gt;&gt;, _, From, To, Packet) -&gt;
<font color=red>     0..|          process_iq(From, To, Packet);</font>
        |  do_route_no_resource(&lt;&lt;"broadcast"&gt;&gt;, _, From, To, Packet) -&gt;
        |      % Backward compatibility
<font color=red>     0..|      ejabberd_hooks:run(sm_broadcast, To#jid.lserver, [From, To, Packet]),</font>
<font color=red>     0..|      broadcast_packet(From, To, Packet);</font>
        |  do_route_no_resource(_, _, _, _, _) -&gt;
<font color=red>     0..|          ok.</font>
        |  
        |  -spec do_route_offline(Name, Type, From, To, Packet) -&gt; ok | stop when
        |        Name :: 'undefined' | binary(),
        |        Type :: binary(),
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel().
        |  do_route_offline(&lt;&lt;"message"&gt;&gt;, _, From, To, Packet)  -&gt;
<font color=red>     0..|          route_message(From, To, Packet);</font>
        |  do_route_offline(&lt;&lt;"iq"&gt;&gt;, &lt;&lt;"error"&gt;&gt;, _From, _To, _Packet) -&gt;
<font color=red>     0..|          ok;</font>
        |  do_route_offline(&lt;&lt;"iq"&gt;&gt;, &lt;&lt;"result"&gt;&gt;, _From, _To, _Packet) -&gt;
<font color=red>     0..|          ok;</font>
        |  do_route_offline(&lt;&lt;"iq"&gt;&gt;, _, From, To, Packet) -&gt;
<font color=red>     0..|          Err = jlib:make_error_reply(Packet, ?ERR_SERVICE_UNAVAILABLE),</font>
<font color=red>     0..|          ejabberd_router:route(To, From, Err);</font>
        |  do_route_offline(_, _, _, _, _) -&gt;
<font color=red>     0..|          ?DEBUG("packet droped~n", []),</font>
<font color=red>     0..|          ok.</font>
        |  
        |  % Backward compatibility
        |  -spec broadcast_packet(From :: ejabberd:jid(), To :: ejabberd:jid(), Packet :: jlib:xmlel()) -&gt; ok.
        |  broadcast_packet(From, To, Packet) -&gt;
<font color=red>     0..|      #jid{user = User, server = Server} = To,</font>
<font color=red>     0..|      lists:foreach(</font>
        |        fun(R) -&gt;
<font color=red>     0..|                do_route(From,</font>
        |                         jid:replace_resource(To, R),
        |                         Packet)
        |        end, get_user_resources(User, Server)).
        |  
        |  %% @doc The default list applies to the user as a whole,
        |  %% and is processed if there is no active list set
        |  %% for the target session/resource to which a stanza is addressed,
        |  %% or if there are no current sessions for the user.
        |  -spec is_privacy_allow(From, To, Packet) -&gt; boolean() when
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel().
        |  is_privacy_allow(From, To, Packet) -&gt;
<font color=red>     0..|      User = To#jid.user,</font>
<font color=red>     0..|      Server = To#jid.server,</font>
<font color=red>     0..|      PrivacyList = ejabberd_hooks:run_fold(privacy_get_user_list, Server,</font>
        |                                            #userlist{}, [User, Server]),
<font color=red>     0..|      is_privacy_allow(From, To, Packet, PrivacyList).</font>
        |  
        |  
        |  %% @doc Check if privacy rules allow this delivery
        |  %% Function copied from ejabberd_c2s.erl
        |  -spec is_privacy_allow(From, To, Packet, PrivacyList) -&gt; boolean() when
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel(),
        |        PrivacyList :: list().
        |  is_privacy_allow(From, To, Packet, PrivacyList) -&gt;
<font color=red>     0..|      User = To#jid.user,</font>
<font color=red>     0..|      Server = To#jid.server,</font>
<font color=red>     0..|      allow == ejabberd_hooks:run_fold(</font>
        |                 privacy_check_packet, Server,
        |                 allow,
        |                 [User, Server, PrivacyList,
        |                  {From, To, Packet}, in]).
        |  
        |  
        |  -spec route_message(From, To, Packet) -&gt; ok | stop when
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel().
        |  route_message(From, To, Packet) -&gt;
<font color=red>     0..|      LUser = To#jid.luser,</font>
<font color=red>     0..|      LServer = To#jid.lserver,</font>
<font color=red>     0..|      PrioPid = get_user_present_pids(LUser,LServer),</font>
<font color=red>     0..|      case catch lists:max(PrioPid) of</font>
        |          {Priority, _} when is_integer(Priority), Priority &gt;= 0 -&gt;
<font color=red>     0..|              lists:foreach(</font>
        |                %% Route messages to all priority that equals the max, if
        |                %% positive
        |                fun({Prio, Pid}) when Prio == Priority -&gt;
        |                        % we will lose message if PID is not alive
<font color=red>     0..|                        Pid ! {route, From, To, Packet};</font>
        |                   %% Ignore other priority:
        |                   ({_Prio, _Pid}) -&gt;
<font color=red>     0..|                        ok</font>
        |                end,
        |                PrioPid);
        |          _ -&gt;
<font color=red>     0..|              case xml:get_tag_attr_s(&lt;&lt;"type"&gt;&gt;, Packet) of</font>
        |                  &lt;&lt;"error"&gt;&gt; -&gt;
<font color=red>     0..|                      ok;</font>
        |                  &lt;&lt;"groupchat"&gt;&gt; -&gt;
<font color=red>     0..|                      bounce_offline_message(From, To, Packet);</font>
        |                  &lt;&lt;"headline"&gt;&gt; -&gt;
<font color=red>     0..|                      bounce_offline_message(From, To, Packet);</font>
        |                  _ -&gt;
<font color=red>     0..|                      case ejabberd_auth:is_user_exists(LUser, LServer) of</font>
        |                          true -&gt;
<font color=red>     0..|                              case is_privacy_allow(From, To, Packet) of</font>
        |                                  true -&gt;
<font color=red>     0..|                                      ejabberd_hooks:run(offline_message_hook,</font>
        |                                                         LServer,
        |                                                         [From, To, Packet]);
        |                                  false -&gt;
<font color=red>     0..|                                      ok</font>
        |                              end;
        |                          _ -&gt;
<font color=red>     0..|                              Err = jlib:make_error_reply(</font>
        |                                      Packet, ?ERR_SERVICE_UNAVAILABLE),
<font color=red>     0..|                              ejabberd_router:route(To, From, Err)</font>
        |                      end
        |              end
        |      end.
        |  
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  -spec clean_session_list([sid()]) -&gt; [sid()].
        |  clean_session_list(Ss) -&gt;
<font color=red>     0..|      clean_session_list(lists:keysort(#session.usr, Ss), []).</font>
        |  
        |  
        |  -spec clean_session_list([sid()],[sid()]) -&gt; [sid()].
        |  clean_session_list([], Res) -&gt;
<font color=red>     0..|      Res;</font>
        |  clean_session_list([S], Res) -&gt;
<font color=red>     0..|      [S | Res];</font>
        |  clean_session_list([S1, S2 | Rest], Res) -&gt;
<font color=red>     0..|      if</font>
        |          S1#session.usr == S2#session.usr -&gt;
<font color=red>     0..|              if</font>
        |                  S1#session.sid &gt; S2#session.sid -&gt;
<font color=red>     0..|                      clean_session_list([S1 | Rest], Res);</font>
        |                  true -&gt;
<font color=red>     0..|                      clean_session_list([S2 | Rest], Res)</font>
        |              end;
        |          true -&gt;
<font color=red>     0..|              clean_session_list([S2 | Rest], [S1 | Res])</font>
        |      end.
        |  
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  -spec get_user_present_pids(LUser, LServer) -&gt; [{priority(), pid()}] when
        |        LUser :: ejabberd:luser(),
        |        LServer :: ejabberd:lserver().
        |  get_user_present_pids(LUser, LServer) -&gt;
<font color=red>     0..|      Ss = clean_session_list(?SM_BACKEND:get_sessions(LUser, LServer)),</font>
<font color=red>     0..|      [{S#session.priority, element(2,S#session.sid)} || S &lt;- Ss, is_integer(S#session.priority)].</font>
        |  
        |  -spec get_user_present_resources(LUser :: ejabberd:user(),
        |                                   LServer :: ejabberd:server()
        |                                   ) -&gt; [{priority(), binary()}].
        |  get_user_present_resources(LUser, LServer) -&gt;
<font color=red>     0..|      Ss = ?SM_BACKEND:get_sessions(LUser, LServer),</font>
<font color=red>     0..|      [{S#session.priority, element(3, S#session.usr)} ||</font>
<font color=red>     0..|          S &lt;- clean_session_list(Ss), is_integer(S#session.priority)].</font>
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  %% @doc On new session, check if some existing connections need to be replace
        |  -spec check_for_sessions_to_replace(User, Server, Resource) -&gt; ok | replaced when
        |        User :: ejabberd:user(),
        |        Server :: ejabberd:server(),
        |        Resource :: ejabberd:resource().
        |  check_for_sessions_to_replace(User, Server, Resource) -&gt;
<font color=red>     0..|      LUser = jid:nodeprep(User),</font>
<font color=red>     0..|      LServer = jid:nameprep(Server),</font>
<font color=red>     0..|      LResource = jid:resourceprep(Resource),</font>
        |  
        |      %% TODO: Depending on how this is executed, there could be an unneeded
        |      %% replacement for max_sessions. We need to check this at some point.
<font color=red>     0..|      check_existing_resources(LUser, LServer, LResource),</font>
<font color=red>     0..|      check_max_sessions(LUser, LServer).</font>
        |  
        |  -spec check_existing_resources(LUser, LServer, LResource) -&gt; ok when
        |        LUser :: 'error' | ejabberd:luser() | tuple(),
        |        LServer :: 'error' | ejabberd:lserver() | tuple(),
        |        LResource :: 'error' | ejabberd:lresource() | [byte()] | tuple().
        |  check_existing_resources(LUser, LServer, LResource) -&gt;
        |      %% A connection exist with the same resource. We replace it:
<font color=red>     0..|      Sessions = ?SM_BACKEND:get_sessions(LUser, LServer, LResource),</font>
<font color=red>     0..|      SIDs = [S#session.sid || S &lt;- Sessions],</font>
<font color=red>     0..|      if</font>
        |          SIDs == [] -&gt;
<font color=red>     0..|              ok;</font>
        |          true -&gt;
<font color=red>     0..|              MaxSID = lists:max(SIDs),</font>
<font color=red>     0..|              lists:foreach(</font>
        |                fun({_, Pid} = S) when S /= MaxSID -&gt;
<font color=red>     0..|                        Pid ! replaced;</font>
<font color=red>     0..|                   (_) -&gt; ok</font>
        |                end, SIDs)
        |      end.
        |  
        |  
        |  -spec check_max_sessions(LUser :: ejabberd:user(), LServer :: ejabberd:server()) -&gt; ok | replaced.
        |  check_max_sessions(LUser, LServer) -&gt;
        |      %% If the max number of sessions for a given is reached, we replace the
        |      %% first one
<font color=red>     0..|      Sessions = ?SM_BACKEND:get_sessions(LUser, LServer),</font>
<font color=red>     0..|      SIDs = [S#session.sid || S &lt;- Sessions],</font>
<font color=red>     0..|      MaxSessions = get_max_user_sessions(LUser, LServer),</font>
<font color=red>     0..|      if</font>
        |          length(SIDs) =&lt; MaxSessions -&gt;
<font color=red>     0..|              ok;</font>
        |          true -&gt;
<font color=red>     0..|              {_, Pid} = lists:min(SIDs),</font>
<font color=red>     0..|              Pid ! replaced</font>
        |      end.
        |  
        |  
        |  %% @doc Get the user_max_session setting
        |  %% This option defines the max number of time a given users are allowed to
        |  %% log in. Defaults to infinity
        |  -spec get_max_user_sessions(LUser, Host) -&gt; infinity | pos_integer() when
        |        LUser :: ejabberd:user(),
        |        Host :: ejabberd:server().
        |  get_max_user_sessions(LUser, Host) -&gt;
<font color=red>     0..|      case acl:match_rule(</font>
        |             Host, max_user_sessions, jid:make(LUser, Host, &lt;&lt;&gt;&gt;)) of
<font color=red>     0..|          Max when is_integer(Max) -&gt; Max;</font>
<font color=red>     0..|          infinity -&gt; infinity;</font>
<font color=red>     0..|          _ -&gt; ?MAX_USER_SESSIONS</font>
        |      end.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  -spec process_iq(From, To, Packet) -&gt; Result when
        |        From :: ejabberd:jid(),
        |        To :: ejabberd:jid(),
        |        Packet :: jlib:xmlel(),
        |        Result :: ok | todo | pid() | {error, lager_not_running} | {process_iq, _, _, _}.
        |  process_iq(From, To, Packet) -&gt;
<font color=red>     0..|      IQ = jlib:iq_query_info(Packet),</font>
<font color=red>     0..|      case IQ of</font>
        |          #iq{xmlns = XMLNS} -&gt;
<font color=red>     0..|              Host = To#jid.lserver,</font>
<font color=red>     0..|              case ets:lookup(sm_iqtable, {XMLNS, Host}) of</font>
        |                  [{_, Module, Function}] -&gt;
<font color=red>     0..|                      ResIQ = Module:Function(From, To, IQ),</font>
<font color=red>     0..|                      if</font>
        |                          ResIQ /= ignore -&gt;
<font color=red>     0..|                              ejabberd_router:route(To, From,</font>
        |                                                    jlib:iq_to_xml(ResIQ));
        |                          true -&gt;
<font color=red>     0..|                              ok</font>
        |                      end;
        |                  [{_, Module, Function, Opts}] -&gt;
<font color=red>     0..|                      gen_iq_handler:handle(Host, Module, Function, Opts,</font>
        |                                            From, To, IQ);
        |                  [] -&gt;
<font color=red>     0..|                      Err = jlib:make_error_reply(</font>
        |                              Packet, ?ERR_SERVICE_UNAVAILABLE),
<font color=red>     0..|                      ejabberd_router:route(To, From, Err)</font>
        |              end;
        |          reply -&gt;
<font color=red>     0..|              ok;</font>
        |          _ -&gt;
<font color=red>     0..|              Err = jlib:make_error_reply(Packet, ?ERR_BAD_REQUEST),</font>
<font color=red>     0..|              ejabberd_router:route(To, From, Err),</font>
<font color=red>     0..|              ok</font>
        |      end.
        |  
        |  
        |  -spec force_update_presence({binary(), ejabberd:server()}) -&gt; 'ok'.
        |  force_update_presence({LUser, LServer}) -&gt;
<font color=red>     0..|      Ss = ?SM_BACKEND:get_sessions(LUser, LServer),</font>
<font color=red>     0..|      lists:foreach(fun(#session{sid = {_, Pid}}) -&gt;</font>
<font color=red>     0..|                            Pid ! {force_update_presence, LUser}</font>
        |                    end, Ss).
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%% ejabberd commands
        |  
        |  -spec commands() -&gt; [ejabberd_commands:cmd(), ...].
        |  commands() -&gt;
<font color=red>     0..|          [</font>
        |       %% TODO: Implement following API functions with pluggable backends architcture
        |       %% #ejabberd_commands{name = connected_users,
        |       %%                    tags = [session],
        |       %%                    desc = "List all established sessions",
        |       %%                    module = ?MODULE, function = connected_users,
        |       %%                    args = [],
        |       %%                    result = {connected_users, {list, {sessions, string}}}},
        |       %% #ejabberd_commands{name = connected_users_number,
        |       %%                    tags = [session, stats],
        |       %%                    desc = "Get the number of established sessions",
        |       %%                    module = ?MODULE, function = connected_users_number,
        |       %%                    args = [],
        |       %%                    result = {num_sessions, integer}},
        |       #ejabberd_commands{name = user_resources,
        |                          tags = [session],
        |                          desc = "List user's connected resources",
        |                          module = ?MODULE, function = user_resources,
        |                          args = [{user, string}, {host, string}],
        |                          result = {resources, {list, {resource, binary}}}}
        |          ].
        |  
        |  
        |  -spec user_resources(UserStr :: string(), ServerStr :: string()) -&gt; [binary()].
        |  user_resources(UserStr, ServerStr) -&gt;
<font color=red>     0..|      Resources = get_user_resources(list_to_binary(UserStr), list_to_binary(ServerStr)),</font>
<font color=red>     0..|      lists:sort(Resources).</font>
        |  
        |  -spec sm_backend(backend()) -&gt; string().
        |  sm_backend(Backend) -&gt;
<font color=red>     0..|      lists:flatten(</font>
        |        ["-module(ejabberd_sm_backend).
        |          -export([backend/0]).
        |  
        |          -spec backend() -&gt; atom().
        |          backend() -&gt;
        |              ejabberd_sm_",
        |         atom_to_list(Backend),
        |         ".\n"]).
        |  
        |  -spec get_cached_unique_count() -&gt; non_neg_integer().
        |  get_cached_unique_count() -&gt;
<font color=red>     0..|      case mongoose_metrics:get_metric_value(?UNIQUE_COUNT_CACHE) of</font>
        |          {ok, DataPoints} -&gt;
<font color=red>     0..|              proplists:get_value(value, DataPoints);</font>
        |          _ -&gt;
<font color=red>     0..|              0</font>
        |      end.
        |  
</pre>
</body>
</html>
