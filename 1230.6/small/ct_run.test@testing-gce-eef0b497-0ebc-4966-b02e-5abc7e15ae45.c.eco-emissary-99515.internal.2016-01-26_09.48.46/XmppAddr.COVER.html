<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/travis/build/esl/MongooseIM/apps/ejabberd/logs/ct_run.test@testing-gce-eef0b497-0ebc-4966-b02e-5abc7e15ae45.c.eco-emissary-99515.internal.2016-01-26_09.48.46/XmppAddr.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/esl/MongooseIM/apps/ejabberd/ebin/../src/XmppAddr.erl by COVER 2016-01-26 at 09:49:22

****************************************************************************

        |  %% Generated by the Erlang ASN.1 BER_V2-compiler version, utilizing bit-syntax:3.0.4
        |  %% Purpose: encoder and decoder to the types in mod XmppAddr
        |  
        |  -module('XmppAddr').
        |  -compile(nowarn_unused_vars).
        |  -include("XmppAddr.hrl").
        |  -asn1_info([{vsn,'3.0.4'},
        |              {module,'XmppAddr'},
        |              {options,[{i,"src"},{outdir,"src"},noobj,{i,"."},{i,"asn1"}]}]).
        |  
        |  -export([encoding_rule/0,bit_string_format/0,
        |           legacy_erlang_types/0]).
        |  -export(['dialyzer-suppressions'/1]).
        |  -export([
        |  'enc_XmppAddr'/2
        |  ]).
        |  
        |  -export([
        |  'dec_XmppAddr'/2
        |  ]).
        |  
        |  -export([
        |  'id-on-xmppAddr'/0
        |  ]).
        |  
        |  -export([info/0]).
        |  
        |  
        |  -export([encode/2,decode/2]).
        |  
<font color=red>     0..|  encoding_rule() -&gt; ber.</font>
        |  
<font color=red>     0..|  bit_string_format() -&gt; bitstring.</font>
        |  
<font color=red>     0..|  legacy_erlang_types() -&gt; false.</font>
        |  
        |  encode(Type, Data) -&gt;
<font color=red>     0..|  try iolist_to_binary(element(1, encode_disp(Type, Data))) of</font>
        |    Bytes -&gt;
<font color=red>     0..|      {ok,Bytes}</font>
        |    catch
        |      Class:Exception when Class =:= error; Class =:= exit -&gt;
<font color=red>     0..|        case Exception of</font>
        |          {error,Reason}=Error -&gt;
<font color=red>     0..|            Error;</font>
        |          Reason -&gt;
<font color=red>     0..|           {error,{asn1,Reason}}</font>
        |        end
        |  end.
        |  
        |  decode(Type,Data) -&gt;
<font color=red>     0..|  try decode_disp(Type, element(1, ber_decode_nif(Data))) of</font>
        |    Result -&gt;
<font color=red>     0..|      {ok,Result}</font>
        |    catch
        |      Class:Exception when Class =:= error; Class =:= exit -&gt;
<font color=red>     0..|        case Exception of</font>
        |          {error,Reason}=Error -&gt;
<font color=red>     0..|            Error;</font>
        |          Reason -&gt;
<font color=red>     0..|           {error,{asn1,Reason}}</font>
        |        end
        |  end.
        |  
<font color=red>     0..|  encode_disp('XmppAddr',Data) -&gt; 'enc_XmppAddr'(Data);</font>
<font color=red>     0..|  encode_disp(Type,_Data) -&gt; exit({error,{asn1,{undefined_type,Type}}}).</font>
        |  
        |  
<font color=red>     0..|  decode_disp('XmppAddr',Data) -&gt; 'dec_XmppAddr'(Data);</font>
<font color=red>     0..|  decode_disp(Type,_Data) -&gt; exit({error,{asn1,{undefined_type,Type}}}).</font>
        |  
        |  
        |  
        |  
        |  info() -&gt;
<font color=red>     0..|     case ?MODULE:module_info(attributes) of</font>
        |       Attributes when is_list(Attributes) -&gt;
<font color=red>     0..|         case lists:keyfind(asn1_info, 1, Attributes) of</font>
        |           {_,Info} when is_list(Info) -&gt;
<font color=red>     0..|             Info;</font>
        |           _ -&gt;
<font color=red>     0..|             []</font>
        |         end;
        |       _ -&gt;
<font color=red>     0..|         []</font>
        |     end.
        |  
        |  
        |  %%================================
        |  %%  XmppAddr
        |  %%================================
        |  'enc_XmppAddr'(Val) -&gt;
<font color=red>     0..|      'enc_XmppAddr'(Val, [&lt;&lt;12&gt;&gt;]).</font>
        |  
        |  'enc_XmppAddr'(Val, TagIn) -&gt;
<font color=red>     0..|  encode_UTF8_string(Val, TagIn).</font>
        |  
        |  
        |  'dec_XmppAddr'(Tlv) -&gt;
<font color=red>     0..|     'dec_XmppAddr'(Tlv, [12]).</font>
        |  
        |  'dec_XmppAddr'(Tlv, TagIn) -&gt;
<font color=red>     0..|  decode_UTF8_string(Tlv, TagIn).</font>
        |  
        |  'id-on-xmppAddr'() -&gt;
<font color=red>     0..|  {1,3,6,1,5,5,7,8,5}.</font>
        |  
        |  
        |  %%%
        |  %%% Run-time functions.
        |  %%%
        |  
        |  'dialyzer-suppressions'(Arg) -&gt;
<font color=red>     0..|      ok.</font>
        |  
        |  ber_decode_nif(B) -&gt;
<font color=red>     0..|      asn1rt_nif:decode_ber_tlv(B).</font>
        |  
        |  collect_parts(TlvList) -&gt;
<font color=red>     0..|      collect_parts(TlvList, []).</font>
        |  
        |  collect_parts([{_,L}|Rest], Acc) when is_list(L) -&gt;
<font color=red>     0..|      collect_parts(Rest, [collect_parts(L)|Acc]);</font>
        |  collect_parts([{3,&lt;&lt;Unused,Bits/binary&gt;&gt;}|Rest], _Acc) -&gt;
<font color=red>     0..|      collect_parts_bit(Rest, [Bits], Unused);</font>
        |  collect_parts([{_T,V}|Rest], Acc) -&gt;
<font color=red>     0..|      collect_parts(Rest, [V|Acc]);</font>
        |  collect_parts([], Acc) -&gt;
<font color=red>     0..|      list_to_binary(lists:reverse(Acc)).</font>
        |  
        |  collect_parts_bit([{3,&lt;&lt;Unused,Bits/binary&gt;&gt;}|Rest], Acc, Uacc) -&gt;
<font color=red>     0..|      collect_parts_bit(Rest, [Bits|Acc], Unused + Uacc);</font>
        |  collect_parts_bit([], Acc, Uacc) -&gt;
<font color=red>     0..|      list_to_binary([Uacc|lists:reverse(Acc)]).</font>
        |  
        |  decode_UTF8_string(Tlv, TagsIn) -&gt;
<font color=red>     0..|      Val = match_tags(Tlv, TagsIn),</font>
<font color=red>     0..|      case Val of</font>
        |          [_|_] = PartList -&gt;
<font color=red>     0..|              collect_parts(PartList);</font>
        |          Bin -&gt;
<font color=red>     0..|              Bin</font>
        |      end.
        |  
        |  encode_UTF8_string(UTF8String, TagIn) when is_binary(UTF8String) -&gt;
<font color=red>     0..|      encode_tags(TagIn, UTF8String, byte_size(UTF8String));</font>
        |  encode_UTF8_string(UTF8String, TagIn) -&gt;
<font color=red>     0..|      encode_tags(TagIn, UTF8String, length(UTF8String)).</font>
        |  
        |  encode_length(L) when L =&lt; 127 -&gt;
<font color=red>     0..|      {[L],1};</font>
        |  encode_length(L) -&gt;
<font color=red>     0..|      Oct = minimum_octets(L),</font>
<font color=red>     0..|      Len = length(Oct),</font>
<font color=red>     0..|      if</font>
        |          Len =&lt; 126 -&gt;
<font color=red>     0..|              {[128 bor Len|Oct],Len + 1};</font>
        |          true -&gt;
<font color=red>     0..|              exit({error,{asn1,too_long_length_oct,Len}})</font>
        |      end.
        |  
        |  encode_tags([Tag|Trest], BytesSoFar, LenSoFar) -&gt;
<font color=red>     0..|      {Bytes2,L2} = encode_length(LenSoFar),</font>
<font color=red>     0..|      encode_tags(Trest,</font>
        |                  [Tag,Bytes2|BytesSoFar],
        |                  LenSoFar + byte_size(Tag) + L2);
        |  encode_tags([], BytesSoFar, LenSoFar) -&gt;
<font color=red>     0..|      {BytesSoFar,LenSoFar}.</font>
        |  
        |  match_tags({T,V}, [T]) -&gt;
<font color=red>     0..|      V;</font>
        |  match_tags({T,V}, [T|Tt]) -&gt;
<font color=red>     0..|      match_tags(V, Tt);</font>
        |  match_tags([{T,V}], [T|Tt]) -&gt;
<font color=red>     0..|      match_tags(V, Tt);</font>
        |  match_tags([{T,_V}|_] = Vlist, [T]) -&gt;
<font color=red>     0..|      Vlist;</font>
        |  match_tags(Tlv, []) -&gt;
<font color=red>     0..|      Tlv;</font>
        |  match_tags({Tag,_V} = Tlv, [T|_Tt]) -&gt;
<font color=red>     0..|      exit({error,{asn1,{wrong_tag,{{expected,T},{got,Tag,Tlv}}}}}).</font>
        |  
        |  minimum_octets(0, Acc) -&gt;
<font color=red>     0..|      Acc;</font>
        |  minimum_octets(Val, Acc) -&gt;
<font color=red>     0..|      minimum_octets(Val bsr 8, [Val band 255|Acc]).</font>
        |  
        |  minimum_octets(Val) -&gt;
<font color=red>     0..|      minimum_octets(Val, []).</font>
</pre>
</body>
</html>
